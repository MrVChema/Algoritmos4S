# Script: Segmentaci√≥n de IVU e IVP por Segmento de Mercado y NSE
# Construcci√≥n de √≠ndices espec√≠ficos que eliminan sesgos de comparaci√≥n entre segmentos

# ---- 1. CONFIGURACI√ìN INICIAL ----
rm(list = ls())

library(dplyr)
library(ggplot2)
library(plotly)
library(leaflet)
library(corrplot)
library(knitr)
library(tidyr)
library(grid)
library(gridExtra)

# Establecer directorio de trabajo
setwd('/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[04] MODELACI√ìN/[00] RESULTADOS/IVU-IVP')

# ---- 2. CARGAR DATOS ----
datos <- read.csv('/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[04] MODELACI√ìN/[00] RESULTADOS/IVP/proyectos_con_ivp_v2_completo.csv', stringsAsFactors = FALSE)

cat("Base de datos cargada:\n")
cat("- Proyectos:", nrow(datos), "\n")
cat("- Variables:", ncol(datos), "\n")
cat("- Segmentos √∫nicos:", paste(unique(datos$Segmento[!is.na(datos$Segmento)]), collapse = ", "), "\n")
cat("- NSE √∫nicos:", paste(unique(datos$nse[!is.na(datos$nse)]), collapse = ", "), "\n")

# ---- 3. CREAR MATRIZ DE SEGMENTACI√ìN ----

# 3.1 Definir segmentos y NSE v√°lidos
segmentos_validos <- c("Premium Plus", "Premium", "Residencial Plus", "Residencial", "Medio")
nse_validos <- c("A+", "A", "B", "C+", "C", "D+", "D", "E")

# 3.2 Limpiar y estandarizar datos
datos_segmentados <- datos %>%
  # Filtrar solo segmentos v√°lidos
  filter(Segmento %in% segmentos_validos & nse %in% nse_validos) %>%
  # Crear combinaci√≥n segmento-NSE
  mutate(
    # Crear categor√≠a combinada
    segmento_nse = paste0(Segmento, " | NSE ", nse),
    
    # Crear categor√≠as amplias para an√°lisis
    categoria_segmento = case_when(
      Segmento %in% c("Premium Plus", "Premium") ~ "PREMIUM",
      Segmento %in% c("Residencial Plus", "Residencial") ~ "RESIDENCIAL", 
      Segmento == "Medio" ~ "MEDIO",
      TRUE ~ "OTRO"
    ),
    
    categoria_nse = case_when(
      nse %in% c("A+", "A") ~ "NSE_ALTO",
      nse %in% c("B", "C+") ~ "NSE_MEDIO_ALTO",
      nse %in% c("C", "D+") ~ "NSE_MEDIO",
      nse %in% c("D", "E") ~ "NSE_BAJO",
      TRUE ~ "NSE_OTRO"
    ),
    
    # Categor√≠a combinada simplificada
    categoria_combinada_simple = paste0(categoria_segmento, "_", categoria_nse)
  )

# 3.3 An√°lisis de distribuci√≥n
distribucion_segmentos <- datos_segmentados %>%
  count(segmento_nse) %>%
  arrange(desc(n))

cat("\nDistribuci√≥n de proyectos por Segmento-NSE:\n")
print(kable(distribucion_segmentos))

# Identificar combinaciones con suficientes datos (m√≠nimo 5 proyectos)
combinaciones_viables <- distribucion_segmentos %>%
  filter(n >= 5) %>%
  pull(segmento_nse)

cat("\nCombinaciones viables para an√°lisis (‚â•5 proyectos):", length(combinaciones_viables), "\n")

# ---- 4. DEFINIR FACTORES ESPEC√çFICOS POR SEGMENTO ----

# 4.1 Matriz de relevancia de factores por segmento
# 1 = No relevante, 2 = Poco relevante, 3 = Moderadamente relevante, 4 = Muy relevante, 5 = Cr√≠tico

factores_relevancia <- data.frame(
  Factor = c(
    # Cercan√≠as
    "cercania_hospital", "cercania_esc_priv", "cercania_esc_pub", "cercania_universidad",
    "cercania_super", "cercania_restau", "cercania_oficina", "cercania_tienda_dept",
    
    # Cantidades
    "cantidad_hospital_1km", "cantidad_esc_priv_1km", "cantidad_esc_pub_1km", "cantidad_universidad_1km",
    "cantidad_super_1km", "cantidad_restau_1km", "cantidad_oficina_1km", "cantidad_tienda_dept_1km",
    
    # Vialidades
    "cerca_avenida_principal", "cercania_avenida_arterial", "accesibilidad_vial",
    
    # √çndices
    "indice_accesibilidad", "potencial_inversion", "indice_conveniencia",
    
    # Otros
    "cerca_parque_relevante", "alta_densidad_comercial", "alto_entorno_laboral"
  ),
  
  # Pesos por segmento (1-5)
  Premium_Plus = c(
    # Cercan√≠as - Premium Plus valora exclusividad y calidad
    5, 5, 1, 4, 3, 4, 5, 4,  # Hospitales y escuelas privadas cr√≠ticos, p√∫blicas irrelevantes
    # Cantidades
    4, 4, 1, 3, 3, 4, 5, 3,  # Menos cantidad, m√°s calidad
    # Vialidades  
    4, 5, 5,  # Accesibilidad muy importante
    # √çndices
    5, 5, 4,  # Todos importantes
    # Otros
    5, 3, 4   # Parques muy importantes
  ),
  
  Premium = c(
    # Cercan√≠as - Premium busca balance calidad-conveniencia
    4, 5, 2, 4, 4, 4, 4, 4,
    # Cantidades
    4, 4, 2, 3, 4, 4, 4, 4,
    # Vialidades
    4, 4, 5,
    # √çndices  
    5, 4, 4,
    # Otros
    4, 4, 4
  ),
  
  Residencial_Plus = c(
    # Cercan√≠as - Residencial Plus valora funcionalidad y servicios
    4, 4, 3, 3, 5, 3, 3, 4,
    # Cantidades
    3, 3, 3, 3, 4, 3, 3, 4,
    # Vialidades
    4, 3, 4,
    # √çndices
    4, 4, 5,
    # Otros
    4, 4, 3
  ),
  
  Residencial = c(
    # Cercan√≠as - Residencial busca balance costo-beneficio
    3, 3, 4, 3, 5, 3, 3, 4,
    # Cantidades
    3, 3, 4, 3, 5, 3, 3, 4,
    # Vialidades
    4, 3, 4,
    # √çndices
    4, 3, 5,
    # Otros
    3, 4, 3
  ),
  
  Medio = c(
    # Cercan√≠as - Medio prioriza servicios b√°sicos y transporte
    4, 2, 5, 2, 5, 3, 2, 4,
    # Cantidades
    4, 2, 5, 2, 5, 3, 2, 4,
    # Vialidades
    5, 4, 5,  # Transporte muy cr√≠tico
    # √çndices
    4, 3, 5,
    # Otros
    3, 5, 2   # Densidad comercial muy importante
  )
)

# 4.2 Convertir a formato largo para an√°lisis
factores_relevancia_long <- factores_relevancia %>%
  pivot_longer(cols = -Factor, names_to = "Segmento", values_to = "Relevancia") %>%
  mutate(Segmento = gsub("_", " ", Segmento))

# Visualizar matriz de relevancia
heatmap_relevancia <- ggplot(factores_relevancia_long, 
                             aes(x = Segmento, y = Factor, fill = Relevancia)) +
  geom_tile(color = "white", linewidth = 0.5) +
  scale_fill_gradient2(low = "#EF6558", mid = "#F4E785", high = "#68D192", 
                       midpoint = 3, name = "Relevancia\n(1-5)") +
  labs(title = "Matriz de Relevancia de Factores por Segmento",
       subtitle = "Definici√≥n de pesos espec√≠ficos para cada mercado objetivo",
       x = "Segmento", y = "Factor") +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 8),
        axis.text.x = element_text(angle = 45, hjust = 1))

print(heatmap_relevancia)

# ---- 5. FUNCIONES PARA C√ÅLCULO SEGMENTADO ----

# 5.1 Funci√≥n para normalizar por segmento
normalizar_por_segmento <- function(datos, variable, segmento_col) {
  datos %>%
    group_by(!!sym(segmento_col)) %>%
    mutate(
      !!paste0(variable, "_norm_seg") := {
        valores = !!sym(variable)
        if(all(is.na(valores))) {
          rep(0.5, length(valores))
        } else {
          min_val = min(valores, na.rm = TRUE)
          max_val = max(valores, na.rm = TRUE)
          if(max_val == min_val) {
            rep(0.5, length(valores))
          } else {
            pmax(0, pmin(1, (valores - min_val) / (max_val - min_val)))
          }
        }
      }
    ) %>%
    ungroup()
}

# 5.2 Funci√≥n para calcular IVU segmentado
calcular_ivu_segmentado <- function(datos, factores_relevancia) {
  # Lista de factores disponibles en los datos
  factores_disponibles <- intersect(factores_relevancia$Factor, names(datos))
  
  cat("Factores disponibles para IVU segmentado:", length(factores_disponibles), "\n")
  
  # Verificar nombres de columnas en factores_relevancia
  cat("Columnas disponibles en factores_relevancia:", paste(names(factores_relevancia), collapse = ", "), "\n")
  
  # Calcular IVU para cada combinaci√≥n segmento-NSE
  datos_ivu_seg <- datos %>%
    group_by(segmento_nse) %>%
    filter(n() >= 3) %>%  # M√≠nimo 3 proyectos para c√°lculo
    do({
      df_grupo <- .
      segmento_actual <- unique(df_grupo$Segmento)[1]
      
      # Convertir espacios a guiones bajos para coincidir con nombres de columnas
      segmento_columna <- gsub(" ", "_", segmento_actual)
      
      cat("Procesando segmento:", segmento_actual, "(columna:", segmento_columna, ") con", nrow(df_grupo), "proyectos\n")
      
      # Verificar si existe la columna para este segmento
      if(segmento_columna %in% names(factores_relevancia)) {
        # Usar indexaci√≥n directa en lugar de select() con sym()
        col_index <- which(names(factores_relevancia) == segmento_columna)
        pesos_segmento <- data.frame(
          Factor = factores_relevancia$Factor,
          Peso = factores_relevancia[, col_index]
        )
        
        # Normalizar factores dentro del grupo
        ivu_segmentado <- rep(0, nrow(df_grupo))
        peso_total <- 0
        
        for(factor in factores_disponibles) {
          if(factor %in% pesos_segmento$Factor && factor %in% names(df_grupo)) {
            peso <- pesos_segmento$Peso[pesos_segmento$Factor == factor]
            valores_factor <- df_grupo[[factor]]
            
            # Normalizar dentro del grupo
            if(!all(is.na(valores_factor))) {
              min_val <- min(valores_factor, na.rm = TRUE)
              max_val <- max(valores_factor, na.rm = TRUE)
              
              if(max_val > min_val) {
                valores_norm <- (valores_factor - min_val) / (max_val - min_val)
                ivu_segmentado <- ivu_segmentado + (valores_norm * peso)
                peso_total <- peso_total + peso
              }
            }
          }
        }
        
        # Normalizar por peso total
        df_grupo$ivu_segmentado <- if(peso_total > 0) ivu_segmentado / peso_total else 0.5
        df_grupo$peso_total_usado <- peso_total
        
        cat("Completado segmento:", segmento_actual, "- Peso total usado:", peso_total, "\n")
      } else {
        df_grupo$ivu_segmentado <- df_grupo$ivu  # Usar IVU original si no hay pesos espec√≠ficos
        df_grupo$peso_total_usado <- 1
        cat("ADVERTENCIA: No se encontraron pesos para segmento:", segmento_actual, 
            "(columna buscada:", segmento_columna, ")\n")
        cat("Columnas disponibles:", paste(names(factores_relevancia), collapse = ", "), "\n")
      }
      
      df_grupo
    }) %>%
    ungroup()
  
  return(datos_ivu_seg)
}

# 5.3 Funci√≥n para calcular IVP segmentado  
calcular_ivp_segmentado <- function(datos) {
  datos %>%
    group_by(segmento_nse) %>%
    filter(n() >= 3) %>%
    mutate(
      # Normalizar amenidades dentro del segmento
      amenidades_norm_seg = {
        vals = score_amenidades_total
        if(all(is.na(vals)) || max(vals, na.rm = TRUE) == min(vals, na.rm = TRUE)) {
          rep(0.5, length(vals))
        } else {
          min_val = min(vals, na.rm = TRUE)
          max_val = max(vals, na.rm = TRUE)
          (vals - min_val) / (max_val - min_val)
        }
      },
      
      # Normalizar performance comercial dentro del segmento
      performance_norm_seg = {
        vals = eficiencia_comercial
        if(all(is.na(vals)) || max(vals, na.rm = TRUE) == min(vals, na.rm = TRUE)) {
          rep(0.5, length(vals))
        } else {
          min_val = min(vals, na.rm = TRUE)
          max_val = max(vals, na.rm = TRUE)
          (vals - min_val) / (max_val - min_val)
        }
      },
      
      # Calcular IVP segmentado con pesos ajustados por segmento
      ivp_segmentado = case_when(
        # Premium Plus: Mayor peso a amenidades y credibilidad desarrollador
        Segmento == "Premium Plus" ~ (amenidades_norm_seg * 0.45) + 
          (performance_norm_seg * 0.20) + 
          (credibilidad_desarrollador_v2 * 0.25) + 
          (propuesta_valor_norm_v2 * 0.10),
        
        # Premium: Balance entre amenidades y performance
        Segmento == "Premium" ~ (amenidades_norm_seg * 0.35) + 
          (performance_norm_seg * 0.30) + 
          (credibilidad_desarrollador_v2 * 0.20) + 
          (propuesta_valor_norm_v2 * 0.15),
        
        # Residencial Plus: Mayor peso a propuesta de valor
        Segmento == "Residencial Plus" ~ (amenidades_norm_seg * 0.25) + 
          (performance_norm_seg * 0.30) + 
          (credibilidad_desarrollador_v2 * 0.15) + 
          (propuesta_valor_norm_v2 * 0.30),
        
        # Residencial: Balance con √©nfasis en valor
        Segmento == "Residencial" ~ (amenidades_norm_seg * 0.20) + 
          (performance_norm_seg * 0.30) + 
          (credibilidad_desarrollador_v2 * 0.15) + 
          (propuesta_valor_norm_v2 * 0.35),
        
        # Medio: M√°ximo peso a propuesta de valor y performance
        Segmento == "Medio" ~ (amenidades_norm_seg * 0.15) + 
          (performance_norm_seg * 0.35) + 
          (credibilidad_desarrollador_v2 * 0.10) + 
          (propuesta_valor_norm_v2 * 0.40),
        
        TRUE ~ ivp_v2  # Usar IVP original como fallback
      ),
      
      # Categorizar IVP segmentado
      ivp_segmentado_categoria = cut(ivp_segmentado,
                                     breaks = c(0, 0.25, 0.45, 0.65, 0.80, 1.0),
                                     labels = c("Muy Bajo", "Bajo", "Medio", "Alto", "Muy Alto"),
                                     include.lowest = TRUE)
    ) %>%
    ungroup()
}

# ---- 6. APLICAR SEGMENTACI√ìN ----

# 6.1 Calcular IVU segmentado
cat("\n=== CALCULANDO IVU SEGMENTADO ===\n")
datos_segmentados <- calcular_ivu_segmentado(datos_segmentados, factores_relevancia)

# 6.2 Calcular IVP segmentado  
cat("=== CALCULANDO IVP SEGMENTADO ===\n")
datos_segmentados <- calcular_ivp_segmentado(datos_segmentados)

# 6.3 Crear categor√≠as segmentadas para IVU
datos_segmentados <- datos_segmentados %>%
  group_by(segmento_nse) %>%
  mutate(
    ivu_segmentado_categoria = cut(ivu_segmentado,
                                   breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1.0),
                                   labels = c("Muy bajo", "Bajo", "Medio", "Alto", "Muy alto"),
                                   include.lowest = TRUE)
  ) %>%
  ungroup()

# ---- 7. AN√ÅLISIS DE RESULTADOS SEGMENTADOS ----

# 7.1 Comparaci√≥n de rankings
comparacion_rankings <- datos_segmentados %>%
  filter(!is.na(ivu_segmentado) & !is.na(ivp_segmentado)) %>%
  select(Proyecto, Segmento, nse, segmento_nse, 
         ivu, ivu_segmentado, ivp_v2, ivp_segmentado) %>%
  group_by(segmento_nse) %>%
  mutate(
    rank_ivu_original = rank(-ivu, ties.method = "min"),
    rank_ivu_segmentado = rank(-ivu_segmentado, ties.method = "min"),
    rank_ivp_original = rank(-ivp_v2, ties.method = "min"),
    rank_ivp_segmentado = rank(-ivp_segmentado, ties.method = "min"),
    
    cambio_rank_ivu = rank_ivu_original - rank_ivu_segmentado,
    cambio_rank_ivp = rank_ivp_original - rank_ivp_segmentado
  ) %>%
  ungroup()

# 7.2 Identificar cambios significativos en rankings
cambios_significativos <- comparacion_rankings %>%
  filter(abs(cambio_rank_ivu) >= 2 | abs(cambio_rank_ivp) >= 2) %>%
  arrange(desc(abs(cambio_rank_ivu) + abs(cambio_rank_ivp)))

cat("\nProyectos con cambios significativos en ranking (‚â•2 posiciones):\n")
print(kable(head(cambios_significativos[c("Proyecto", "Segmento", "nse", 
                                          "cambio_rank_ivu", "cambio_rank_ivp")], 10)))

# 7.3 Estad√≠sticas por segmento
estadisticas_segmento <- datos_segmentados %>%
  filter(!is.na(ivu_segmentado) & !is.na(ivp_segmentado)) %>%
  group_by(Segmento) %>%
  summarise(
    Proyectos = n(),
    
    # IVU
    IVU_Original_Media = round(mean(ivu, na.rm = TRUE), 3),
    IVU_Segmentado_Media = round(mean(ivu_segmentado, na.rm = TRUE), 3),
    IVU_Correlacion = round(cor(ivu, ivu_segmentado, use = "complete.obs"), 3),
    
    # IVP  
    IVP_Original_Media = round(mean(ivp_v2, na.rm = TRUE), 3),
    IVP_Segmentado_Media = round(mean(ivp_segmentado, na.rm = TRUE), 3),
    IVP_Correlacion = round(cor(ivp_v2, ivp_segmentado, use = "complete.obs"), 3),
    
    .groups = 'drop'
  )

cat("\nEstad√≠sticas comparativas por segmento:\n")
print(kable(estadisticas_segmento))

# ---- 8. VISUALIZACIONES SEGMENTADAS ----

# 8.1 Scatter plot IVU original vs segmentado
grafico_ivu_comparacion <- ggplot(datos_segmentados, 
                                  aes(x = ivu, y = ivu_segmentado, color = Segmento)) +
  geom_point(alpha = 0.7, size = 3) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray") +
  facet_wrap(~Segmento, scales = "free") +
  labs(title = "Comparaci√≥n IVU Original vs Segmentado",
       subtitle = "L√≠nea diagonal = sin cambios",
       x = "IVU Original (comparaci√≥n global)",
       y = "IVU Segmentado (comparaci√≥n intra-segmento)") +
  theme_minimal()

print(grafico_ivu_comparacion)

# 8.2 Scatter plot IVP original vs segmentado  
grafico_ivp_comparacion <- ggplot(datos_segmentados, 
                                  aes(x = ivp_v2, y = ivp_segmentado, color = Segmento)) +
  geom_point(alpha = 0.7, size = 3) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray") +
  facet_wrap(~Segmento, scales = "free") +
  labs(title = "Comparaci√≥n IVP Original vs Segmentado",
       subtitle = "L√≠nea diagonal = sin cambios",
       x = "IVP Original (comparaci√≥n global)", 
       y = "IVP Segmentado (comparaci√≥n intra-segmento)") +
  theme_minimal()

print(grafico_ivp_comparacion)

# 8.3 Top proyectos por segmento (segmentado)
top_por_segmento <- datos_segmentados %>%
  filter(!is.na(ivu_segmentado) & !is.na(ivp_segmentado)) %>%
  group_by(Segmento) %>%
  mutate(
    score_combinado_seg = (ivu_segmentado * 0.6) + (ivp_segmentado * 0.4),
    rank_combinado = rank(-score_combinado_seg, ties.method = "min")
  ) %>%
  filter(rank_combinado <= 3) %>%
  select(Proyecto, Desarrollador, Segmento, nse, 
         ivu_segmentado, ivp_segmentado, score_combinado_seg, rank_combinado) %>%
  arrange(Segmento, rank_combinado) %>%
  ungroup()

cat("\nTop 3 proyectos por segmento (√≠ndices segmentados):\n")
print(kable(top_por_segmento, digits = 3))

# 8.4 Matriz de decisi√≥n segmentada INTERACTIVA - UNA SOLA VERSI√ìN
crear_matriz_segmentada_interactiva <- function(datos, segmento_filtro) {
  datos_filtrados <- datos %>% filter(Segmento == segmento_filtro)
  
  if(nrow(datos_filtrados) < 5) {
    return(NULL)
  }
  
  datos_filtrados <- datos_filtrados %>%
    mutate(
      categoria_seg = case_when(
        ivu_segmentado >= 0.5 & ivp_segmentado >= 0.5 ~ "SUPERIOR",
        ivu_segmentado < 0.5 & ivp_segmentado >= 0.5 ~ "S√ìLIDO",
        ivu_segmentado >= 0.5 & ivp_segmentado < 0.5 ~ "SUSTENTABLE",
        TRUE ~ "SINGULAR"
      )
    )
  
  colores_matriz_4s <- c(
    "SUPERIOR" = "#68D192", "S√ìLIDO" = "#9B87F4", 
    "SUSTENTABLE" = "#F4E785", "SINGULAR" = "#F8C579"
  )
  
  p <- ggplot(datos_filtrados, aes(x = ivu_segmentado, y = ivp_segmentado)) +
    # Cuadrantes de fondo
    annotate("rect", xmin = 0, xmax = 0.5, ymin = 0.5, ymax = 1, 
             fill = "#9B87F4", alpha = 0.1) +
    annotate("rect", xmin = 0.5, xmax = 1, ymin = 0.5, ymax = 1, 
             fill = "#68D192", alpha = 0.1) +
    annotate("rect", xmin = 0, xmax = 0.5, ymin = 0, ymax = 0.5, 
             fill = "#F8C579", alpha = 0.1) +
    annotate("rect", xmin = 0.5, xmax = 1, ymin = 0, ymax = 0.5, 
             fill = "#F4E785", alpha = 0.1) +
    
    geom_point(aes(color = categoria_seg, 
                   text = paste0("Proyecto: ", Proyecto, "\n",
                                 "Desarrollador: ", Desarrollador, "\n",
                                 "NSE: ", nse, "\n",
                                 "IVU Segmentado: ", round(ivu_segmentado, 3), "\n",
                                 "IVP Segmentado: ", round(ivp_segmentado, 3), "\n",
                                 "Precio/m¬≤: $", format(p_m2, big.mark = ","), "\n",
                                 "Categor√≠a 4S: ", categoria_seg)), 
               size = 4, alpha = 0.8) +
    
    geom_hline(yintercept = 0.5, linetype = "dashed", color = "gray40") +
    geom_vline(xintercept = 0.5, linetype = "dashed", color = "gray40") +
    
    scale_color_manual(values = colores_matriz_4s, name = "Categor√≠a 4S") +
    
    # Etiquetas de cuadrantes 4S
    annotate("text", x = 0.25, y = 0.75, 
             label = "‚≠ê S√ìLIDO\n(Propuesta s√≥lida\nalto potencial)", 
             fontface = "bold", hjust = 0.5, size = 3.5, color = "gray20") +
    annotate("text", x = 0.75, y = 0.75, 
             label = "üèÜ SUPERIOR\n(Excelente ubicaci√≥n\ny proyecto)", 
             fontface = "bold", hjust = 0.5, size = 3.5, color = "gray20") +
    annotate("text", x = 0.25, y = 0.25, 
             label = "üéØ SINGULAR\n(Caracter√≠sticas √∫nicas\nenfoque especializado)", 
             fontface = "bold", hjust = 0.5, size = 3.5, color = "gray20") +
    annotate("text", x = 0.75, y = 0.25, 
             label = "üîÑ SUSTENTABLE\n(Ubicaci√≥n excelente\nfundamentos consistentes)", 
             fontface = "bold", hjust = 0.5, size = 3.5, color = "gray20") +
    
    labs(title = paste("Matriz de Decisi√≥n 4S Segmentada:", segmento_filtro),
         subtitle = "Comparaci√≥n justa intra-segmento (INTERACTIVA)",
         x = "IVU Segmentado", y = "IVP Segmentado") +
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", size = 14),
      plot.subtitle = element_text(size = 12),
      legend.position = "right"
    )
  
  # Convertir a plotly para interactividad
  p_interactivo <- ggplotly(p, tooltip = "text") %>%
    layout(
      title = list(
        text = paste("Matriz de Decisi√≥n 4S Segmentada:", segmento_filtro, 
                     "<br><sub>Comparaci√≥n justa intra-segmento (INTERACTIVA)</sub>"),
        font = list(size = 16)
      ),
      hoverlabel = list(
        bgcolor = "white",
        font = list(size = 12, color = "black"),
        bordercolor = "gray"
      )
    )
  
  return(p_interactivo)
}

# Crear matrices interactivas SOLO UNA VEZ por segmento
segmentos_con_datos <- datos_segmentados %>%
  group_by(Segmento) %>%
  summarise(n = n()) %>%
  filter(n >= 5) %>%
  pull(Segmento)

cat("\n=== CREANDO MATRICES DE DECISI√ìN 4S INTERACTIVAS (√öNICAS) ===\n")
for(seg in segmentos_con_datos) {
  cat("Creando matriz interactiva 4S para segmento:", seg, "\n")
  matriz <- crear_matriz_segmentada_interactiva(datos_segmentados, seg)
  if(!is.null(matriz)) {
    print(matriz)
  }
}

# ---- 9. MAPAS INTERACTIVOS SEGMENTADOS ----

# 9.1 Funciones de mapas consolidadas (SOLO UNA VERSI√ìN)
crear_mapa_ivu_unico <- function(datos) {
  datos_validos <- datos %>% filter(!is.na(latitud) & !is.na(longitud) & !is.na(ivu_segmentado_categoria))
  
  colores_ivu <- c(
    "Muy bajo" = "#EF6558", "Bajo" = "#F8C579", "Medio" = "#F4E785", 
    "Alto" = "#68D192", "Muy alto" = "#2C6C66"
  )
  pal_ivu <- colorFactor(palette = colores_ivu, domain = datos_validos$ivu_segmentado_categoria, na.color = "#808080")
  
  popups <- paste0(
    "<div style='font-family: Arial, sans-serif; font-size: 14px; max-width: 300px;'>",
    "<h4 style='margin: 0 0 10px 0; color: #2C6C66;'><b>", datos_validos$Proyecto, "</b></h4>",
    "<hr style='margin: 5px 0;'>",
    "<b>üè¢ Desarrollador:</b> ", datos_validos$Desarrollador, "<br>",
    "<b>üìç Municipio:</b> ", datos_validos$Municipio, "<br>",
    "<b>üè† Segmento:</b> ", datos_validos$Segmento, " | NSE ", datos_validos$nse, "<br>",
    "<hr style='margin: 5px 0;'>",
    "<b>üìä IVU Segmentado:</b> ", round(datos_validos$ivu_segmentado, 3), " (", datos_validos$ivu_segmentado_categoria, ")<br>",
    "<b>üí∞ Precio/m¬≤:</b> $", format(datos_validos$p_m2, big.mark = ","), "<br>",
    "<b>üìà Absorci√≥n:</b> ", round(datos_validos$absorcion, 1), "<br>",
    "</div>"
  )
  
  leaflet(datos_validos) %>%
    addTiles() %>%
    addCircleMarkers(
      lng = ~longitud, lat = ~latitud,
      radius = 8, # TAMA√ëO UNIFORME
      fillColor = ~pal_ivu(ivu_segmentado_categoria),
      color = "white", weight = 2, opacity = 1, fillOpacity = 0.8,
      popup = popups
    ) %>%
    addLegend(
      position = "bottomright", pal = pal_ivu, values = ~ivu_segmentado_categoria,
      title = "IVU Segmentado<br>(Intra-segmento)", opacity = 0.8
    ) %>%
    setView(lng = mean(datos_validos$longitud, na.rm = TRUE), 
            lat = mean(datos_validos$latitud, na.rm = TRUE), zoom = 10)
}

crear_mapa_ivp_unico <- function(datos) {
  datos_validos <- datos %>% filter(!is.na(latitud) & !is.na(longitud) & !is.na(ivp_segmentado_categoria))
  
  colores_ivp <- c(
    "Muy Bajo" = "#EF6558", "Bajo" = "#F8C579", "Medio" = "#F4E785", 
    "Alto" = "#68D192", "Muy Alto" = "#2C6C66"
  )
  pal_ivp <- colorFactor(palette = colores_ivp, domain = datos_validos$ivp_segmentado_categoria, na.color = "#808080")
  
  popups <- paste0(
    "<div style='font-family: Arial, sans-serif; font-size: 14px; max-width: 300px;'>",
    "<h4 style='margin: 0 0 10px 0; color: #2C6C66;'><b>", datos_validos$Proyecto, "</b></h4>",
    "<hr style='margin: 5px 0;'>",
    "<b>üè¢ Desarrollador:</b> ", datos_validos$Desarrollador, "<br>",
    "<b>üìç Municipio:</b> ", datos_validos$Municipio, "<br>",
    "<b>üè† Segmento:</b> ", datos_validos$Segmento, " | NSE ", datos_validos$nse, "<br>",
    "<hr style='margin: 5px 0;'>",
    "<b>‚≠ê IVP Segmentado:</b> ", round(datos_validos$ivp_segmentado, 3), " (", datos_validos$ivp_segmentado_categoria, ")<br>",
    "<b>üéØ Amenidades:</b> ", datos_validos$num_amenidades, " (Score: ", round(datos_validos$score_amenidades_total, 1), ")<br>",
    "<b>üí∞ Precio/m¬≤:</b> $", format(datos_validos$p_m2, big.mark = ","), "<br>",
    "</div>"
  )
  
  leaflet(datos_validos) %>%
    addTiles() %>%
    addCircleMarkers(
      lng = ~longitud, lat = ~latitud,
      radius = 8, # TAMA√ëO UNIFORME
      fillColor = ~pal_ivp(ivp_segmentado_categoria),
      color = "white", weight = 2, opacity = 1, fillOpacity = 0.8,
      popup = popups
    ) %>%
    addLegend(
      position = "bottomright", pal = pal_ivp, values = ~ivp_segmentado_categoria,
      title = "IVP Segmentado<br>(Intra-segmento)", opacity = 0.8
    ) %>%
    setView(lng = mean(datos_validos$longitud, na.rm = TRUE), 
            lat = mean(datos_validos$latitud, na.rm = TRUE), zoom = 10)
}

crear_mapa_principal_unico <- function(datos) {
  datos_validos <- datos %>% 
    filter(!is.na(latitud) & !is.na(longitud) & 
             !is.na(ivu_segmentado) & !is.na(ivp_segmentado))
  
  datos_validos <- datos_validos %>%
    mutate(
      categoria_seg = case_when(
        ivu_segmentado >= 0.5 & ivp_segmentado >= 0.5 ~ "SUPERIOR_SEG",
        ivu_segmentado < 0.5 & ivp_segmentado >= 0.5 ~ "S√ìLIDO_SEG",
        ivu_segmentado >= 0.5 & ivp_segmentado < 0.5 ~ "SUSTENTABLE_SEG",
        TRUE ~ "SINGULAR_SEG"
      )
    )
  
  colores_seg_4s <- c(
    "SUPERIOR_SEG" = "#68D192", "S√ìLIDO_SEG" = "#9B87F4", 
    "SUSTENTABLE_SEG" = "#F4E785", "SINGULAR_SEG" = "#F8C579"
  )
  
  pal_seg <- colorFactor(palette = colores_seg_4s, domain = datos_validos$categoria_seg)
  
  popups <- paste0(
    "<div style='font-family: Arial, sans-serif; font-size: 14px; max-width: 320px;'>",
    "<h4 style='margin: 0 0 10px 0; color: #2C6C66;'><b>", datos_validos$Proyecto, "</b></h4>",
    "<div style='background-color: ", colores_seg_4s[datos_validos$categoria_seg], 
    "; color: white; padding: 5px 10px; border-radius: 5px; text-align: center; font-weight: bold; margin: 5px 0;'>",
    gsub("_SEG", " (Segmentado)", datos_validos$categoria_seg), "</div>",
    "<hr style='margin: 5px 0;'>",
    "<b>üè¢ Desarrollador:</b> ", datos_validos$Desarrollador, "<br>",
    "<b>üìç Municipio:</b> ", datos_validos$Municipio, "<br>",
    "<b>üè† Segmento:</b> ", datos_validos$Segmento, " | NSE ", datos_validos$nse, "<br>",
    "<hr style='margin: 5px 0;'>",
    "<b>Comparaci√≥n Global vs Segmentada:</b><br>",
    "üìä IVU: ", round(datos_validos$ivu, 3), " ‚Üí ", round(datos_validos$ivu_segmentado, 3), "<br>",
    "‚≠ê IVP: ", round(datos_validos$ivp_v2, 3), " ‚Üí ", round(datos_validos$ivp_segmentado, 3), "<br>",
    "<hr style='margin: 5px 0;'>",
    "<b>üí∞ Precio/m¬≤:</b> $", format(datos_validos$p_m2, big.mark = ","), "<br>",
    "<b>üìà Absorci√≥n:</b> ", round(datos_validos$absorcion, 1), "<br>",
    "</div>"
  )
  
  leaflet(datos_validos) %>%
    addTiles() %>%
    addCircleMarkers(
      lng = ~longitud, lat = ~latitud,
      radius = 8, # TAMA√ëO UNIFORME
      fillColor = ~pal_seg(categoria_seg),
      color = "white", weight = 2, opacity = 1, fillOpacity = 0.8,
      popup = popups
    ) %>%
    addLegend(
      position = "bottomright", pal = pal_seg, values = ~categoria_seg,
      title = "Categorizaci√≥n 4S<br>Segmentada", opacity = 0.8,
      labFormat = labelFormat(transform = function(x) gsub("_SEG", "", x))
    ) %>%
    addControl(
      html = paste0(
        "<div style='background: white; padding: 10px; border-radius: 5px; border: 2px solid #2C6C66;'>",
        "<h5 style='margin: 0 0 5px 0; color: #2C6C66;'>üéØ Categor√≠as 4S Segmentadas</h5>",
        "<div style='font-size: 12px;'>",
        "Comparaci√≥n justa intra-segmento<br>",
        "üèÜ <b>SUPERIOR:</b> L√≠deres en su segmento<br>",
        "‚≠ê <b>S√ìLIDO:</b> Alto potencial<br>",
        "üîÑ <b>SUSTENTABLE:</b> Ubicaci√≥n excelente<br>",
        "üéØ <b>SINGULAR:</b> Caracter√≠sticas √∫nicas",
        "</div></div>"
      ),
      position = "topleft"
    ) %>%
    setView(lng = mean(datos_validos$longitud, na.rm = TRUE), 
            lat = mean(datos_validos$latitud, na.rm = TRUE), zoom = 10)
}

# 9.2 CREAR MAPAS √öNICOS (NO DUPLICADOS)
cat("\n=== CREANDO MAPAS INTERACTIVOS 4S (VERSI√ìN √öNICA) ===\n")

cat("1. Creando mapa de IVU Segmentado...\n")
mapa_ivu_final <- crear_mapa_ivu_unico(datos_segmentados)
print(mapa_ivu_final)

cat("\n2. Creando mapa de IVP Segmentado...\n")
mapa_ivp_final <- crear_mapa_ivp_unico(datos_segmentados)
print(mapa_ivp_final)

cat("\n3. Creando mapa principal con categorizaci√≥n 4S segmentada...\n")
mapa_principal_final <- crear_mapa_principal_unico(datos_segmentados)
print(mapa_principal_final)

# ---- 10. AN√ÅLISIS DE INSIGHTS ----

# 10.1 Proyectos que mejoraron significativamente
mejores_cambios <- comparacion_rankings %>%
  mutate(mejora_total = pmax(0, -cambio_rank_ivu) + pmax(0, -cambio_rank_ivp)) %>%
  filter(mejora_total >= 3) %>%
  arrange(desc(mejora_total)) %>%
  head(10)

cat("\nProyectos que m√°s mejoraron con segmentaci√≥n:\n")
print(kable(mejores_cambios[c("Proyecto", "Segmento", "nse", "mejora_total", 
                              "cambio_rank_ivu", "cambio_rank_ivp")]))

# 10.2 Distribuci√≥n de categor√≠as por segmento
distribucion_categorias <- datos_segmentados %>%
  filter(!is.na(ivu_segmentado_categoria) & !is.na(ivp_segmentado_categoria)) %>%
  group_by(Segmento, ivu_segmentado_categoria) %>%
  summarise(proyectos = n(), .groups = 'drop') %>%
  pivot_wider(names_from = ivu_segmentado_categoria, values_from = proyectos, values_fill = 0)

cat("\nDistribuci√≥n de categor√≠as IVU segmentado por segmento:\n")
print(kable(distribucion_categorias))

# ---- 11. GUARDAR RESULTADOS ----

# 11.1 Guardar dataset completo
write.csv(datos_segmentados, "proyectos_indices_segmentados_4s.csv", row.names = FALSE)

# 11.2 Guardar rankings por segmento
rankings_finales <- datos_segmentados %>%
  filter(!is.na(ivu_segmentado) & !is.na(ivp_segmentado)) %>%
  group_by(Segmento) %>%
  mutate(
    score_combinado_seg = (ivu_segmentado * 0.6) + (ivp_segmentado * 0.4),
    rank_final = rank(-score_combinado_seg, ties.method = "min")
  ) %>%
  select(Proyecto, Desarrollador, Municipio, Segmento, nse, segmento_nse,
         ivu_segmentado, ivu_segmentado_categoria,
         ivp_segmentado, ivp_segmentado_categoria,
         score_combinado_seg, rank_final) %>%
  arrange(Segmento, rank_final) %>%
  ungroup()

write.csv(rankings_finales, "rankings_por_segmento_4s.csv", row.names = FALSE)

# 11.3 Guardar matriz de relevancia aplicada
write.csv(factores_relevancia, "matriz_relevancia_factores_4s.csv", row.names = FALSE)

# ---- 12. RESUMEN EJECUTIVO 4S ----

cat("\n" , rep("=", 60), "\n")
cat("RESUMEN EJECUTIVO 4S - SEGMENTACI√ìN DE √çNDICES\n")
cat(rep("=", 60), "\n")

cat("\nüìä ESTAD√çSTICAS GENERALES:\n")
cat("- Proyectos analizados:", nrow(datos_segmentados), "\n")
cat("- Combinaciones Segmento-NSE:", n_distinct(datos_segmentados$segmento_nse), "\n")
cat("- Segmentos con datos suficientes:", length(segmentos_con_datos), "\n")

cat("\nüéØ PRINCIPALES HALLAZGOS:\n")
cat("- Correlaci√≥n promedio IVU original vs segmentado:", 
    round(mean(estadisticas_segmento$IVU_Correlacion, na.rm = TRUE), 3), "\n")
cat("- Correlaci√≥n promedio IVP original vs segmentado:", 
    round(mean(estadisticas_segmento$IVP_Correlacion, na.rm = TRUE), 3), "\n")
cat("- Proyectos con cambios significativos en ranking:", nrow(cambios_significativos), "\n")
cat("- Proyectos que mejoraron ‚â•3 posiciones:", nrow(mejores_cambios), "\n")

cat("\nüìà BENEFICIOS DE LA SEGMENTACI√ìN 4S:\n")
cat("‚úÖ Eliminaci√≥n de sesgos por comparaci√≥n entre segmentos diferentes\n")
cat("‚úÖ Rankings justos intra-segmento con categor√≠as diplom√°ticas\n") 
cat("‚úÖ Identificaci√≥n de l√≠deres reales por mercado objetivo\n")
cat("‚úÖ Pesos espec√≠ficos por valoraci√≥n del segmento\n")
cat("‚úÖ Mejor identificaci√≥n de oportunidades de inversi√≥n\n")
cat("‚úÖ Lenguaje profesional y constructivo para desarrolladores\n")

cat("\nüèÜ CATEGOR√çAS 4S REAL ESTATE:\n")
cat("- SUPERIOR: L√≠deres del mercado en su segmento\n")
cat("- S√ìLIDO: Proyectos con alto potencial\n") 
cat("- SUSTENTABLE: Base s√≥lida para crecimiento\n")
cat("- SINGULAR: Caracter√≠sticas √∫nicas especializadas\n")

cat("\nüìÅ ARCHIVOS GENERADOS:\n")
cat("- proyectos_indices_segmentados_4s.csv (dataset completo)\n")
cat("- rankings_por_segmento_4s.csv (rankings finales)\n") 
cat("- matriz_relevancia_factores_4s.csv (pesos por segmento)\n")

cat("\nüó∫Ô∏è VISUALIZACIONES 4S MEJORADAS:\n")
cat("- Matriz de relevancia de factores por segmento\n")
cat("- Comparaciones IVU/IVP original vs segmentado\n")
cat("- Matrices de decisi√≥n 4S INTERACTIVAS por segmento (plotly)\n")
cat("- Mapas interactivos con TAMA√ëOS UNIFORMES y categorizaci√≥n 4S\n")
cat("- Popups informativos detallados con identidad 4S\n")

cat("\n", rep("=", 60), "\n")
cat("PROCESO DE SEGMENTACI√ìN 4S COMPLETADO CON √âXITO\n")
cat(rep("=", 60), "\n\n")

cat("‚úÖ CAMBIOS 4S IMPLEMENTADOS:\n")
cat("üî∏ Categor√≠as diplom√°ticas SUPERIOR, S√ìLIDO, SUSTENTABLE, SINGULAR\n")
cat("üî∏ Tama√±os uniformes en todos los mapas (eliminaci√≥n de sobresaturaci√≥n)\n")
cat("üî∏ Matrices de decisi√≥n 4S interactivas con tooltips informativos\n") 
cat("üî∏ Mejor identificaci√≥n de proyectos en cada cuadrante 4S\n")
cat("üî∏ Mapas segmentados con categorizaci√≥n justa intra-segmento\n")
cat("üî∏ Popups detallados con comparaciones antes/despu√©s\n")
cat("üî∏ Identidad visual y terminolog√≠a 4S Real Estate consistente\n")


# ---- 13. VISUALIZACIONES PARA PROYECTO INDIVIDUAL ----

# 13.1 Funciones para proyecto individual (SIN DUPLICAR)
seleccionar_proyecto_segmentado <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  if (!is.null(indice_proyecto)) {
    if(indice_proyecto > nrow(datos) || indice_proyecto < 1) {
      stop("√çndice de proyecto fuera de rango. Debe estar entre 1 y ", nrow(datos))
    }
    proyecto <- datos[indice_proyecto, ]
  } else if (!is.null(nombre_proyecto)) {
    proyecto <- datos[datos$Proyecto == nombre_proyecto, ]
    if (nrow(proyecto) == 0) {
      stop("Proyecto no encontrado: ", nombre_proyecto)
    }
  } else {
    stop("Debe proporcionar un indice_proyecto o un nombre_proyecto")
  }
  return(proyecto)
}

# 13.2 Funci√≥n para crear term√≥metro IVU segmentado
crear_termometro_ivu_segmentado <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  proyecto <- seleccionar_proyecto_segmentado(datos, indice_proyecto, nombre_proyecto)
  
  valor <- proyecto$ivu_segmentado
  categoria <- proyecto$ivu_segmentado_categoria
  nombre <- proyecto$Proyecto
  segmento <- proyecto$Segmento
  nse <- proyecto$nse
  
  colores <- c(
    "Muy bajo" = "#EF6558", "Bajo" = "#F8C579", "Medio" = "#F4E785",
    "Alto" = "#68D192", "Muy alto" = "#2C6C66"
  )
  
  color <- colores[as.character(categoria)]
  
  escala <- data.frame(
    y = seq(0, 1, 0.2),
    labels = c("0.0", "0.2", "0.4", "0.6", "0.8", "1.0"),
    categorias = c("", "Muy bajo", "Bajo", "Medio", "Alto", "Muy alto")
  )
  
  p <- ggplot() +
    geom_rect(aes(xmin = 0.4, xmax = 0.6, ymin = 0, ymax = 1), 
              fill = "lightgrey", color = "black", linewidth = 1) +
    geom_rect(aes(xmin = 0.4, xmax = 0.6, ymin = 0, ymax = valor), 
              fill = color, alpha = 0.8) +
    geom_segment(data = escala, 
                 aes(x = 0.38, y = y, xend = 0.62, yend = y), 
                 color = "black", linewidth = 0.5) +
    geom_text(data = escala, 
              aes(x = 0.35, y = y, label = labels), 
              hjust = 1, size = 4) +
    geom_text(data = escala[-1,], 
              aes(x = 0.7, y = y - 0.1, label = categorias), 
              hjust = 0, size = 3) +
    geom_text(aes(x = 0.5, y = 1.15, 
                  label = paste0(nombre, "\n", 
                                 "Segmento: ", segmento, " | NSE: ", nse, "\n",
                                 "IVU Segmentado: ", round(valor, 3), "\n",
                                 "Categor√≠a: ", categoria)),
              fontface = "bold", hjust = 0.5, size = 4) +
    labs(title = "üéØ Term√≥metro IVU Segmentado 4S",
         subtitle = "Comparaci√≥n justa intra-segmento",
         x = NULL, y = NULL) +
    theme_minimal() +
    theme(
      axis.text = element_blank(), axis.ticks = element_blank(), panel.grid = element_blank(),
      plot.title = element_text(hjust = 0.5, face = "bold", size = 16, color = "#2C6C66"),
      plot.subtitle = element_text(hjust = 0.5, size = 12, color = "#2C6C66")
    ) +
    coord_cartesian(xlim = c(0, 1), ylim = c(-0.05, 1.3), expand = FALSE)
  
  return(p)
}

# 13.3 Funci√≥n para crear term√≥metro IVP segmentado
crear_termometro_ivp_segmentado <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  proyecto <- seleccionar_proyecto_segmentado(datos, indice_proyecto, nombre_proyecto)
  
  valor <- proyecto$ivp_segmentado
  categoria <- proyecto$ivp_segmentado_categoria
  nombre <- proyecto$Proyecto
  segmento <- proyecto$Segmento
  amenidades <- proyecto$num_amenidades
  
  colores <- c(
    "Muy Bajo" = "#EF6558", "Bajo" = "#F8C579", "Medio" = "#F4E785",
    "Alto" = "#68D192", "Muy Alto" = "#2C6C66"
  )
  
  color <- colores[as.character(categoria)]
  
  escala <- data.frame(
    y = seq(0, 1, 0.2),
    labels = c("0.0", "0.2", "0.4", "0.6", "0.8", "1.0"),
    categorias = c("", "Muy Bajo", "Bajo", "Medio", "Alto", "Muy Alto")
  )
  
  p <- ggplot() +
    geom_rect(aes(xmin = 0.4, xmax = 0.6, ymin = 0, ymax = 1), 
              fill = "lightgrey", color = "black", linewidth = 1) +
    geom_rect(aes(xmin = 0.4, xmax = 0.6, ymin = 0, ymax = valor), 
              fill = color, alpha = 0.8) +
    geom_segment(data = escala, 
                 aes(x = 0.38, y = y, xend = 0.62, yend = y), 
                 color = "black", linewidth = 0.5) +
    geom_text(data = escala, 
              aes(x = 0.35, y = y, label = labels), 
              hjust = 1, size = 4) +
    geom_text(data = escala[-1,], 
              aes(x = 0.7, y = y - 0.1, label = categorias), 
              hjust = 0, size = 3) +
    geom_text(aes(x = 0.5, y = 1.15, 
                  label = paste0(nombre, "\n", 
                                 "Segmento: ", segmento, "\n",
                                 "IVP Segmentado: ", round(valor, 3), "\n",
                                 "Categor√≠a: ", categoria, "\n",
                                 "Amenidades: ", amenidades)),
              fontface = "bold", hjust = 0.5, size = 4) +
    labs(title = "‚≠ê Term√≥metro IVP Segmentado 4S",
         subtitle = "Valor del proyecto intra-segmento",
         x = NULL, y = NULL) +
    theme_minimal() +
    theme(
      axis.text = element_blank(), axis.ticks = element_blank(), panel.grid = element_blank(),
      plot.title = element_text(hjust = 0.5, face = "bold", size = 16, color = "#2C6C66"),
      plot.subtitle = element_text(hjust = 0.5, size = 12, color = "#2C6C66")
    ) +
    coord_cartesian(xlim = c(0, 1), ylim = c(-0.05, 1.3), expand = FALSE)
  
  return(p)
}

# 13.4 Funci√≥n para crear panel de categorizaci√≥n 4S
crear_panel_categorizacion_4s <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  proyecto <- seleccionar_proyecto_segmentado(datos, indice_proyecto, nombre_proyecto)
  
  ivu_seg <- proyecto$ivu_segmentado
  ivp_seg <- proyecto$ivp_segmentado
  
  categoria_4s <- case_when(
    ivu_seg >= 0.5 & ivp_seg >= 0.5 ~ "SUPERIOR",
    ivu_seg < 0.5 & ivp_seg >= 0.5 ~ "S√ìLIDO",
    ivu_seg >= 0.5 & ivp_seg < 0.5 ~ "SUSTENTABLE",
    TRUE ~ "SINGULAR"
  )
  
  info_categorias <- data.frame(
    categoria = c("SUPERIOR", "S√ìLIDO", "SUSTENTABLE", "SINGULAR"),
    color = c("#68D192", "#9B87F4", "#F4E785", "#F8C579"),
    descripcion = c(
      "Excelente ubicaci√≥n\ny proyecto",
      "Propuesta s√≥lida\nalto potencial", 
      "Ubicaci√≥n excelente\nfundamentos consistentes",
      "Caracter√≠sticas √∫nicas\nenfoque especializado"
    ),
    icono = c("üèÜ", "‚≠ê", "üîÑ", "üéØ")
  )
  
  categoria_info <- info_categorias[info_categorias$categoria == categoria_4s, ]
  
  p <- ggplot() +
    geom_rect(aes(xmin = 0.1, xmax = 0.9, ymin = 0.4, ymax = 0.8), 
              fill = categoria_info$color, alpha = 0.8, color = "white", linewidth = 2) +
    geom_text(aes(x = 0.5, y = 0.6, 
                  label = paste0(categoria_info$icono, " ", categoria_4s)), 
              size = 8, fontface = "bold", color = "white") +
    geom_text(aes(x = 0.5, y = 0.3, 
                  label = categoria_info$descripcion), 
              size = 5, fontface = "bold", color = categoria_info$color) +
    geom_text(aes(x = 0.5, y = 0.9, 
                  label = paste0(proyecto$Proyecto, "\n",
                                 proyecto$Segmento, " | NSE ", proyecto$nse)), 
              size = 5, fontface = "bold", color = "#2C6C66") +
    geom_text(aes(x = 0.5, y = 0.1, 
                  label = paste0("IVU: ", round(ivu_seg, 3), 
                                 " | IVP: ", round(ivp_seg, 3))), 
              size = 4, color = "#2C6C66") +
    labs(title = "üéØ Categorizaci√≥n 4S Segmentada",
         subtitle = "Posici√≥n en la matriz de decisi√≥n intra-segmento") +
    theme_void() +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold", size = 16, color = "#2C6C66"),
      plot.subtitle = element_text(hjust = 0.5, size = 12, color = "#2C6C66")
    ) +
    coord_cartesian(xlim = c(0, 1), ylim = c(0, 1))
  
  return(p)
}

# 13.5 Funci√≥n para crear dashboard b√°sico del proyecto
crear_dashboard_proyecto_4s <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  
  if (!is.null(indice_proyecto)) {
    if(indice_proyecto > nrow(datos) || indice_proyecto < 1) {
      stop("√çndice de proyecto fuera de rango. Debe estar entre 1 y ", nrow(datos))
    }
  }
  
  termometro_ivu <- crear_termometro_ivu_segmentado(datos, indice_proyecto, nombre_proyecto)
  termometro_ivp <- crear_termometro_ivp_segmentado(datos, indice_proyecto, nombre_proyecto)
  panel_categoria <- crear_panel_categorizacion_4s(datos, indice_proyecto, nombre_proyecto)
  
  proyecto <- seleccionar_proyecto_segmentado(datos, indice_proyecto, nombre_proyecto)
  
  datos_segmento <- datos %>% filter(Segmento == proyecto$Segmento)
  
  matriz_posicion <- ggplot(datos_segmento, aes(x = ivu_segmentado, y = ivp_segmentado)) +
    annotate("rect", xmin = 0, xmax = 0.5, ymin = 0.5, ymax = 1, 
             fill = "#9B87F4", alpha = 0.1) +
    annotate("rect", xmin = 0.5, xmax = 1, ymin = 0.5, ymax = 1, 
             fill = "#68D192", alpha = 0.1) +
    annotate("rect", xmin = 0, xmax = 0.5, ymin = 0, ymax = 0.5, 
             fill = "#F8C579", alpha = 0.1) +
    annotate("rect", xmin = 0.5, xmax = 1, ymin = 0, ymax = 0.5, 
             fill = "#F4E785", alpha = 0.1) +
    geom_point(data = datos_segmento[datos_segmento$Proyecto != proyecto$Proyecto, ],
               alpha = 0.3, size = 2, color = "gray60") +
    geom_point(data = proyecto, aes(x = ivu_segmentado, y = ivp_segmentado),
               size = 6, color = "#2C6C66", shape = 17) +
    geom_hline(yintercept = 0.5, linetype = "dashed", color = "gray40") +
    geom_vline(xintercept = 0.5, linetype = "dashed", color = "gray40") +
    labs(title = paste("Posici√≥n en Matriz 4S -", proyecto$Segmento),
         subtitle = paste("‚ñ≤ =", proyecto$Proyecto),
         x = "IVU Segmentado", y = "IVP Segmentado") +
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", size = 12, color = "#2C6C66"),
      plot.subtitle = element_text(size = 10, color = "#2C6C66")
    )
  
  dashboard <- grid.arrange(
    termometro_ivu, termometro_ivp, 
    panel_categoria, matriz_posicion,
    ncol = 2, nrow = 2,
    top = textGrob(paste("Dashboard 4S -", proyecto$Proyecto), 
                   gp = gpar(fontsize = 18, fontface = "bold", col = "#2C6C66"))
  )
  
  return(dashboard)
}

# 13.6 Funci√≥n b√°sica de an√°lisis del proyecto
analizar_proyecto_4s <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  proyecto <- seleccionar_proyecto_segmentado(datos, indice_proyecto, nombre_proyecto)
  
  datos_segmento <- datos %>% filter(Segmento == proyecto$Segmento)
  
  percentil_ivu <- round(mean(datos_segmento$ivu_segmentado <= proyecto$ivu_segmentado, na.rm = TRUE) * 100, 1)
  percentil_ivp <- round(mean(datos_segmento$ivp_segmentado <= proyecto$ivp_segmentado, na.rm = TRUE) * 100, 1)
  
  categoria_4s <- case_when(
    proyecto$ivu_segmentado >= 0.5 & proyecto$ivp_segmentado >= 0.5 ~ "SUPERIOR",
    proyecto$ivu_segmentado < 0.5 & proyecto$ivp_segmentado >= 0.5 ~ "S√ìLIDO",
    proyecto$ivu_segmentado >= 0.5 & proyecto$ivp_segmentado < 0.5 ~ "SUSTENTABLE",
    TRUE ~ "SINGULAR"
  )
  
  score_combinado <- (proyecto$ivu_segmentado * 0.6) + (proyecto$ivp_segmentado * 0.4)
  datos_segmento$score_temp <- (datos_segmento$ivu_segmentado * 0.6) + (datos_segmento$ivp_segmentado * 0.4)
  ranking <- sum(datos_segmento$score_temp >= score_combinado, na.rm = TRUE)
  total_segmento <- nrow(datos_segmento)
  
  cat("\n", rep("=", 60), "\n")
  cat("AN√ÅLISIS 4S INDIVIDUAL DEL PROYECTO\n")
  cat(rep("=", 60), "\n")
  
  cat("\nüìä INFORMACI√ìN B√ÅSICA:\n")
  cat("Proyecto:", proyecto$Proyecto, "\n")
  cat("Desarrollador:", proyecto$Desarrollador, "\n")
  cat("Municipio:", proyecto$Municipio, "\n")
  cat("Segmento:", proyecto$Segmento, "| NSE:", proyecto$nse, "\n")
  cat("Precio/m¬≤: $", format(proyecto$p_m2, big.mark = ","), "\n")
  
  cat("\nüéØ CATEGORIZACI√ìN 4S:", categoria_4s, "\n")
  
  cat("\nüìà M√âTRICAS SEGMENTADAS:\n")
  cat("IVU Segmentado:", round(proyecto$ivu_segmentado, 3), 
      "(", proyecto$ivu_segmentado_categoria, ")\n")
  cat("IVP Segmentado:", round(proyecto$ivp_segmentado, 3), 
      "(", proyecto$ivp_segmentado_categoria, ")\n")
  cat("Score Combinado:", round(score_combinado, 3), "\n")
  
  cat("\nüèÜ POSICI√ìN EN SEGMENTO:\n")
  cat("Ranking:", ranking, "de", total_segmento, "proyectos\n")
  cat("Percentil IVU:", percentil_ivu, "% (mejor que", percentil_ivu, "% del segmento)\n")
  cat("Percentil IVP:", percentil_ivp, "% (mejor que", percentil_ivp, "% del segmento)\n")
  
  cat("\nüí° COMPARACI√ìN GLOBAL vs SEGMENTADA:\n")
  cat("IVU: Global", round(proyecto$ivu, 3), "‚Üí Segmentado", round(proyecto$ivu_segmentado, 3), "\n")
  cat("IVP: Global", round(proyecto$ivp_v2, 3), "‚Üí Segmentado", round(proyecto$ivp_segmentado, 3), "\n")
  
  interpretaciones <- list(
    "SUPERIOR" = "L√≠der del segmento con excelente ubicaci√≥n y proyecto. Inversi√≥n premium recomendada.",
    "S√ìLIDO" = "Alto potencial con propuesta s√≥lida. Oportunidad de crecimiento en el segmento.",
    "SUSTENTABLE" = "Base s√≥lida con ubicaci√≥n excelente. Fundamentos consistentes para crecimiento.",
    "SINGULAR" = "Caracter√≠sticas √∫nicas especializadas. Enfoque diferenciado en el mercado."
  )
  
  cat("\nüéØ INTERPRETACI√ìN CATEGOR√çA", categoria_4s, ":\n")
  cat(interpretaciones[[categoria_4s]], "\n")
  cat("\n", rep("=", 60), "\n")
  
  return(list(
    proyecto = proyecto$Proyecto,
    categoria_4s = categoria_4s,
    ivu_segmentado = proyecto$ivu_segmentado,
    ivp_segmentado = proyecto$ivp_segmentado,
    ranking = ranking,
    total_segmento = total_segmento,
    percentil_ivu = percentil_ivu,
    percentil_ivp = percentil_ivp,
    score_combinado = score_combinado
  ))
}

# 13.7 Funci√≥n COMPLETA para an√°lisis con fortalezas
crear_dashboard_proyecto_4s_completo <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  
  # Dashboard original (4 paneles)
  dashboard_original <- crear_dashboard_proyecto_4s(datos, indice_proyecto, nombre_proyecto)
  
  cat("\n=== DASHBOARD PRINCIPAL 4S ===\n")
  print(dashboard_original)
  
  return(dashboard_original)
}

# 13.8 Funci√≥n COMPLETA para an√°lisis detallado
analizar_proyecto_4s_completo <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  # Ejecutar an√°lisis 4S original
  analisis_base <- analizar_proyecto_4s(datos, indice_proyecto, nombre_proyecto)
  
  cat("\nüèÜ AN√ÅLISIS COMPLETADO\n")
  
  return(analisis_base)
}

# ---- 14. EJEMPLOS DE USO DE LAS VISUALIZACIONES ----

# Definir proyecto a analizar
PROYECTO_SELECCIONADO <- 7 

cat("\n=== AN√ÅLISIS INDIVIDUAL 4S (VERSI√ìN √öNICA) ===\n")

if(PROYECTO_SELECCIONADO <= nrow(datos_segmentados)) {
  proyecto_info <- datos_segmentados[PROYECTO_SELECCIONADO, ]
  
  if(!is.na(proyecto_info$ivu_segmentado) && !is.na(proyecto_info$ivp_segmentado)) {
    
    cat("Analizando proyecto:", proyecto_info$Proyecto, "\n")
    cat("Segmento:", proyecto_info$Segmento, "| NSE:", proyecto_info$nse, "\n")
    
    # SOLO UNA VERSI√ìN de cada visualizaci√≥n
    cat("\n1. Dashboard 4S completo...\n")
    dashboard_unico <- crear_dashboard_proyecto_4s_completo(datos_segmentados, PROYECTO_SELECCIONADO)
    
    cat("\n2. An√°lisis detallado...\n")
    analisis_unico <- analizar_proyecto_4s_completo(datos_segmentados, PROYECTO_SELECCIONADO)
    
  } else {
    cat("ERROR: El proyecto seleccionado no tiene datos segmentados v√°lidos.\n")
  }
} else {
  cat("ERROR: √çndice de proyecto fuera de rango. M√°ximo:", nrow(datos_segmentados), "\n")
}


# ---- 15 Crear archivo espec√≠fico para Keynote ----
datos_keynote <- datos_segmentados %>%
  filter(!is.na(ivu_segmentado) & !is.na(ivp_segmentado)) %>%
  mutate(
    # Calcular categor√≠a 4S
    categoria_4s = case_when(
      ivu_segmentado >= 0.5 & ivp_segmentado >= 0.5 ~ "SUPERIOR",
      ivu_segmentado < 0.5 & ivp_segmentado >= 0.5 ~ "S√ìLIDO",
      ivu_segmentado >= 0.5 & ivp_segmentado < 0.5 ~ "SUSTENTABLE",
      TRUE ~ "SINGULAR"
    ),
    
    # Redondear valores para mejor visualizaci√≥n
    IVU_X = round(ivu_segmentado, 3),
    IVP_Y = round(ivp_segmentado, 3),
    
    # Crear etiqueta combinada
    Etiqueta = paste0(Proyecto, "\n(", Segmento, ")")
  ) %>%
  select(
    Proyecto, Desarrollador, Municipio, Segmento, nse,
    IVU_X, IVP_Y, categoria_4s, Etiqueta, p_m2
  ) %>%
  arrange(Segmento, desc(IVU_X + IVP_Y))

# Guardar archivo optimizado para Keynote
write.csv(datos_keynote, "matriz_4s_para_keynote.csv", row.names = FALSE)

cat("Archivo creado: matriz_4s_para_keynote.csv\n")
cat("Proyectos incluidos:", nrow(datos_keynote), "\n")

# ---- 16. AN√ÅLISIS DE FORTALEZAS DEL PROYECTO ----

# 16.1 Funci√≥n para identificar fortalezas del proyecto
identificar_fortalezas_proyecto <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  # Seleccionar proyecto
  proyecto <- seleccionar_proyecto_segmentado(datos, indice_proyecto, nombre_proyecto)
  
  # Obtener datos del mismo segmento para comparaci√≥n
  datos_segmento <- datos %>% 
    filter(Segmento == proyecto$Segmento) %>%
    filter(!is.na(ivu_segmentado) & !is.na(ivp_segmentado))
  
  # Definir variables clave para an√°lisis
  variables_analisis <- c(
    # Performance Comercial
    "absorcion", "ratio_ventas", "eficiencia_comercial", "velocidad_ventas",
    
    # Amenidades y Proyecto
    "score_amenidades_total", "num_amenidades", "m2_inv",
    
    # Ubicaci√≥n y Accesibilidad
    "indice_accesibilidad", "accesibilidad_vial", "indice_conveniencia",
    "cerca_parque_relevante", "dist_to_park", "dist_to_relevant_park",
    
    # Cercan√≠as clave
    "cercania_hospital", "cercania_esc_priv", "cercania_universidad", 
    "cercania_super", "cercania_tienda_dept", "cerca_avenida_principal",
    
    # Cantidades en 1km
    "cantidad_hospital_1km", "cantidad_esc_priv_1km", "cantidad_super_1km", 
    "cantidad_restau_1km", "cantidad_oficina_1km",
    
    # Desarrollador
    "proyectos_total", "absorcion_promedio_dev", "consistencia_absorcion",
    
    # Entorno demogr√°fico
    "pob2020_1km", "hogares2020_1km", "alta_densidad_comercial", "alto_entorno_laboral",
    
    # Competitividad
    "competitividad_precio", "propuesta_valor_v2"
  )
  
  # Filtrar solo variables que existen en los datos
  variables_existentes <- intersect(variables_analisis, names(datos_segmento))
  
  # Calcular percentiles para cada variable
  percentiles_proyecto <- data.frame(
    Variable = character(0),
    Valor_Proyecto = numeric(0),
    Percentil = numeric(0),
    Promedio_Segmento = numeric(0),
    Categoria_Fortaleza = character(0),
    stringsAsFactors = FALSE
  )
  
  for(var in variables_existentes) {
    valor_proyecto <- proyecto[[var]]
    
    if(!is.na(valor_proyecto)) {
      valores_segmento <- datos_segmento[[var]]
      valores_validos <- valores_segmento[!is.na(valores_segmento)]
      
      if(length(valores_validos) > 2) {
        # Calcular percentil
        percentil <- round(mean(valores_validos <= valor_proyecto, na.rm = TRUE) * 100, 1)
        promedio <- mean(valores_validos, na.rm = TRUE)
        
        # Categorizar fortaleza
        categoria <- case_when(
          percentil >= 90 ~ "Excepcional",
          percentil >= 75 ~ "Muy Fuerte", 
          percentil >= 60 ~ "Fuerte",
          percentil >= 40 ~ "Promedio",
          TRUE ~ "√Årea de Mejora"
        )
        
        # Para variables donde menor es mejor (distancias), invertir percentil
        if(grepl("^dist_", var)) {
          percentil <- 100 - percentil
          categoria <- case_when(
            percentil >= 90 ~ "Excepcional",
            percentil >= 75 ~ "Muy Fuerte", 
            percentil >= 60 ~ "Fuerte",
            percentil >= 40 ~ "Promedio",
            TRUE ~ "√Årea de Mejora"
          )
        }
        
        percentiles_proyecto <- rbind(percentiles_proyecto, data.frame(
          Variable = var,
          Valor_Proyecto = valor_proyecto,
          Percentil = percentil,
          Promedio_Segmento = promedio,
          Categoria_Fortaleza = categoria,
          stringsAsFactors = FALSE
        ))
      }
    }
  }
  
  # Ordenar por percentil descendente
  percentiles_proyecto <- percentiles_proyecto %>%
    arrange(desc(Percentil))
  
  return(percentiles_proyecto)
}

# 16.2 Funci√≥n para crear visualizaci√≥n de fortalezas
crear_visualizacion_fortalezas <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  # Obtener an√°lisis de fortalezas
  fortalezas <- identificar_fortalezas_proyecto(datos, indice_proyecto, nombre_proyecto)
  proyecto <- seleccionar_proyecto_segmentado(datos, indice_proyecto, nombre_proyecto)
  
  # Tomar top 12 fortalezas para visualizaci√≥n
  top_fortalezas <- head(fortalezas, 12)
  
  # Crear etiquetas m√°s amigables
  etiquetas_variables <- c(
    "absorcion" = "Absorci√≥n",
    "ratio_ventas" = "Ratio de Ventas", 
    "eficiencia_comercial" = "Eficiencia Comercial",
    "velocidad_ventas" = "Velocidad Ventas",
    "score_amenidades_total" = "Score Amenidades",
    "num_amenidades" = "N√∫mero Amenidades",
    "m2_inv" = "Superficie Inventario",
    "indice_accesibilidad" = "Accesibilidad",
    "accesibilidad_vial" = "Accesibilidad Vial",
    "indice_conveniencia" = "Conveniencia",
    "cerca_parque_relevante" = "Cercan√≠a Parque",
    "dist_to_park" = "Distancia Parque",
    "dist_to_relevant_park" = "Dist. Parque Relevante",
    "cercania_hospital" = "Cercan√≠a Hospital",
    "cercania_esc_priv" = "Cercan√≠a Esc. Privada",
    "cercania_universidad" = "Cercan√≠a Universidad",
    "cercania_super" = "Cercan√≠a Supermercado",
    "cercania_tienda_dept" = "Cercan√≠a Tienda Depto",
    "cerca_avenida_principal" = "Cercan√≠a Av. Principal",
    "cantidad_hospital_1km" = "Hospitales 1km",
    "cantidad_esc_priv_1km" = "Esc. Privadas 1km",
    "cantidad_super_1km" = "Supermercados 1km",
    "cantidad_restau_1km" = "Restaurantes 1km",
    "cantidad_oficina_1km" = "Oficinas 1km",
    "proyectos_total" = "Proyectos Desarrollador",
    "absorcion_promedio_dev" = "Absorci√≥n Prom. Dev.",
    "consistencia_absorcion" = "Consistencia Dev.",
    "pob2020_1km" = "Poblaci√≥n 1km",
    "hogares2020_1km" = "Hogares 1km",
    "alta_densidad_comercial" = "Densidad Comercial",
    "alto_entorno_laboral" = "Entorno Laboral",
    "competitividad_precio" = "Competitividad Precio",
    "propuesta_valor_v2" = "Propuesta de Valor"
  )
  
  # Aplicar etiquetas
  top_fortalezas$Etiqueta <- sapply(top_fortalezas$Variable, function(x) {
    if(x %in% names(etiquetas_variables)) etiquetas_variables[x] else x
  })
  
  # Colores por categor√≠a de fortaleza
  colores_fortaleza <- c(
    "Excepcional" = "#2C6C66",
    "Muy Fuerte" = "#68D192", 
    "Fuerte" = "#F4E785",
    "Promedio" = "#F8C579",
    "√Årea de Mejora" = "#EF6558"
  )
  
  # Crear gr√°fico de barras horizontales
  p <- ggplot(top_fortalezas, aes(x = reorder(Etiqueta, Percentil), y = Percentil, 
                                  fill = Categoria_Fortaleza)) +
    geom_bar(stat = "identity", alpha = 0.8) +
    geom_text(aes(label = paste0(round(Percentil, 0), "%")), 
              hjust = -0.1, size = 3, fontface = "bold") +
    scale_fill_manual(values = colores_fortaleza, name = "Nivel") +
    coord_flip() +
    labs(title = paste("üèÜ Principales Fortalezas -", proyecto$Proyecto),
         subtitle = paste("Percentiles vs otros proyectos", proyecto$Segmento),
         x = "Factor", y = "Percentil en el Segmento (%)") +
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", size = 14, color = "#2C6C66"),
      plot.subtitle = element_text(size = 11, color = "#2C6C66"),
      axis.text.y = element_text(size = 9),
      legend.position = "bottom"
    ) +
    scale_y_continuous(limits = c(0, 105), breaks = seq(0, 100, 25))
  
  return(p)
}

# 16.3 Funci√≥n para crear gr√°fico radar de fortalezas clave
crear_radar_fortalezas <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  # Obtener proyecto
  proyecto <- seleccionar_proyecto_segmentado(datos, indice_proyecto, nombre_proyecto)
  
  # Definir categor√≠as clave para radar
  categorias_radar <- list(
    "Amenidades" = c("score_amenidades_total", "num_amenidades"),
    "Performance" = c("absorcion", "eficiencia_comercial", "ratio_ventas"),
    "Ubicaci√≥n" = c("indice_accesibilidad", "indice_conveniencia", "accesibilidad_vial"),
    "Servicios" = c("cercania_hospital", "cercania_esc_priv", "cantidad_super_1km"),
    "Desarrollador" = c("proyectos_total", "absorcion_promedio_dev", "consistencia_absorcion"),
    "Entorno" = c("pob2020_1km", "alta_densidad_comercial", "alto_entorno_laboral")
  )
  
  # Obtener datos del segmento
  datos_segmento <- datos %>% 
    filter(Segmento == proyecto$Segmento) %>%
    filter(!is.na(ivu_segmentado) & !is.na(ivp_segmentado))
  
  # Calcular score promedio por categor√≠a
  scores_categoria <- data.frame(
    Categoria = character(0),
    Score = numeric(0),
    stringsAsFactors = FALSE
  )
  
  for(categoria in names(categorias_radar)) {
    variables_cat <- intersect(categorias_radar[[categoria]], names(datos_segmento))
    
    if(length(variables_cat) > 0) {
      # Calcular percentiles promedio para esta categor√≠a
      percentiles_cat <- numeric(0)
      
      for(var in variables_cat) {
        valor_proyecto <- proyecto[[var]]
        if(!is.na(valor_proyecto)) {
          valores_segmento <- datos_segmento[[var]]
          valores_validos <- valores_segmento[!is.na(valores_segmento)]
          
          if(length(valores_validos) > 2) {
            percentil <- mean(valores_validos <= valor_proyecto, na.rm = TRUE) * 100
            percentiles_cat <- c(percentiles_cat, percentil)
          }
        }
      }
      
      if(length(percentiles_cat) > 0) {
        score_promedio <- mean(percentiles_cat)
        scores_categoria <- rbind(scores_categoria, data.frame(
          Categoria = categoria,
          Score = score_promedio,
          stringsAsFactors = FALSE
        ))
      }
    }
  }
  
  # Asegurar que tenemos al menos 3 categor√≠as
  if(nrow(scores_categoria) >= 3) {
    # Preparar datos para radar (agregar primera fila al final para cerrar)
    radar_data <- rbind(scores_categoria, scores_categoria[1, ])
    
    # Crear gr√°fico de radar
    p <- ggplot(radar_data, aes(x = Categoria, y = Score)) +
      geom_polygon(fill = "#68D192", alpha = 0.3, color = "#2C6C66", linewidth = 1) +
      geom_point(color = "#2C6C66", size = 3) +
      coord_polar() +
      ylim(0, 100) +
      labs(title = paste("üéØ Perfil de Fortalezas -", proyecto$Proyecto),
           subtitle = "Percentiles por categor√≠a vs segmento") +
      theme_minimal() +
      theme(
        plot.title = element_text(face = "bold", size = 14, color = "#2C6C66", hjust = 0.5),
        plot.subtitle = element_text(size = 11, color = "#2C6C66", hjust = 0.5),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        panel.grid.major.y = element_line(color = "gray90", linewidth = 0.5),
        axis.text.x = element_text(size = 10, face = "bold")
      )
    
    return(p)
  } else {
    # Crear gr√°fico placeholder si no hay suficientes datos
    p <- ggplot() +
      geom_text(aes(x = 0.5, y = 0.5, label = "Datos insuficientes\npara radar"), 
                size = 6, color = "#2C6C66") +
      labs(title = paste("üéØ Perfil de Fortalezas -", proyecto$Proyecto)) +
      theme_void()
    return(p)
  }
}

# 16.4 Funci√≥n para generar reporte textual de fortalezas
generar_reporte_fortalezas <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  # Obtener an√°lisis
  fortalezas <- identificar_fortalezas_proyecto(datos, indice_proyecto, nombre_proyecto)
  proyecto <- seleccionar_proyecto_segmentado(datos, indice_proyecto, nombre_proyecto)
  
  # Filtrar solo fortalezas significativas (percentil >= 75)
  fortalezas_top <- fortalezas %>% filter(Percentil >= 75)
  
  cat("\n", rep("üèÜ", 20), "\n")
  cat("AN√ÅLISIS DE FORTALEZAS COMPETITIVAS\n")
  cat(rep("üèÜ", 20), "\n")
  
  cat("\nüìä PROYECTO:", proyecto$Proyecto, "\n")
  cat("üè† SEGMENTO:", proyecto$Segmento, "| NSE:", proyecto$nse, "\n")
  
  # Corregir la sintaxis del pipe
  datos_segmento_count <- datos %>% 
    filter(Segmento == proyecto$Segmento) %>%
    pull(ivu_segmentado) %>%
    {sum(!is.na(.))}
  
  cat("üìà POSICI√ìN: Comparaci√≥n vs", datos_segmento_count, "proyectos del segmento\n")
  
  if(nrow(fortalezas_top) > 0) {
    cat("\nüåü FORTALEZAS DESTACADAS (Percentil ‚â•75%):\n")
    
    # Agrupar por categor√≠a de fortaleza
    excepcionales <- fortalezas_top %>% filter(Categoria_Fortaleza == "Excepcional")
    muy_fuertes <- fortalezas_top %>% filter(Categoria_Fortaleza == "Muy Fuerte")
    
    if(nrow(excepcionales) > 0) {
      cat("\nü•á EXCEPCIONAL (Top 10%):\n")
      for(i in 1:nrow(excepcionales)) {
        cat("  ‚Ä¢", excepcionales$Variable[i], "- Percentil:", 
            round(excepcionales$Percentil[i], 0), "%\n")
      }
    }
    
    if(nrow(muy_fuertes) > 0) {
      cat("\nü•à MUY FUERTE (Top 25%):\n")
      for(i in 1:nrow(muy_fuertes)) {
        cat("  ‚Ä¢", muy_fuertes$Variable[i], "- Percentil:", 
            round(muy_fuertes$Percentil[i], 0), "%\n")
      }
    }
    
    # Interpretaciones espec√≠ficas
    cat("\nüí° INTERPRETACI√ìN DE FORTALEZAS:\n")
    
    # Amenidades
    if(any(grepl("amenidades|num_amenidades", fortalezas_top$Variable))) {
      cat("üè¢ AMENIDADES: Proyecto sobresale en oferta de amenidades vs competencia\n")
    }
    
    # Performance comercial
    if(any(grepl("absorcion|ratio_ventas|eficiencia", fortalezas_top$Variable))) {
      cat("üìà PERFORMANCE: Excelente desempe√±o comercial y de ventas\n")
    }
    
    # Ubicaci√≥n
    if(any(grepl("accesibilidad|conveniencia|cercania", fortalezas_top$Variable))) {
      cat("üìç UBICACI√ìN: Localizaci√≥n estrat√©gica con excelente accesibilidad\n")
    }
    
    # Desarrollador
    if(any(grepl("proyectos_total|absorcion_promedio_dev|consistencia", fortalezas_top$Variable))) {
      cat("üèóÔ∏è DESARROLLADOR: Track record s√≥lido y experiencia comprobada\n")
    }
    
    # Entorno
    if(any(grepl("pob2020|hogares|densidad", fortalezas_top$Variable))) {
      cat("üåÜ ENTORNO: Zona con excelente densidad poblacional y comercial\n")
    }
    
  } else {
    cat("\n‚ö†Ô∏è  No se identificaron fortalezas destacadas (percentil ‚â•75%)\n")
    cat("üìä Top 5 aspectos relativos del proyecto:\n")
    top_5 <- head(fortalezas, 5)
    for(i in 1:nrow(top_5)) {
      cat("  ", i, ".", top_5$Variable[i], "- Percentil:", 
          round(top_5$Percentil[i], 0), "%\n")
    }
  }
  
  # √Åreas de mejora
  areas_mejora <- fortalezas %>% filter(Percentil < 40) %>% head(3)
  if(nrow(areas_mejora) > 0) {
    cat("\nüîß √ÅREAS DE OPORTUNIDAD (Percentil <40%):\n")
    for(i in 1:nrow(areas_mejora)) {
      cat("  ‚Ä¢", areas_mejora$Variable[i], "- Percentil:", 
          round(areas_mejora$Percentil[i], 0), "%\n")
    }
  }
  
  cat("\n", rep("üèÜ", 20), "\n")
  
  return(fortalezas_top)
}

# 16.5 Funci√≥n para dashboard completo de fortalezas
crear_dashboard_fortalezas <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  
  # Crear visualizaciones
  grafico_barras <- crear_visualizacion_fortalezas(datos, indice_proyecto, nombre_proyecto)
  grafico_radar <- crear_radar_fortalezas(datos, indice_proyecto, nombre_proyecto)
  
  # Obtener proyecto para t√≠tulo
  proyecto <- seleccionar_proyecto_segmentado(datos, indice_proyecto, nombre_proyecto)
  
  # Combinar gr√°ficos
  dashboard_fortalezas <- grid.arrange(
    grafico_barras, grafico_radar,
    ncol = 2, nrow = 1,
    top = grid::textGrob(paste("üèÜ An√°lisis de Fortalezas Competitivas -", proyecto$Proyecto), 
                         gp = grid::gpar(fontsize = 16, fontface = "bold", col = "#2C6C66"))
  )
  
  return(dashboard_fortalezas)
}

# 16.6 An√°lisis de factores √∫nicos (diferenciadores)
identificar_diferenciadores <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  # Obtener proyecto y fortalezas
  proyecto <- seleccionar_proyecto_segmentado(datos, indice_proyecto, nombre_proyecto)
  fortalezas <- identificar_fortalezas_proyecto(datos, indice_proyecto, nombre_proyecto)
  
  # Identificar factores √∫nicos o muy raros
  datos_segmento <- datos %>% filter(Segmento == proyecto$Segmento)
  
  diferenciadores <- list()
  
  # 1. Amenidades √∫nicas o superiores
  if(!is.na(proyecto$num_amenidades)) {
    amenidades_prom <- mean(datos_segmento$num_amenidades, na.rm = TRUE)
    if(proyecto$num_amenidades >= amenidades_prom * 1.5) {
      diferenciadores$amenidades <- paste0("N√∫mero excepcional de amenidades (", 
                                           proyecto$num_amenidades, " vs promedio ", 
                                           round(amenidades_prom, 1), ")")
    }
  }
  
  # 2. Performance comercial excepcional
  if(!is.na(proyecto$absorcion)) {
    absorcion_p90 <- quantile(datos_segmento$absorcion, 0.9, na.rm = TRUE)
    if(proyecto$absorcion >= absorcion_p90) {
      diferenciadores$performance <- paste0("Absorci√≥n en top 10% del segmento (", 
                                            round(proyecto$absorcion, 1), ")")
    }
  }
  
  # 3. Ubicaci√≥n privilegiada
  factores_ubicacion <- c("indice_accesibilidad", "accesibilidad_vial", "indice_conveniencia")
  ubicacion_scores <- numeric(0)
  
  for(factor in factores_ubicacion) {
    if(factor %in% names(proyecto) && !is.na(proyecto[[factor]])) {
      valores_segmento <- datos_segmento[[factor]]
      percentil <- mean(valores_segmento <= proyecto[[factor]], na.rm = TRUE) * 100
      ubicacion_scores <- c(ubicacion_scores, percentil)
    }
  }
  
  if(length(ubicacion_scores) > 0 && mean(ubicacion_scores) >= 85) {
    diferenciadores$ubicacion <- "Ubicaci√≥n en top 15% con excelente accesibilidad integral"
  }
  
  # 4. Desarrollador de elite
  if(!is.na(proyecto$proyectos_total) && !is.na(proyecto$absorcion_promedio_dev)) {
    if(proyecto$proyectos_total >= 5 && proyecto$absorcion_promedio_dev >= 4) {
      diferenciadores$desarrollador <- paste0("Desarrollador experimentado (", 
                                              proyecto$proyectos_total, " proyectos, absorci√≥n prom: ", 
                                              round(proyecto$absorcion_promedio_dev, 1), ")")
    }
  }
  
  return(diferenciadores)
}

# ---- 17. INTEGRACI√ìN CON AN√ÅLISIS EXISTENTE ----

# 17.1 Actualizar funci√≥n de an√°lisis principal para incluir fortalezas
analizar_proyecto_4s_completo <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  # Ejecutar an√°lisis 4S original
  analisis_base <- analizar_proyecto_4s(datos, indice_proyecto, nombre_proyecto)
  
  # Agregar an√°lisis de fortalezas
  cat("\n" , rep("üèÜ", 30), "\n")
  cat("AN√ÅLISIS DETALLADO DE FORTALEZAS COMPETITIVAS\n")
  cat(rep("üèÜ", 30), "\n")
  
  fortalezas_detalle <- generar_reporte_fortalezas(datos, indice_proyecto, nombre_proyecto)
  
  # Diferenciadores √∫nicos
  diferenciadores <- identificar_diferenciadores(datos, indice_proyecto, nombre_proyecto)
  
  if(length(diferenciadores) > 0) {
    cat("\nüéØ DIFERENCIADORES √öNICOS:\n")
    for(i in 1:length(diferenciadores)) {
      cat("  ", i, ".", diferenciadores[[i]], "\n")
    }
  }
  
  cat("\n", rep("üèÜ", 30), "\n")
  
  # Retornar an√°lisis combinado
  return(list(
    analisis_4s = analisis_base,
    fortalezas = fortalezas_detalle,
    diferenciadores = diferenciadores
  ))
}

# 17.2 Actualizar dashboard principal para incluir fortalezas
crear_dashboard_proyecto_4s_completo <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  
  # Dashboard original (4 paneles)
  dashboard_original <- crear_dashboard_proyecto_4s(datos, indice_proyecto, nombre_proyecto)
  
  # Dashboard de fortalezas (2 paneles)
  dashboard_fortalezas <- crear_dashboard_fortalezas(datos, indice_proyecto, nombre_proyecto)
  
  # Mostrar ambos dashboards
  cat("\n=== DASHBOARD PRINCIPAL 4S ===\n")
  print(dashboard_original)
  
  cat("\n=== DASHBOARD DE FORTALEZAS ===\n") 
  print(dashboard_fortalezas)
  
  return(list(
    dashboard_principal = dashboard_original,
    dashboard_fortalezas = dashboard_fortalezas
  ))
}

# ---- 18. ACTUALIZACI√ìN DE EJEMPLOS DE USO ----

# Actualizar la secci√≥n 14 del script original para incluir an√°lisis de fortalezas
# Esta secci√≥n reemplaza o complementa la secci√≥n 14 existente

# 18.1 Definir proyecto a analizar (mismo que antes)
# PROYECTO_SELECCIONADO <- 29  # Ya definido en el script principal

# 18.2 An√°lisis completo incluyendo fortalezas
cat("\n=== AN√ÅLISIS COMPLETO CON FORTALEZAS ===\n")

if(PROYECTO_SELECCIONADO <= nrow(datos_segmentados)) {
  proyecto_info <- datos_segmentados[PROYECTO_SELECCIONADO, ]
  
  if(!is.na(proyecto_info$ivu_segmentado) && !is.na(proyecto_info$ivp_segmentado)) {
    
    cat("Analizando proyecto:", proyecto_info$Proyecto, "\n")
    cat("Segmento:", proyecto_info$Segmento, "| NSE:", proyecto_info$nse, "\n")
    
    # Visualizaciones principales (como antes)
    cat("\n1. Creando term√≥metros y panel 4S...\n")
    termometro_ivu_individual <- crear_termometro_ivu_segmentado(datos_segmentados, PROYECTO_SELECCIONADO)
    print(termometro_ivu_individual)
    
    termometro_ivp_individual <- crear_termometro_ivp_segmentado(datos_segmentados, PROYECTO_SELECCIONADO)
    print(termometro_ivp_individual)
    
    panel_4s_individual <- crear_panel_categorizacion_4s(datos_segmentados, PROYECTO_SELECCIONADO)
    print(panel_4s_individual)
    
    # NUEVAS VISUALIZACIONES DE FORTALEZAS
    cat("\n2. Creando an√°lisis de fortalezas...\n")
    
    # Gr√°fico de barras de fortalezas
    cat("   a) Gr√°fico de fortalezas principales...\n")
    grafico_fortalezas <- crear_visualizacion_fortalezas(datos_segmentados, PROYECTO_SELECCIONADO)
    print(grafico_fortalezas)
    
    # Gr√°fico radar de categor√≠as
    cat("   b) Radar de perfil de fortalezas...\n")
    radar_fortalezas <- crear_radar_fortalezas(datos_segmentados, PROYECTO_SELECCIONADO)
    print(radar_fortalezas)
    
    # Dashboard combinado de fortalezas
    cat("   c) Dashboard integrado de fortalezas...\n")
    dashboard_fortalezas_completo <- crear_dashboard_fortalezas(datos_segmentados, PROYECTO_SELECCIONADO)
    
    # An√°lisis textual completo
    cat("\n3. Generando an√°lisis completo con fortalezas...\n")
    analisis_completo <- analizar_proyecto_4s_completo(datos_segmentados, PROYECTO_SELECCIONADO)
    
    # Dashboard completo (original + fortalezas)
    cat("\n4. Creando dashboard completo...\n")
    dashboards_completos <- crear_dashboard_proyecto_4s_completo(datos_segmentados, PROYECTO_SELECCIONADO)
    
  } else {
    cat("ERROR: El proyecto seleccionado no tiene datos segmentados v√°lidos.\n")
  }
} else {
  cat("ERROR: √çndice de proyecto fuera de rango. M√°ximo:", nrow(datos_segmentados), "\n")
}

# 18.3 Funciones de uso directo para an√°lisis r√°pido
cat("\n=== FUNCIONES DE USO R√ÅPIDO ===\n")
cat("Para an√°lisis r√°pido de fortalezas de cualquier proyecto:\n\n")

cat("# An√°lisis de fortalezas espec√≠fico:\n")
cat("fortalezas <- identificar_fortalezas_proyecto(datos_segmentados, 25)\n")
cat("View(fortalezas)  # Ver tabla completa de percentiles\n\n")

cat("# Visualizaci√≥n r√°pida de fortalezas:\n") 
cat("crear_visualizacion_fortalezas(datos_segmentados, 25)\n\n")

cat("# Reporte textual de fortalezas:\n")
cat("generar_reporte_fortalezas(datos_segmentados, 25)\n\n")

cat("# Dashboard completo:\n")
cat("crear_dashboard_proyecto_4s_completo(datos_segmentados, 25)\n\n")

cat("# An√°lisis por nombre:\n")
cat("analizar_proyecto_4s_completo(datos_segmentados, nombre_proyecto = 'Nombre Proyecto')\n\n")

# 18.4 Ejemplo de an√°lisis comparativo entre proyectos
comparar_fortalezas_proyectos <- function(datos, proyecto1, proyecto2) {
  cat("\n=== COMPARACI√ìN DE FORTALEZAS ENTRE PROYECTOS ===\n")
  
  # Obtener fortalezas de ambos proyectos
  fortalezas1 <- identificar_fortalezas_proyecto(datos, proyecto1)
  fortalezas2 <- identificar_fortalezas_proyecto(datos, proyecto2)
  
  proy1 <- seleccionar_proyecto_segmentado(datos, proyecto1)
  proy2 <- seleccionar_proyecto_segmentado(datos, proyecto2)
  
  cat("Proyecto 1:", proy1$Proyecto, "(", proy1$Segmento, ")\n")
  cat("Proyecto 2:", proy2$Proyecto, "(", proy2$Segmento, ")\n\n")
  
  # Top 5 fortalezas de cada uno
  cat("üèÜ TOP 5 FORTALEZAS PROYECTO 1:\n")
  top5_1 <- head(fortalezas1, 5)
  for(i in 1:nrow(top5_1)) {
    cat("  ", i, ".", top5_1$Variable[i], "- Percentil:", round(top5_1$Percentil[i], 0), "%\n")
  }
  
  cat("\nüèÜ TOP 5 FORTALEZAS PROYECTO 2:\n") 
  top5_2 <- head(fortalezas2, 5)
  for(i in 1:nrow(top5_2)) {
    cat("  ", i, ".", top5_2$Variable[i], "- Percentil:", round(top5_2$Percentil[i], 0), "%\n")
  }
  
  cat("\nüí° Usar esta funci√≥n: comparar_fortalezas_proyectos(datos_segmentados, 15, 25)\n")
}

cat("\n=== AN√ÅLISIS DE FORTALEZAS IMPLEMENTADO EXITOSAMENTE ===\n")
cat("‚úÖ Identificaci√≥n autom√°tica de fortalezas por percentiles\n")
cat("‚úÖ Visualizaciones de barras y radar para fortalezas\n") 
cat("‚úÖ Reporte textual interpretativo de diferenciadores\n")
cat("‚úÖ Dashboard integrado con an√°lisis 4S + fortalezas\n")
cat("‚úÖ Funciones de comparaci√≥n entre proyectos\n")
cat("‚úÖ An√°lisis de factores √∫nicos y diferenciadores\n")

# ---- 19. AN√ÅLISIS INTEGRADO DE FORTALEZAS Y DEBILIDADES ----
## 19.1 Funci√≥n para identificar debilidades del proyecto
identificar_debilidades_proyecto <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  # Reutilizar la funci√≥n de fortalezas existente pero filtrar por debilidades
  fortalezas_completas <- identificar_fortalezas_proyecto(datos, indice_proyecto, nombre_proyecto)
  
  # Filtrar solo las debilidades (percentil <= 30)
  debilidades <- fortalezas_completas %>%
    filter(Percentil <= 30) %>%
    arrange(Percentil) %>%  # Ordenar de menor a mayor percentil
    mutate(
      Categoria_Debilidad = case_when(
        Percentil <= 10 ~ "Cr√≠tica",
        Percentil <= 20 ~ "Muy D√©bil",
        TRUE ~ "D√©bil"
      )
    )
  
  return(debilidades)
}

## 19.2 Funci√≥n para crear visualizaci√≥n de debilidades
crear_visualizacion_debilidades <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  # Obtener an√°lisis de debilidades
  debilidades <- identificar_debilidades_proyecto(datos, indice_proyecto, nombre_proyecto)
  proyecto <- seleccionar_proyecto_segmentado(datos, indice_proyecto, nombre_proyecto)
  
  if(nrow(debilidades) == 0) {
    # Si no hay debilidades significativas, crear gr√°fico placeholder
    p <- ggplot() +
      geom_text(aes(x = 0.5, y = 0.5, label = "¬°Excelente!\nNo se identificaron\ndebilidades significativas"), 
                size = 6, color = "#2C6C66", fontface = "bold") +
      labs(title = paste("‚ö†Ô∏è √Åreas de Mejora -", proyecto$Proyecto),
           subtitle = "Proyecto sin debilidades cr√≠ticas identificadas") +
      theme_void() +
      theme(
        plot.title = element_text(face = "bold", size = 14, color = "#2C6C66", hjust = 0.5),
        plot.subtitle = element_text(size = 11, color = "#68D192", hjust = 0.5)
      )
    return(p)
  }
  
  # Tomar top 12 debilidades para visualizaci√≥n
  top_debilidades <- head(debilidades, 12)
  
  # Crear etiquetas m√°s amigables (reutilizar del c√≥digo existente)
  etiquetas_variables <- c(
    "absorcion" = "Absorci√≥n",
    "ratio_ventas" = "Ratio de Ventas", 
    "eficiencia_comercial" = "Eficiencia Comercial",
    "velocidad_ventas" = "Velocidad Ventas",
    "score_amenidades_total" = "Score Amenidades",
    "num_amenidades" = "N√∫mero Amenidades",
    "m2_inv" = "Superficie Inventario",
    "indice_accesibilidad" = "Accesibilidad",
    "accesibilidad_vial" = "Accesibilidad Vial",
    "indice_conveniencia" = "Conveniencia",
    "cerca_parque_relevante" = "Cercan√≠a Parque",
    "dist_to_park" = "Distancia Parque",
    "cercania_hospital" = "Cercan√≠a Hospital",
    "cercania_esc_priv" = "Cercan√≠a Esc. Privada",
    "cercania_universidad" = "Cercan√≠a Universidad",
    "cercania_super" = "Cercan√≠a Supermercado",
    "cantidad_hospital_1km" = "Hospitales 1km",
    "cantidad_esc_priv_1km" = "Esc. Privadas 1km",
    "pob2020_1km" = "Poblaci√≥n 1km",
    "competitividad_precio" = "Competitividad Precio",
    "meses_inv" = "Meses en Inventario",
    "meses_mercado" = "Meses en Mercado"
  )
  
  # Aplicar etiquetas
  top_debilidades$Etiqueta <- sapply(top_debilidades$Variable, function(x) {
    if(x %in% names(etiquetas_variables)) etiquetas_variables[x] else x
  })
  
  # Colores por categor√≠a de debilidad
  colores_debilidad <- c(
    "Cr√≠tica" = "#C53030",
    "Muy D√©bil" = "#E53E3E", 
    "D√©bil" = "#EF6558"
  )
  
  # Crear gr√°fico de barras horizontales
  p <- ggplot(top_debilidades, aes(x = reorder(Etiqueta, -Percentil), y = Percentil, 
                                   fill = Categoria_Debilidad)) +
    geom_bar(stat = "identity", alpha = 0.8) +
    geom_text(aes(label = paste0(round(Percentil, 0), "%")), 
              hjust = 1.1, size = 3, fontface = "bold", color = "white") +
    scale_fill_manual(values = colores_debilidad, name = "Nivel") +
    coord_flip() +
    labs(title = paste("‚ö†Ô∏è Principales √Åreas de Mejora -", proyecto$Proyecto),
         subtitle = paste("Percentiles m√°s bajos vs otros proyectos", proyecto$Segmento),
         x = "Factor", y = "Percentil en el Segmento (%)") +
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", size = 14, color = "#C53030"),
      plot.subtitle = element_text(size = 11, color = "#C53030"),
      axis.text.y = element_text(size = 9),
      legend.position = "bottom"
    ) +
    scale_y_continuous(limits = c(0, 35), breaks = seq(0, 30, 10))
  
  return(p)
}

## 19.3 Funci√≥n para crear gr√°fico espejo fortalezas vs debilidades
crear_grafico_espejo_fortalezas_debilidades <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  # Obtener ambos an√°lisis
  fortalezas <- identificar_fortalezas_proyecto(datos, indice_proyecto, nombre_proyecto) %>%
    filter(Percentil >= 70) %>%
    head(6)
  
  debilidades <- identificar_debilidades_proyecto(datos, indice_proyecto, nombre_proyecto) %>%
    head(6)
  
  proyecto <- seleccionar_proyecto_segmentado(datos, indice_proyecto, nombre_proyecto)
  
  # Crear etiquetas amigables
  etiquetas_variables <- c(
    "absorcion" = "Absorci√≥n", "score_amenidades_total" = "Score Amenidades",
    "indice_accesibilidad" = "Accesibilidad", "num_amenidades" = "N√∫m. Amenidades",
    "accesibilidad_vial" = "Accesibilidad Vial", "indice_conveniencia" = "Conveniencia",
    "cercania_hospital" = "Cercan√≠a Hospital", "meses_inv" = "Meses Inventario",
    "competitividad_precio" = "Competitividad", "dist_to_park" = "Dist. Parque"
  )
  
  # Preparar datos para el gr√°fico espejo
  max_items <- max(nrow(fortalezas), nrow(debilidades), 3)
  
  # Datos de fortalezas (lado positivo)
  datos_fortalezas <- data.frame(
    Orden = 1:max_items,
    Variable = character(max_items),
    Valor = numeric(max_items),
    Tipo = "Fortaleza",
    stringsAsFactors = FALSE
  )
  
  for(i in 1:max_items) {
    if(i <= nrow(fortalezas)) {
      var_name <- fortalezas$Variable[i]
      datos_fortalezas$Variable[i] <- ifelse(var_name %in% names(etiquetas_variables), 
                                             etiquetas_variables[var_name], var_name)
      datos_fortalezas$Valor[i] <- fortalezas$Percentil[i]
    } else {
      datos_fortalezas$Variable[i] <- ""
      datos_fortalezas$Valor[i] <- NA
    }
  }
  
  # Datos de debilidades (lado negativo)
  datos_debilidades <- data.frame(
    Orden = 1:max_items,
    Variable = character(max_items),
    Valor = numeric(max_items),
    Tipo = "Debilidad",
    stringsAsFactors = FALSE
  )
  
  for(i in 1:max_items) {
    if(i <= nrow(debilidades)) {
      var_name <- debilidades$Variable[i]
      datos_debilidades$Variable[i] <- ifelse(var_name %in% names(etiquetas_variables), 
                                              etiquetas_variables[var_name], var_name)
      datos_debilidades$Valor[i] <- -debilidades$Percentil[i]  # Negativo para el espejo
    } else {
      datos_debilidades$Variable[i] <- ""
      datos_debilidades$Valor[i] <- NA
    }
  }
  
  # Combinar datos y filtrar valores v√°lidos
  datos_combinados <- rbind(datos_fortalezas, datos_debilidades) %>%
    filter(!is.na(Valor) & Variable != "")
  
  if(nrow(datos_combinados) == 0) {
    # Si no hay datos, crear gr√°fico placeholder
    p <- ggplot() +
      geom_text(aes(x = 0.5, y = 0.5, label = "Datos insuficientes\npara an√°lisis espejo"), 
                size = 6, color = "#6c757d") +
      labs(title = paste("‚öñÔ∏è An√°lisis Espejo -", proyecto$Proyecto)) +
      theme_void()
    return(p)
  }
  
  # Crear gr√°fico espejo
  colores_espejo <- c("Fortaleza" = "#68D192", "Debilidad" = "#EF6558")
  
  p <- ggplot(datos_combinados, aes(x = reorder(Variable, abs(Valor)), y = Valor, fill = Tipo)) +
    geom_bar(stat = "identity", alpha = 0.8, width = 0.7) +
    geom_hline(yintercept = 0, color = "gray40", linewidth = 1) +
    
    # Etiquetas de valores
    geom_text(aes(label = paste0(abs(round(Valor)), "%")), 
              hjust = ifelse(datos_combinados$Valor > 0, -0.1, 1.1), 
              size = 3.5, fontface = "bold", color = "gray20") +
    
    scale_fill_manual(values = colores_espejo, name = "") +
    coord_flip() +
    
    labs(title = paste("‚öñÔ∏è An√°lisis Espejo: Fortalezas vs Debilidades"),
         subtitle = paste("Proyecto:", proyecto$Proyecto, "|", proyecto$Segmento),
         x = "", y = "Percentil en Segmento (%)") +
    
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", size = 16, color = "#2C6C66", hjust = 0.5),
      plot.subtitle = element_text(size = 12, color = "#2C6C66", hjust = 0.5),
      axis.text.y = element_text(size = 10),
      axis.text.x = element_text(size = 9),
      legend.position = "bottom",
      legend.title = element_text(face = "bold"),
      panel.grid.major.y = element_blank(),
      panel.grid.minor = element_blank()
    ) +
    
    scale_y_continuous(
      limits = c(-100, 100),
      breaks = seq(-100, 100, 25),
      labels = function(x) paste0(abs(x), "%")
    ) +
    
    # Anotaciones explicativas
    annotate("text", x = max_items * 0.7, y = 75, 
             label = "FORTALEZAS\n(Percentil ‚â•70)", 
             fontface = "bold", color = "#2C6C66", size = 3.5) +
    annotate("text", x = max_items * 0.7, y = -75, 
             label = "DEBILIDADES\n(Percentil ‚â§30)", 
             fontface = "bold", color = "#C53030", size = 3.5)
  
  return(p)
}

## 19.4 Funci√≥n para crear dashboard completo con fortalezas y debilidades
crear_dashboard_fortalezas_debilidades_integrado <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  
  # Obtener informaci√≥n del proyecto
  proyecto <- seleccionar_proyecto_segmentado(datos, indice_proyecto, nombre_proyecto)
  
  # Crear visualizaciones individuales
  grafico_fortalezas <- crear_visualizacion_fortalezas(datos, indice_proyecto, nombre_proyecto)
  grafico_debilidades <- crear_visualizacion_debilidades(datos, indice_proyecto, nombre_proyecto)
  grafico_espejo <- crear_grafico_espejo_fortalezas_debilidades(datos, indice_proyecto, nombre_proyecto)
  
  # Obtener estad√≠sticas para panel de resumen
  fortalezas <- identificar_fortalezas_proyecto(datos, indice_proyecto, nombre_proyecto) %>%
    filter(Percentil >= 70)
  debilidades <- identificar_debilidades_proyecto(datos, indice_proyecto, nombre_proyecto)
  
  # Crear panel de resumen estad√≠stico
  num_fortalezas <- nrow(fortalezas)
  num_debilidades <- nrow(debilidades)
  
  # Calcular score general (promedio de todos los percentiles)
  todos_percentiles <- identificar_fortalezas_proyecto(datos, indice_proyecto, nombre_proyecto)
  score_general <- round(mean(todos_percentiles$Percentil, na.rm = TRUE), 1)
  
  # Determinar balance competitivo
  balance <- case_when(
    num_fortalezas >= 5 & num_debilidades <= 2 ~ "DOMINANTE",
    num_fortalezas >= 3 & num_debilidades <= 3 ~ "COMPETITIVO",
    num_fortalezas >= 2 & num_debilidades <= 5 ~ "EQUILIBRADO",
    num_fortalezas <= 2 & num_debilidades >= 3 ~ "DESAFIANTE",
    TRUE ~ "NEUTRAL"
  )
  
  # Crear panel de resumen
  panel_resumen <- ggplot() +
    geom_rect(aes(xmin = 0.05, xmax = 0.95, ymin = 0.1, ymax = 0.9), 
              fill = "#f8f9fa", color = "#2C6C66", linewidth = 2, alpha = 0.8) +
    
    # T√≠tulo del panel
    geom_text(aes(x = 0.5, y = 0.8, label = "üìä RESUMEN COMPETITIVO"),
              size = 6, fontface = "bold", color = "#2C6C66") +
    
    # Estad√≠sticas principales
    geom_text(aes(x = 0.25, y = 0.65, label = paste0("üèÜ FORTALEZAS\n", num_fortalezas)),
              size = 5, fontface = "bold", color = "#68D192") +
    geom_text(aes(x = 0.75, y = 0.65, label = paste0("‚ö†Ô∏è DEBILIDADES\n", num_debilidades)),
              size = 5, fontface = "bold", color = "#EF6558") +
    
    # Score general
    geom_text(aes(x = 0.5, y = 0.5, label = paste0("üìà SCORE GENERAL\n", score_general, "%")),
              size = 5, fontface = "bold", color = "#2C6C66") +
    
    # Balance competitivo
    geom_text(aes(x = 0.5, y = 0.35, label = paste0("‚öñÔ∏è BALANCE: ", balance)),
              size = 4, fontface = "bold", 
              color = case_when(
                balance == "DOMINANTE" ~ "#2C6C66",
                balance == "COMPETITIVO" ~ "#68D192",
                balance == "EQUILIBRADO" ~ "#F4A261",
                balance == "DESAFIANTE" ~ "#E76F51",
                TRUE ~ "#6c757d"
              )) +
    
    # Informaci√≥n del proyecto
    geom_text(aes(x = 0.5, y = 0.2, 
                  label = paste0(proyecto$Proyecto, " | ", proyecto$Segmento, " | NSE: ", proyecto$nse)),
              size = 3.5, color = "#6c757d") +
    
    theme_void() +
    coord_cartesian(xlim = c(0, 1), ylim = c(0, 1))
  
  # Combinar en dashboard usando grid.arrange
  dashboard <- grid.arrange(
    grafico_espejo,                           # Fila 1: Gr√°fico espejo completo
    arrangeGrob(grafico_fortalezas, grafico_debilidades, ncol = 2),  # Fila 2: Fortalezas y debilidades
    panel_resumen,                            # Fila 3: Panel de resumen
    ncol = 1, nrow = 3,
    heights = c(2, 1.5, 0.8),
    top = textGrob(paste("üéØ Dashboard Integral de Fortalezas y Debilidades -", proyecto$Proyecto), 
                   gp = gpar(fontsize = 18, fontface = "bold", col = "#2C6C66"))
  )
  
  return(dashboard)
}

## 19.5 Funci√≥n para reporte textual integrado
generar_reporte_fortalezas_debilidades <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  # Obtener an√°lisis de fortalezas (funci√≥n existente)
  fortalezas_detalle <- generar_reporte_fortalezas(datos, indice_proyecto, nombre_proyecto)
  
  # Obtener an√°lisis de debilidades
  debilidades <- identificar_debilidades_proyecto(datos, indice_proyecto, nombre_proyecto)
  proyecto <- seleccionar_proyecto_segmentado(datos, indice_proyecto, nombre_proyecto)
  
  cat("\n" , rep("‚öñÔ∏è", 30), "\n")
  cat("AN√ÅLISIS INTEGRAL DE DEBILIDADES\n")
  cat(rep("‚öñÔ∏è", 30), "\n")
  
  if(nrow(debilidades) > 0) {
    cat("\n‚ö†Ô∏è DEBILIDADES IDENTIFICADAS (Percentil ‚â§30%):\n")
    
    # Agrupar por categor√≠a de debilidad
    criticas <- debilidades %>% filter(Categoria_Debilidad == "Cr√≠tica")
    muy_debiles <- debilidades %>% filter(Categoria_Debilidad == "Muy D√©bil")
    debiles <- debilidades %>% filter(Categoria_Debilidad == "D√©bil")
    
    if(nrow(criticas) > 0) {
      cat("\nüö® CR√çTICAS (Bottom 10%):\n")
      for(i in 1:nrow(criticas)) {
        cat("  ‚Ä¢", criticas$Variable[i], "- Percentil:", 
            round(criticas$Percentil[i], 0), "%\n")
      }
    }
    
    if(nrow(muy_debiles) > 0) {
      cat("\n‚ùå MUY D√âBILES (Bottom 20%):\n")
      for(i in 1:nrow(muy_debiles)) {
        cat("  ‚Ä¢", muy_debiles$Variable[i], "- Percentil:", 
            round(muy_debiles$Percentil[i], 0), "%\n")
      }
    }
    
    if(nrow(debiles) > 0) {
      cat("\n‚ö° D√âBILES (Bottom 30%):\n")
      for(i in 1:nrow(debiles)) {
        cat("  ‚Ä¢", debiles$Variable[i], "- Percentil:", 
            round(debiles$Percentil[i], 0), "%\n")
      }
    }
    
    # Recomendaciones espec√≠ficas
    cat("\nüîß RECOMENDACIONES DE MEJORA:\n")
    
    # An√°lisis por tipo de debilidad
    if(any(grepl("amenidades|num_amenidades", debilidades$Variable))) {
      cat("üè¢ AMENIDADES: Considerar ampliar oferta de amenidades para competir mejor\n")
    }
    
    if(any(grepl("absorcion|ratio_ventas|eficiencia", debilidades$Variable))) {
      cat("üìà VENTAS: Revisar estrategia comercial y pricing para mejorar absorci√≥n\n")
    }
    
    if(any(grepl("accesibilidad|conveniencia|cercania", debilidades$Variable))) {
      cat("üìç UBICACI√ìN: Compensar limitaciones de ubicaci√≥n con propuesta de valor\n")
    }
    
    if(any(grepl("meses_inv|meses_mercado", debilidades$Variable))) {
      cat("‚è±Ô∏è TIEMPO: Acelerar comercializaci√≥n y reducir tiempo en mercado\n")
    }
    
  } else {
    cat("\n‚úÖ ¬°EXCELENTE POSICI√ìN COMPETITIVA!\n")
    cat("No se identificaron debilidades significativas (percentil ‚â§30%)\n")
    cat("El proyecto mantiene un rendimiento s√≥lido en todos los factores analizados.\n")
  }
  
  cat("\n", rep("‚öñÔ∏è", 30), "\n")
  
  return(debilidades)
}

## 19.6 Actualizaci√≥n de funci√≥n de an√°lisis completo
analizar_proyecto_4s_fortalezas_debilidades <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  # Ejecutar an√°lisis 4S base (funci√≥n existente)
  analisis_base <- analizar_proyecto_4s(datos, indice_proyecto, nombre_proyecto)
  
  # Agregar an√°lisis de fortalezas (funci√≥n existente)
  cat("\n" , rep("üèÜ", 30), "\n")
  cat("AN√ÅLISIS DETALLADO DE FORTALEZAS COMPETITIVAS\n")
  cat(rep("üèÜ", 30), "\n")
  
  fortalezas_detalle <- generar_reporte_fortalezas(datos, indice_proyecto, nombre_proyecto)
  
  # Agregar an√°lisis de debilidades (nueva funci√≥n)
  debilidades_detalle <- generar_reporte_fortalezas_debilidades(datos, indice_proyecto, nombre_proyecto)
  
  # Diferenciadores √∫nicos (funci√≥n existente)
  diferenciadores <- identificar_diferenciadores(datos, indice_proyecto, nombre_proyecto)
  
  if(length(diferenciadores) > 0) {
    cat("\nüéØ DIFERENCIADORES √öNICOS:\n")
    for(i in 1:length(diferenciadores)) {
      cat("  ", i, ".", diferenciadores[[i]], "\n")
    }
  }
  
  # Balance general
  num_fortalezas <- nrow(fortalezas_detalle)
  num_debilidades <- nrow(debilidades_detalle)
  
  cat("\nüìä BALANCE COMPETITIVO GENERAL:\n")
  cat("- Fortalezas identificadas:", num_fortalezas, "\n")
  cat("- Debilidades identificadas:", num_debilidades, "\n")
  
  if(num_fortalezas > num_debilidades) {
    cat("- Estrategia recomendada: üìà OFENSIVA - Capitalizar ventajas competitivas\n")
  } else if(num_debilidades > num_fortalezas) {
    cat("- Estrategia recomendada: üõ°Ô∏è DEFENSIVA - Corregir debilidades cr√≠ticas\n")
  } else {
    cat("- Estrategia recomendada: ‚öñÔ∏è EQUILIBRADA - Mantener fortalezas y mejorar debilidades\n")
  }
  
  cat("\n", rep("üéØ", 30), "\n")
  
  # Retornar an√°lisis combinado
  return(list(
    analisis_4s = analisis_base,
    fortalezas = fortalezas_detalle,
    debilidades = debilidades_detalle,
    diferenciadores = diferenciadores,
    balance = list(
      num_fortalezas = num_fortalezas,
      num_debilidades = num_debilidades
    )
  ))
}

## 19.7 Actualizaci√≥n de dashboard principal
crear_dashboard_4s_fortalezas_debilidades <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  
  # Dashboard 4S original (funciones existentes)
  dashboard_original <- crear_dashboard_proyecto_4s(datos, indice_proyecto, nombre_proyecto)
  
  # Dashboard integrado de fortalezas y debilidades
  dashboard_integrado <- crear_dashboard_fortalezas_debilidades_integrado(datos, indice_proyecto, nombre_proyecto)
  
  # Mostrar ambos dashboards
  cat("\n=== DASHBOARD PRINCIPAL 4S ===\n")
  print(dashboard_original)
  
  cat("\n=== DASHBOARD INTEGRADO DE FORTALEZAS Y DEBILIDADES ===\n") 
  print(dashboard_integrado)
  
  return(list(
    dashboard_principal = dashboard_original,
    dashboard_integrado = dashboard_integrado
  ))
}

## 19.8 Actualizaci√≥n del ejemplo de uso final

# Actualizar la secci√≥n 18 del script para incluir el nuevo an√°lisis
cat("\n=== AN√ÅLISIS COMPLETO CON FORTALEZAS Y DEBILIDADES (INTEGRADO) ===\n")

if(PROYECTO_SELECCIONADO <= nrow(datos_segmentados)) {
  proyecto_info <- datos_segmentados[PROYECTO_SELECCIONADO, ]
  
  if(!is.na(proyecto_info$ivu_segmentado) && !is.na(proyecto_info$ivp_segmentado)) {
    
    cat("Analizando proyecto:", proyecto_info$Proyecto, "\n")
    cat("Segmento:", proyecto_info$Segmento, "| NSE:", proyecto_info$nse, "\n")
    
    # An√°lisis textual completo (4S + Fortalezas + Debilidades)
    cat("\n1. Generando an√°lisis completo con fortalezas y debilidades...\n")
    analisis_completo_integrado <- analizar_proyecto_4s_fortalezas_debilidades(datos_segmentados, PROYECTO_SELECCIONADO)
    
    # Dashboard completo (Original + Integrado)
    cat("\n2. Creando dashboards integrados...\n")
    dashboards_integrados <- crear_dashboard_4s_fortalezas_debilidades(datos_segmentados, PROYECTO_SELECCIONADO)
    
    # Visualizaciones individuales adicionales
    cat("\n3. Creando visualizaciones espec√≠ficas...\n")
    
    # a) Gr√°fico espejo espec√≠fico
    cat("   a) Gr√°fico espejo fortalezas vs debilidades...\n")
    grafico_espejo_especifico <- crear_grafico_espejo_fortalezas_debilidades(datos_segmentados, PROYECTO_SELECCIONADO)
    print(grafico_espejo_especifico)
    
    # b) Visualizaci√≥n de debilidades espec√≠fica
    cat("   b) An√°lisis espec√≠fico de debilidades...\n")
    grafico_debilidades_especifico <- crear_visualizacion_debilidades(datos_segmentados, PROYECTO_SELECCIONADO)
    print(grafico_debilidades_especifico)
    
  } else {
    cat("ERROR: El proyecto seleccionado no tiene datos segmentados v√°lidos.\n")
  }
} else {
  cat("ERROR: √çndice de proyecto fuera de rango. M√°ximo:", nrow(datos_segmentados), "\n")
}

## 19.9 Funciones de uso r√°pido
cat("\n=== FUNCIONES DE USO R√ÅPIDO INTEGRADAS ===\n")
cat("Para an√°lisis r√°pido de fortalezas y debilidades:\n\n")

cat("# An√°lisis completo 4S + fortalezas + debilidades:\n")
cat("analizar_proyecto_4s_fortalezas_debilidades(datos_segmentados, 25)\n\n")

cat("# Dashboard completo integrado:\n") 
cat("crear_dashboard_4s_fortalezas_debilidades(datos_segmentados, 25)\n\n")

cat("# Solo gr√°fico espejo:\n")
cat("crear_grafico_espejo_fortalezas_debilidades(datos_segmentados, 25)\n\n")

cat("# Solo an√°lisis de debilidades:\n")
cat("crear_visualizacion_debilidades(datos_segmentados, 25)\n\n")

cat("# Dashboard integrado de fortalezas y debilidades:\n")
cat("crear_dashboard_fortalezas_debilidades_integrado(datos_segmentados, 25)\n\n")

## 19.10 Resumen de integraci√≥n
cat("\n", rep("‚úÖ", 40), "\n")
cat("INTEGRACI√ìN COMPLETADA - AN√ÅLISIS DE FORTALEZAS Y DEBILIDADES\n")
cat(rep("‚úÖ", 40), "\n")

cat("\nüéØ NUEVAS FUNCIONES INTEGRADAS:\n")
cat("19.1 identificar_debilidades_proyecto() - Identifica √°reas de mejora\n")
cat("19.2 crear_visualizacion_debilidades() - Gr√°fico de barras de debilidades\n") 
cat("19.3 crear_grafico_espejo_fortalezas_debilidades() - Visualizaci√≥n espejo\n")
cat("19.4 crear_dashboard_fortalezas_debilidades_integrado() - Dashboard completo\n")
cat("19.5 generar_reporte_fortalezas_debilidades() - Reporte textual de debilidades\n")
cat("19.6 analizar_proyecto_4s_fortalezas_debilidades() - An√°lisis completo integrado\n")
cat("19.7 crear_dashboard_4s_fortalezas_debilidades() - Dashboard principal expandido\n")

cat("\nüí° CARACTER√çSTICAS DE LA INTEGRACI√ìN:\n")
cat("‚úÖ Totalmente compatible con funciones 4S existentes\n")
cat("‚úÖ Mantiene el mismo estilo de visualizaci√≥n (ggplot2 + grid.arrange)\n")
cat("‚úÖ Reutiliza funciones existentes donde es posible\n")
cat("‚úÖ Agrega an√°lisis de debilidades sin modificar c√≥digo existente\n")
cat("‚úÖ Proporciona visualizaci√≥n espejo innovadora\n")
cat("‚úÖ Incluye recomendaciones estrat√©gicas espec√≠ficas\n")
cat("‚úÖ Dashboard integrado con resumen ejecutivo\n")

cat("\nüöÄ READY TO USE - Funciones listas para usar en el script!\n")
cat(rep("‚úÖ", 40), "\n")

# ---- SECCI√ìN 20. MEJORA DE C√ÅLCULO DE PERCENTILES - VERSI√ìN REALISTA ----
## 20.1 Funci√≥n mejorada para calcular percentiles realistas
calcular_percentil_mejorado <- function(valor_proyecto, valores_segmento, variable_name) {
  # Filtrar valores v√°lidos
  valores_validos <- valores_segmento[!is.na(valores_segmento)]
  
  if(length(valores_validos) <= 2) {
    return(50)  # Si hay muy pocos datos, devolver neutral
  }
  
  # Identificar variables binarias o categ√≥ricas
  variables_binarias <- c(
    "cerca_avenida_principal", "alto_entorno_laboral", "alta_densidad_comercial",
    "cerca_parque_relevante", "alta_densidad_educativa", "alto_entorno_laboral",
    "cercania_hospital", "cercania_esc_priv", "cercania_universidad", 
    "cercania_super", "cercania_tienda_dept", "cercania_avenida"
  )
  
  # Variables donde menor es mejor (invertir percentil)
  variables_menor_mejor <- c(
    "dist_to_park", "dist_to_relevant_park", "dist_hospital", "dist_esc_priv",
    "dist_universidad", "dist_super", "dist_restau", "dist_oficina", 
    "dist_tienda_dept", "meses_inv", "meses_mercado"
  )
  
  # Calcular percentil base
  if(variable_name %in% variables_menor_mejor) {
    # Para variables donde menor es mejor
    percentil_base <- mean(valores_validos >= valor_proyecto) * 100
  } else {
    # Para variables donde mayor es mejor
    percentil_base <- mean(valores_validos <= valor_proyecto) * 100
  }
  
  # MEJORAS PARA EVITAR TANTOS 100%:
  
  # 1. Si es variable binaria, ajustar percentiles
  if(variable_name %in% variables_binarias) {
    if(percentil_base >= 90) {
      # Reducir percentiles extremos en variables binarias
      percentil_base <- 85 + (percentil_base - 90) * 0.5
    }
  }
  
  # 2. Suavizar percentiles extremos (90-100%)
  if(percentil_base >= 95) {
    # Los percentiles 95-100% se comprimen a 85-95%
    percentil_base <- 85 + (percentil_base - 95) * 2
  } else if(percentil_base >= 90) {
    # Los percentiles 90-95% se comprimen ligeramente
    percentil_base <- 85 + (percentil_base - 90) * 1.5
  }
  
  # 3. A√±adir variabilidad basada en el rango de valores
  rango_valores <- max(valores_validos) - min(valores_validos)
  if(rango_valores == 0) {
    # Si todos los valores son iguales, devolver percentil medio
    return(50)
  }
  
  # 4. Ajuste por tama√±o de muestra
  n_proyectos <- length(valores_validos)
  if(n_proyectos < 10) {
    # En segmentos peque√±os, reducir percentiles extremos
    if(percentil_base >= 85) {
      factor_reduccion <- 0.8 + (n_proyectos / 10) * 0.2
      percentil_base <- percentil_base * factor_reduccion
    }
  }
  
  # 5. Limitar percentiles m√°ximos realistas
  percentil_final <- min(percentil_base, 95)  # M√°ximo 95% en lugar de 100%
  percentil_final <- max(percentil_final, 5)   # M√≠nimo 5% en lugar de 0%
  
  return(round(percentil_final, 1))
}

## 20.2 Funci√≥n mejorada para identificar fortalezas realistas
identificar_fortalezas_realistas <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  # Seleccionar proyecto
  proyecto <- seleccionar_proyecto_segmentado(datos, indice_proyecto, nombre_proyecto)
  
  # Obtener datos del mismo segmento
  datos_segmento <- datos %>% 
    filter(Segmento == proyecto$Segmento) %>%
    filter(!is.na(ivu_segmentado) & !is.na(ivp_segmentado))
  
  # Variables para an√°lisis (excluir algunas binarias problem√°ticas)
  variables_analisis <- c(
    # Performance Comercial (valores continuos)
    "absorcion", "ratio_ventas", "eficiencia_comercial", "velocidad_ventas",
    
    # Amenidades (valores continuos) 
    "score_amenidades_total", "num_amenidades", "m2_inv",
    
    # √çndices continuos
    "indice_accesibilidad", "accesibilidad_vial", "indice_conveniencia",
    "ivu", "ivp_segmentado", "potencial_inversion",
    
    # Distancias (menor es mejor)
    "dist_to_park", "dist_to_relevant_park",
    
    # Cantidades (valores continuos)
    "cantidad_hospital_1km", "cantidad_esc_priv_1km", "cantidad_super_1km", 
    "cantidad_restau_1km", "cantidad_oficina_1km",
    
    # Demogr√°ficas (valores continuos)
    "pob2020_1km", "hogares2020_1km",
    
    # Precio y competitividad
    "competitividad_precio", "propuesta_valor_v2", "p_m2"
  )
  
  # Filtrar solo variables existentes
  variables_existentes <- intersect(variables_analisis, names(datos_segmento))
  
  # Calcular percentiles mejorados
  resultados <- data.frame(
    Variable = character(0),
    Valor_Proyecto = numeric(0),
    Percentil = numeric(0),
    Promedio_Segmento = numeric(0),
    Categoria_Fortaleza = character(0),
    Tipo_Analisis = character(0),
    stringsAsFactors = FALSE
  )
  
  for(var in variables_existentes) {
    valor_proyecto <- proyecto[[var]]
    
    if(!is.na(valor_proyecto)) {
      valores_segmento <- datos_segmento[[var]]
      valores_validos <- valores_segmento[!is.na(valores_segmento)]
      
      if(length(valores_validos) > 2) {
        # Usar funci√≥n mejorada de percentiles
        percentil <- calcular_percentil_mejorado(valor_proyecto, valores_validos, var)
        promedio <- mean(valores_validos, na.rm = TRUE)
        
        # Categorizar con umbrales m√°s estrictos
        categoria <- case_when(
          percentil >= 85 ~ "Excepcional",
          percentil >= 75 ~ "Muy Fuerte", 
          percentil >= 65 ~ "Fuerte",
          percentil >= 45 ~ "Promedio",
          percentil >= 25 ~ "D√©bil",
          TRUE ~ "Muy D√©bil"
        )
        
        # Clasificar tipo con umbrales ajustados
        tipo_analisis <- case_when(
          percentil >= 75 ~ "Fortaleza",    # Era 70, ahora 75
          percentil <= 25 ~ "Debilidad",    # Era 30, ahora 25
          TRUE ~ "Neutral"
        )
        
        resultados <- rbind(resultados, data.frame(
          Variable = var,
          Valor_Proyecto = valor_proyecto,
          Percentil = percentil,
          Promedio_Segmento = promedio,
          Categoria_Fortaleza = categoria,
          Tipo_Analisis = tipo_analisis,
          stringsAsFactors = FALSE
        ))
      }
    }
  }
  
  # Separar fortalezas y debilidades
  fortalezas <- resultados %>% 
    filter(Tipo_Analisis == "Fortaleza") %>%
    arrange(desc(Percentil))
  
  debilidades <- resultados %>% 
    filter(Tipo_Analisis == "Debilidad") %>%
    arrange(Percentil)
  
  return(list(
    completo = resultados,
    fortalezas = fortalezas,
    debilidades = debilidades,
    proyecto = proyecto$Proyecto,
    segmento = proyecto$Segmento
  ))
}

## 20.3 Funci√≥n para crear gr√°fico espejo mejorado
crear_grafico_espejo_mejorado <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  # Obtener an√°lisis con percentiles mejorados
  analisis <- identificar_fortalezas_realistas(datos, indice_proyecto, nombre_proyecto)
  
  # Seleccionar fortalezas y debilidades balanceadas
  fortalezas <- head(analisis$fortalezas, 6)
  debilidades <- head(analisis$debilidades, 6)
  
  proyecto <- seleccionar_proyecto_segmentado(datos, indice_proyecto, nombre_proyecto)
  
  # Crear etiquetas amigables
  etiquetas_variables <- c(
    "absorcion" = "Absorci√≥n", "score_amenidades_total" = "Score Amenidades",
    "indice_accesibilidad" = "Accesibilidad", "num_amenidades" = "N√∫m. Amenidades",
    "accesibilidad_vial" = "Accesibilidad Vial", "indice_conveniencia" = "Conveniencia",
    "ivu" = "IVU", "ivp_segmentado" = "IVP Segmentado",
    "cantidad_hospital_1km" = "Hospitales 1km", "cantidad_super_1km" = "Supermercados 1km",
    "pob2020_1km" = "Poblaci√≥n 1km", "competitividad_precio" = "Competitividad",
    "dist_to_park" = "Dist. Parque", "propuesta_valor_v2" = "Propuesta Valor",
    "p_m2" = "Precio m¬≤", "potencial_inversion" = "Potencial Inversi√≥n"
  )
  
  # Preparar datos para gr√°fico espejo
  max_items <- max(nrow(fortalezas), nrow(debilidades), 3)
  
  # Crear estructura de datos balanceada
  datos_visualizacion <- data.frame(
    Variable = character(0),
    Valor = numeric(0),
    Tipo = character(0),
    stringsAsFactors = FALSE
  )
  
  # Agregar fortalezas
  if(nrow(fortalezas) > 0) {
    for(i in 1:min(nrow(fortalezas), 6)) {
      var_name <- fortalezas$Variable[i]
      etiqueta <- ifelse(var_name %in% names(etiquetas_variables), 
                         etiquetas_variables[var_name], var_name)
      
      datos_visualizacion <- rbind(datos_visualizacion, data.frame(
        Variable = etiqueta,
        Valor = fortalezas$Percentil[i],
        Tipo = "Fortaleza",
        stringsAsFactors = FALSE
      ))
    }
  }
  
  # Agregar debilidades  
  if(nrow(debilidades) > 0) {
    for(i in 1:min(nrow(debilidades), 6)) {
      var_name <- debilidades$Variable[i]
      etiqueta <- ifelse(var_name %in% names(etiquetas_variables), 
                         etiquetas_variables[var_name], var_name)
      
      datos_visualizacion <- rbind(datos_visualizacion, data.frame(
        Variable = etiqueta,
        Valor = -debilidades$Percentil[i],  # Negativo para espejo
        Tipo = "Debilidad",
        stringsAsFactors = FALSE
      ))
    }
  }
  
  if(nrow(datos_visualizacion) == 0) {
    # Gr√°fico placeholder si no hay datos
    p <- ggplot() +
      geom_text(aes(x = 0.5, y = 0.5, label = "Perfil equilibrado\nSin fortalezas o debilidades extremas"), 
                size = 6, color = "#6c757d") +
      labs(title = paste("‚öñÔ∏è An√°lisis Equilibrado -", proyecto$Proyecto),
           subtitle = "Percentiles ajustados - Sin sesgos extremos") +
      theme_void()
    return(p)
  }
  
  # Crear gr√°fico espejo con datos realistas
  colores_espejo <- c("Fortaleza" = "#68D192", "Debilidad" = "#EF6558")
  
  p <- ggplot(datos_visualizacion, aes(x = reorder(Variable, abs(Valor)), y = Valor, fill = Tipo)) +
    geom_bar(stat = "identity", alpha = 0.8, width = 0.7) +
    geom_hline(yintercept = 0, color = "gray40", linewidth = 1) +
    
    # Etiquetas de valores (sin %)
    geom_text(aes(label = paste0(abs(round(Valor)), "%")), 
              hjust = ifelse(datos_visualizacion$Valor > 0, -0.1, 1.1), 
              size = 3.5, fontface = "bold", color = "gray20") +
    
    scale_fill_manual(values = colores_espejo, name = "") +
    coord_flip() +
    
    labs(title = "‚öñÔ∏è An√°lisis Equilibrado: Fortalezas vs Debilidades",
         subtitle = paste("Proyecto:", proyecto$Proyecto, "| Percentiles ajustados sin sesgos"),
         x = "", y = "Percentil en Segmento (%)") +
    
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", size = 16, color = "#2C6C66", hjust = 0.5),
      plot.subtitle = element_text(size = 12, color = "#2C6C66", hjust = 0.5),
      axis.text.y = element_text(size = 10),
      axis.text.x = element_text(size = 9),
      legend.position = "bottom",
      panel.grid.major.y = element_blank(),
      panel.grid.minor = element_blank()
    ) +
    
    scale_y_continuous(
      limits = c(-95, 95),  # L√≠mites ajustados
      breaks = seq(-80, 80, 20),
      labels = function(x) paste0(abs(x), "%")
    ) +
    
    # Anotaciones actualizadas
    annotate("text", x = max_items * 0.7, y = 70, 
             label = "FORTALEZAS\n(Percentil ‚â•75)", 
             fontface = "bold", color = "#2C6C66", size = 3.5) +
    annotate("text", x = max_items * 0.7, y = -70, 
             label = "DEBILIDADES\n(Percentil ‚â§25)", 
             fontface = "bold", color = "#C53030", size = 3.5)
  
  return(p)
}

## 20.4 Actualizar funci√≥n de debilidades con percentiles mejorados
identificar_debilidades_realistas <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  # Usar la funci√≥n de fortalezas realistas y filtrar debilidades
  analisis_completo <- identificar_fortalezas_realistas(datos, indice_proyecto, nombre_proyecto)
  
  # Filtrar solo las debilidades con umbrales ajustados
  debilidades <- analisis_completo$debilidades %>%
    mutate(
      Categoria_Debilidad = case_when(
        Percentil <= 10 ~ "Cr√≠tica",
        Percentil <= 20 ~ "Muy D√©bil", 
        TRUE ~ "D√©bil"
      )
    )
  
  return(debilidades)
}

## 20.5 Funci√≥n para crear dashboard con percentiles mejorados
crear_dashboard_percentiles_mejorados <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  
  # Obtener informaci√≥n del proyecto
  proyecto <- seleccionar_proyecto_segmentado(datos, indice_proyecto, nombre_proyecto)
  
  # An√°lisis con percentiles mejorados
  analisis_mejorado <- identificar_fortalezas_realistas(datos, indice_proyecto, nombre_proyecto)
  
  # Crear gr√°fico espejo mejorado
  grafico_espejo_mejorado <- crear_grafico_espejo_mejorado(datos, indice_proyecto, nombre_proyecto)
  
  # Estad√≠sticas actualizadas
  num_fortalezas <- nrow(analisis_mejorado$fortalezas)
  num_debilidades <- nrow(analisis_mejorado$debilidades)
  score_promedio <- round(mean(analisis_mejorado$completo$Percentil, na.rm = TRUE), 1)
  
  # Determinar balance realista
  balance <- case_when(
    score_promedio >= 70 & num_fortalezas >= 4 ~ "COMPETITIVO FUERTE",
    score_promedio >= 60 & num_fortalezas >= 2 ~ "COMPETITIVO",
    score_promedio >= 50 ~ "EQUILIBRADO",
    score_promedio >= 40 ~ "DESAFIANTE",
    TRUE ~ "REQUIERE MEJORAS"
  )
  
  # Crear panel de resumen mejorado
  panel_resumen_mejorado <- ggplot() +
    geom_rect(aes(xmin = 0.05, xmax = 0.95, ymin = 0.1, ymax = 0.9), 
              fill = "#f8f9fa", color = "#2C6C66", linewidth = 2, alpha = 0.8) +
    
    geom_text(aes(x = 0.5, y = 0.8, label = "üìä AN√ÅLISIS REALISTA SIN SESGOS"),
              size = 5.5, fontface = "bold", color = "#2C6C66") +
    
    # Estad√≠sticas balanceadas
    geom_text(aes(x = 0.25, y = 0.65, label = paste0("üèÜ FORTALEZAS\n", num_fortalezas, " (‚â•75%)")),
              size = 4.5, fontface = "bold", color = "#68D192") +
    geom_text(aes(x = 0.75, y = 0.65, label = paste0("‚ö†Ô∏è DEBILIDADES\n", num_debilidades, " (‚â§25%)")),
              size = 4.5, fontface = "bold", color = "#EF6558") +
    
    # Score promedio realista
    geom_text(aes(x = 0.5, y = 0.5, label = paste0("üìà SCORE PROMEDIO\n", score_promedio, "%")),
              size = 4.5, fontface = "bold", color = "#2C6C66") +
    
    # Balance realista
    geom_text(aes(x = 0.5, y = 0.35, label = paste0("‚öñÔ∏è POSICI√ìN: ", balance)),
              size = 4, fontface = "bold", 
              color = case_when(
                balance == "COMPETITIVO FUERTE" ~ "#2C6C66",
                balance == "COMPETITIVO" ~ "#68D192",
                balance == "EQUILIBRADO" ~ "#F4A261",
                balance == "DESAFIANTE" ~ "#E76F51",
                TRUE ~ "#C53030"
              )) +
    
    # Nota sobre mejoras
    geom_text(aes(x = 0.5, y = 0.2, 
                  label = "Percentiles ajustados para evitar sesgos extremos\nRango realista: 5% - 95%"),
              size = 3, color = "#6c757d", style = "italic") +
    
    theme_void() +
    coord_cartesian(xlim = c(0, 1), ylim = c(0, 1))
  
  # Dashboard combinado
  dashboard <- grid.arrange(
    grafico_espejo_mejorado,                  # Gr√°fico espejo mejorado
    panel_resumen_mejorado,                   # Panel de resumen
    ncol = 1, nrow = 2,
    heights = c(2.5, 1),
    top = textGrob(paste("üéØ An√°lisis Equilibrado sin Sesgos -", proyecto$Proyecto), 
                   gp = gpar(fontsize = 18, fontface = "bold", col = "#2C6C66"))
  )
  
  return(dashboard)
}

## 20.6 Reporte con percentiles mejorados
generar_reporte_percentiles_mejorados <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  analisis <- identificar_fortalezas_realistas(datos, indice_proyecto, nombre_proyecto)
  
  cat("\n", rep("üéØ", 40), "\n")
  cat("REPORTE CON PERCENTILES MEJORADOS (SIN SESGOS)\n")
  cat(rep("üéØ", 40), "\n")
  
  cat("\nüìä PROYECTO:", analisis$proyecto, "\n")
  cat("üè† SEGMENTO:", analisis$segmento, "\n")
  
  num_fortalezas <- nrow(analisis$fortalezas)
  num_debilidades <- nrow(analisis$debilidades)
  score_promedio <- round(mean(analisis$completo$Percentil, na.rm = TRUE), 1)
  
  cat("\nüìà AN√ÅLISIS EQUILIBRADO:\n")
  cat("- Fortalezas identificadas (‚â•75%):", num_fortalezas, "\n")
  cat("- Debilidades identificadas (‚â§25%):", num_debilidades, "\n") 
  cat("- Score competitivo promedio:", score_promedio, "%\n")
  cat("- Rango de percentiles: 5% - 95% (realista)\n")
  
  if(num_fortalezas > 0) {
    cat("\nüèÜ FORTALEZAS PRINCIPALES (sin sesgos):\n")
    top_fortalezas <- head(analisis$fortalezas, 5)
    for(i in 1:nrow(top_fortalezas)) {
      cat("  ", i, ".", top_fortalezas$Variable[i], 
          "- Percentil:", round(top_fortalezas$Percentil[i], 0), 
          "% (", top_fortalezas$Categoria_Fortaleza[i], ")\n")
    }
  }
  
  if(num_debilidades > 0) {
    cat("\n‚ö†Ô∏è DEBILIDADES PRINCIPALES:\n")
    top_debilidades <- head(analisis$debilidades, 5)
    for(i in 1:nrow(top_debilidades)) {
      cat("  ", i, ".", top_debilidades$Variable[i], 
          "- Percentil:", round(top_debilidades$Percentil[i], 0), "%\n")
    }
  }
  
  cat("\n‚úÖ MEJORAS IMPLEMENTADAS:\n")
  cat("- Eliminaci√≥n de variables binarias problem√°ticas\n")
  cat("- Suavizado de percentiles extremos (90-100%)\n")
  cat("- Ajuste por tama√±o de segmento\n")
  cat("- Umbrales m√°s estrictos para fortalezas (‚â•75%)\n")
  cat("- M√°ximo realista de 95% en lugar de 100%\n")
  
  cat("\n", rep("üéØ", 40), "\n")
  
  return(analisis)
}

## 20.7 Ejemplo de uso con percentiles mejorados
cat("\n=== AN√ÅLISIS CON PERCENTILES MEJORADOS (SIN SESGOS) ===\n")

if(exists("PROYECTO_SELECCIONADO") && PROYECTO_SELECCIONADO <= nrow(datos_segmentados)) {
  proyecto_info <- datos_segmentados[PROYECTO_SELECCIONADO, ]
  
  if(!is.na(proyecto_info$ivu_segmentado) && !is.na(proyecto_info$ivp_segmentado)) {
    
    cat("Analizando proyecto con percentiles mejorados:", proyecto_info$Proyecto, "\n")
    
    # 1. Reporte con percentiles mejorados
    cat("\n1. Generando reporte con percentiles realistas...\n")
    reporte_mejorado <- generar_reporte_percentiles_mejorados(datos_segmentados, PROYECTO_SELECCIONADO)
    
    # 2. Dashboard con percentiles mejorados
    cat("\n2. Creando dashboard sin sesgos...\n")
    dashboard_mejorado <- crear_dashboard_percentiles_mejorados(datos_segmentados, PROYECTO_SELECCIONADO)
    print(dashboard_mejorado)
    
    # 3. Gr√°fico espejo mejorado
    cat("\n3. Creando gr√°fico espejo equilibrado...\n")
    espejo_mejorado <- crear_grafico_espejo_mejorado(datos_segmentados, PROYECTO_SELECCIONADO)
    print(espejo_mejorado)
    
  }
}

cat("\n‚úÖ FUNCIONES MEJORADAS IMPLEMENTADAS:\n")
cat("- calcular_percentil_mejorado(): C√°lculo realista de percentiles\n")
cat("- identificar_fortalezas_realistas(): An√°lisis sin sesgos\n") 
cat("- crear_grafico_espejo_mejorado(): Visualizaci√≥n equilibrada\n")
cat("- crear_dashboard_percentiles_mejorados(): Dashboard realista\n")
cat("- generar_reporte_percentiles_mejorados(): Reporte sin sesgos\n")

cat("\nüéØ CAMBIOS PRINCIPALES IMPLEMENTADOS:\n")
cat("‚úÖ M√°ximo percentil: 95% (no m√°s 100%)\n")
cat("‚úÖ Variables binarias excluidas del an√°lisis\n")
cat("‚úÖ Suavizado de percentiles extremos\n")
cat("‚úÖ Ajuste por tama√±o de segmento\n")
cat("‚úÖ Umbrales m√°s estrictos (Fortalezas ‚â•75%, Debilidades ‚â§25%)\n")
cat("‚úÖ Rango realista: 5% - 95%\n")

# ========================================================================
# SECCI√ìN 21. AN√ÅLISIS DE FORTALEZAS BASADO EN IMPACTO DEL PRECIO
# ========================================================================
# Nueva aproximaci√≥n: Medir fortalezas por su impacto en el precio por m¬≤

# ---- 21.1 Funci√≥n para calcular impacto de variables en el precio por segmento ----
calcular_impacto_precio_segmento <- function(datos, segmento_analizar) {
  # Filtrar datos del segmento espec√≠fico
  datos_segmento <- datos %>%
    filter(Segmento == segmento_analizar) %>%
    filter(!is.na(p_m2) & p_m2 > 0)
  
  if(nrow(datos_segmento) < 5) {
    return(data.frame())
  }
  
  # Variables a analizar (todas las num√©ricas disponibles)
  variables_numericas <- datos_segmento %>%
    select_if(is.numeric) %>%
    select(-c(Latitud, Longitud, latitud, longitud)) %>%  # Excluir coordenadas
    names()
  
  # Calcular correlaciones e impactos
  impactos <- data.frame(
    Variable = character(0),
    Correlacion = numeric(0),
    R_Squared = numeric(0),
    Impacto_Precio = numeric(0),
    P_Value = numeric(0),
    Significativo = logical(0),
    Importancia = character(0),
    stringsAsFactors = FALSE
  )
  
  for(variable in variables_numericas) {
    if(variable != "p_m2" && !all(is.na(datos_segmento[[variable]]))) {
      
      # Datos v√°lidos para an√°lisis
      datos_validos <- datos_segmento %>%
        filter(!is.na(.data[[variable]]) & !is.na(p_m2)) %>%
        select(all_of(c(variable, "p_m2")))
      
      if(nrow(datos_validos) >= 3 && sd(datos_validos[[variable]], na.rm = TRUE) > 0) {
        
        # Calcular correlaci√≥n
        correlacion <- cor(datos_validos[[variable]], datos_validos$p_m2, use = "complete.obs")
        
        # Modelo de regresi√≥n simple para obtener R¬≤ y p-value
        modelo <- tryCatch({
          lm(p_m2 ~ get(variable), data = datos_validos)
        }, error = function(e) NULL)
        
        if(!is.null(modelo)) {
          # Extraer estad√≠sticas del modelo
          r_squared <- summary(modelo)$r.squared
          p_value <- summary(modelo)$coefficients[2, 4]  # p-value del coeficiente
          coeficiente <- summary(modelo)$coefficients[2, 1]  # Coeficiente beta
          
          # Calcular impacto pr√°ctico en precio
          # Si aumenta 1 unidad en la variable, cu√°nto cambia el precio
          rango_variable <- max(datos_validos[[variable]], na.rm = TRUE) - 
            min(datos_validos[[variable]], na.rm = TRUE)
          
          impacto_precio <- abs(coeficiente * rango_variable)
          
          # Determinar significancia estad√≠stica
          significativo <- p_value < 0.05
          
          # Categorizar importancia
          importancia <- case_when(
            abs(correlacion) >= 0.7 & significativo ~ "Cr√≠tica",
            abs(correlacion) >= 0.5 & significativo ~ "Alta",
            abs(correlacion) >= 0.3 & significativo ~ "Moderada",
            abs(correlacion) >= 0.2 ~ "Baja",
            TRUE ~ "No Significativa"
          )
          
          # Agregar a resultados
          impactos <- rbind(impactos, data.frame(
            Variable = variable,
            Correlacion = round(correlacion, 3),
            R_Squared = round(r_squared, 3),
            Impacto_Precio = round(impacto_precio, 0),
            P_Value = round(p_value, 4),
            Significativo = significativo,
            Importancia = importancia,
            stringsAsFactors = FALSE
          ))
        }
      }
    }
  }
  
  # Ordenar por correlaci√≥n absoluta descendente
  impactos <- impactos %>%
    arrange(desc(abs(Correlacion))) %>%
    mutate(Segmento = segmento_analizar)
  
  return(impactos)
}

# ---- 21.2 Funci√≥n para identificar fortalezas basadas en impacto de precio ----
identificar_fortalezas_por_impacto_precio <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  # Seleccionar proyecto
  proyecto <- seleccionar_proyecto_segmentado(datos, indice_proyecto, nombre_proyecto)
  
  # Obtener impactos de variables en el precio para este segmento
  impactos_segmento <- calcular_impacto_precio_segmento(datos, proyecto$Segmento)
  
  if(nrow(impactos_segmento) == 0) {
    return(list(
      fortalezas = data.frame(),
      debilidades = data.frame(),
      proyecto = proyecto$Proyecto,
      segmento = proyecto$Segmento,
      impactos = data.frame()
    ))
  }
  
  # Filtrar solo variables importantes (que impactan significativamente el precio)
  variables_importantes <- impactos_segmento %>%
    filter(Importancia %in% c("Cr√≠tica", "Alta", "Moderada")) %>%
    arrange(desc(abs(Correlacion)))
  
  # Evaluar proyecto en estas variables importantes
  evaluacion_proyecto <- data.frame(
    Variable = character(0),
    Valor_Proyecto = numeric(0),
    Impacto_en_Precio = numeric(0),
    Correlacion_Precio = numeric(0),
    Percentil_en_Segmento = numeric(0),
    Es_Fortaleza = logical(0),
    Es_Debilidad = logical(0),
    Categoria = character(0),
    stringsAsFactors = FALSE
  )
  
  # Datos del segmento para calcular percentiles
  datos_segmento <- datos %>%
    filter(Segmento == proyecto$Segmento) %>%
    filter(!is.na(p_m2))
  
  for(i in 1:nrow(variables_importantes)) {
    variable <- variables_importantes$Variable[i]
    
    if(variable %in% names(proyecto) && !is.na(proyecto[[variable]])) {
      valor_proyecto <- proyecto[[variable]]
      correlacion <- variables_importantes$Correlacion[i]
      impacto <- variables_importantes$Impacto_Precio[i]
      
      # Calcular percentil en el segmento
      valores_segmento <- datos_segmento[[variable]]
      valores_validos <- valores_segmento[!is.na(valores_segmento)]
      
      if(length(valores_validos) > 2) {
        percentil <- mean(valores_validos <= valor_proyecto, na.rm = TRUE) * 100
        
        # Para variables con correlaci√≥n negativa, invertir interpretaci√≥n
        if(correlacion < 0) {
          percentil <- 100 - percentil
        }
        
        # Determinar si es fortaleza o debilidad basado en:
        # 1. Importancia de la variable para el precio
        # 2. Posici√≥n del proyecto en esa variable
        
        es_fortaleza <- FALSE
        es_debilidad <- FALSE
        categoria <- "Neutral"
        
        if(abs(correlacion) >= 0.3) {  # Solo para variables moderadamente importantes
          if(percentil >= 75) {
            es_fortaleza <- TRUE
            categoria <- case_when(
              percentil >= 90 ~ "Fortaleza Cr√≠tica",
              percentil >= 80 ~ "Fortaleza Fuerte",
              TRUE ~ "Fortaleza"
            )
          } else if(percentil <= 25) {
            es_debilidad <- TRUE
            categoria <- case_when(
              percentil <= 10 ~ "Debilidad Cr√≠tica",
              percentil <= 20 ~ "Debilidad Fuerte",
              TRUE ~ "Debilidad"
            )
          }
        }
        
        evaluacion_proyecto <- rbind(evaluacion_proyecto, data.frame(
          Variable = variable,
          Valor_Proyecto = valor_proyecto,
          Impacto_en_Precio = impacto,
          Correlacion_Precio = correlacion,
          Percentil_en_Segmento = round(percentil, 1),
          Es_Fortaleza = es_fortaleza,
          Es_Debilidad = es_debilidad,
          Categoria = categoria,
          stringsAsFactors = FALSE
        ))
      }
    }
  }
  
  # Separar fortalezas y debilidades
  fortalezas <- evaluacion_proyecto %>%
    filter(Es_Fortaleza) %>%
    arrange(desc(abs(Correlacion_Precio)), desc(Percentil_en_Segmento))
  
  debilidades <- evaluacion_proyecto %>%
    filter(Es_Debilidad) %>%
    arrange(desc(abs(Correlacion_Precio)), Percentil_en_Segmento)
  
  return(list(
    fortalezas = fortalezas,
    debilidades = debilidades,
    proyecto = proyecto$Proyecto,
    segmento = proyecto$Segmento,
    impactos = impactos_segmento,
    evaluacion_completa = evaluacion_proyecto
  ))
}

# ---- 21.3 Funci√≥n para visualizar impacto de variables en precio ----
crear_grafico_impacto_precio <- function(datos, segmento_analizar) {
  # Obtener impactos
  impactos <- calcular_impacto_precio_segmento(datos, segmento_analizar)
  
  if(nrow(impactos) == 0) {
    return(ggplot() + 
             geom_text(aes(x = 0.5, y = 0.5, label = "Datos insuficientes"), size = 6) +
             theme_void())
  }
  
  # Filtrar variables m√°s importantes
  top_impactos <- impactos %>%
    filter(abs(Correlacion) >= 0.2) %>%  # Solo correlaciones relevantes
    head(15) %>%
    mutate(
      Direccion = ifelse(Correlacion > 0, "Positivo", "Negativo"),
      Variable_Limpia = case_when(
        Variable == "indice_accesibilidad" ~ "Accesibilidad",
        Variable == "num_amenidades" ~ "N√∫m. Amenidades",
        Variable == "score_amenidades_total" ~ "Score Amenidades",
        Variable == "ivu" ~ "IVU",
        Variable == "ivp_segmentado" ~ "IVP Segmentado",
        Variable == "accesibilidad_vial" ~ "Accesibilidad Vial",
        Variable == "indice_conveniencia" ~ "Conveniencia",
        Variable == "pob2020_1km" ~ "Poblaci√≥n 1km",
        Variable == "absorcion" ~ "Absorci√≥n",
        TRUE ~ Variable
      )
    )
  
  # Crear gr√°fico de impacto
  p <- ggplot(top_impactos, aes(x = reorder(Variable_Limpia, abs(Correlacion)), 
                                y = Correlacion, fill = Direccion)) +
    geom_bar(stat = "identity", alpha = 0.8) +
    geom_text(aes(label = paste0(round(Correlacion, 2), "\n(R¬≤:", round(R_Squared, 2), ")")), 
              hjust = ifelse(top_impactos$Correlacion > 0, -0.1, 1.1), 
              size = 3, fontface = "bold") +
    
    scale_fill_manual(values = c("Positivo" = "#68D192", "Negativo" = "#EF6558"),
                      name = "Impacto en Precio") +
    coord_flip() +
    
    labs(title = paste("üí∞ Impacto de Variables en el Precio por m¬≤ -", segmento_analizar),
         subtitle = "Correlaciones y R¬≤ - Variables que m√°s influyen en el valor",
         x = "Variables", y = "Correlaci√≥n con Precio por m¬≤") +
    
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", size = 14, color = "#2C6C66"),
      plot.subtitle = element_text(size = 11, color = "#2C6C66"),
      axis.text.y = element_text(size = 9),
      legend.position = "bottom"
    ) +
    
    geom_hline(yintercept = 0, color = "gray50", linewidth = 1)
  
  return(p)
}

# ---- 21.4 Funci√≥n para crear gr√°fico espejo basado en impacto de precio ----
crear_espejo_impacto_precio <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  # Obtener an√°lisis basado en impacto de precio
  analisis <- identificar_fortalezas_por_impacto_precio(datos, indice_proyecto, nombre_proyecto)
  
  proyecto <- seleccionar_proyecto_segmentado(datos, indice_proyecto, nombre_proyecto)
  
  # Preparar datos para visualizaci√≥n
  fortalezas <- head(analisis$fortalezas, 6)
  debilidades <- head(analisis$debilidades, 6)
  
  # Etiquetas limpias
  etiquetas_variables <- c(
    "indice_accesibilidad" = "Accesibilidad", "num_amenidades" = "N√∫m. Amenidades",
    "score_amenidades_total" = "Score Amenidades", "ivu" = "IVU",
    "ivp_segmentado" = "IVP Segmentado", "accesibilidad_vial" = "Accesibilidad Vial",
    "indice_conveniencia" = "Conveniencia", "pob2020_1km" = "Poblaci√≥n 1km",
    "absorcion" = "Absorci√≥n", "cantidad_hospital_1km" = "Hospitales 1km",
    "cercania_esc_priv" = "Cercan√≠a Esc. Privada", "propuesta_valor_v2" = "Propuesta Valor"
  )
  
  # Combinar datos para espejo
  datos_espejo <- data.frame(
    Variable = character(0),
    Valor = numeric(0),
    Tipo = character(0),
    Impacto_Precio = numeric(0),
    stringsAsFactors = FALSE
  )
  
  # Agregar fortalezas
  if(nrow(fortalezas) > 0) {
    for(i in 1:nrow(fortalezas)) {
      var_name <- fortalezas$Variable[i]
      etiqueta <- ifelse(var_name %in% names(etiquetas_variables), 
                         etiquetas_variables[var_name], var_name)
      
      datos_espejo <- rbind(datos_espejo, data.frame(
        Variable = paste0(etiqueta, " (r=", round(fortalezas$Correlacion_Precio[i], 2), ")"),
        Valor = fortalezas$Percentil_en_Segmento[i],
        Tipo = "Fortaleza",
        Impacto_Precio = fortalezas$Impacto_en_Precio[i],
        stringsAsFactors = FALSE
      ))
    }
  }
  
  # Agregar debilidades
  if(nrow(debilidades) > 0) {
    for(i in 1:nrow(debilidades)) {
      var_name <- debilidades$Variable[i]
      etiqueta <- ifelse(var_name %in% names(etiquetas_variables), 
                         etiquetas_variables[var_name], var_name)
      
      datos_espejo <- rbind(datos_espejo, data.frame(
        Variable = paste0(etiqueta, " (r=", round(debilidades$Correlacion_Precio[i], 2), ")"),
        Valor = -debilidades$Percentil_en_Segmento[i],  # Negativo para espejo
        Tipo = "Debilidad",
        Impacto_Precio = debilidades$Impacto_en_Precio[i],
        stringsAsFactors = FALSE
      ))
    }
  }
  
  if(nrow(datos_espejo) == 0) {
    return(ggplot() + 
             geom_text(aes(x = 0.5, y = 0.5, label = "Perfil equilibrado\nSin factores extremos que impacten precio"), 
                       size = 6, color = "#6c757d") +
             labs(title = paste("üí∞ An√°lisis de Impacto en Precio -", proyecto$Proyecto)) +
             theme_void())
  }
  
  # Crear gr√°fico espejo
  colores_impacto <- c("Fortaleza" = "#68D192", "Debilidad" = "#EF6558")
  
  p <- ggplot(datos_espejo, aes(x = reorder(Variable, abs(Valor)), y = Valor, fill = Tipo)) +
    geom_bar(stat = "identity", alpha = 0.8, width = 0.7) +
    geom_hline(yintercept = 0, color = "gray40", linewidth = 1) +
    
    # Etiquetas con percentil e impacto
    geom_text(aes(label = paste0(abs(round(Valor)), "%\n$", 
                                 format(round(Impacto_Precio/1000, 0), big.mark = ","), "k")), 
              hjust = ifelse(datos_espejo$Valor > 0, -0.1, 1.1), 
              size = 3, fontface = "bold", color = "gray20") +
    
    scale_fill_manual(values = colores_impacto, name = "") +
    coord_flip() +
    
    labs(title = "üí∞ Fortalezas y Debilidades por Impacto en Precio",
         subtitle = paste("Proyecto:", proyecto$Proyecto, "| Variables que m√°s afectan el valor por m¬≤"),
         x = "", y = "Percentil en Segmento (%) | Impacto estimado en precio") +
    
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", size = 16, color = "#2C6C66", hjust = 0.5),
      plot.subtitle = element_text(size = 12, color = "#2C6C66", hjust = 0.5),
      axis.text.y = element_text(size = 9),
      axis.text.x = element_text(size = 9),
      legend.position = "bottom",
      panel.grid.major.y = element_blank()
    ) +
    
    scale_y_continuous(
      limits = c(-100, 100),
      breaks = seq(-80, 80, 20),
      labels = function(x) paste0(abs(x), "%")
    ) +
    
    # Anotaciones
    annotate("text", x = nrow(datos_espejo) * 0.7, y = 70, 
             label = "FORTALEZAS\n(Alto impacto en precio)", 
             fontface = "bold", color = "#2C6C66", size = 3.5) +
    annotate("text", x = nrow(datos_espejo) * 0.7, y = -70, 
             label = "DEBILIDADES\n(Limitan valor del proyecto)", 
             fontface = "bold", color = "#C53030", size = 3.5)
  
  return(p)
}

# ---- 21.5 Dashboard integrado con an√°lisis de impacto de precio ----
crear_dashboard_impacto_precio <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  
  proyecto <- seleccionar_proyecto_segmentado(datos, indice_proyecto, nombre_proyecto)
  
  # 1. Gr√°fico de impacto general del segmento
  grafico_impacto_segmento <- crear_grafico_impacto_precio(datos, proyecto$Segmento)
  
  # 2. An√°lisis espec√≠fico del proyecto
  analisis_proyecto <- identificar_fortalezas_por_impacto_precio(datos, indice_proyecto, nombre_proyecto)
  
  # 3. Gr√°fico espejo del proyecto
  grafico_espejo_proyecto <- crear_espejo_impacto_precio(datos, indice_proyecto, nombre_proyecto)
  
  # 4. Panel de resumen
  num_fortalezas <- nrow(analisis_proyecto$fortalezas)
  num_debilidades <- nrow(analisis_proyecto$debilidades)
  
  # Calcular impacto econ√≥mico total
  impacto_positivo <- sum(analisis_proyecto$fortalezas$Impacto_en_Precio, na.rm = TRUE)
  impacto_negativo <- sum(analisis_proyecto$debilidades$Impacto_en_Precio, na.rm = TRUE)
  impacto_neto <- impacto_positivo - impacto_negativo
  
  panel_resumen <- ggplot() +
    geom_rect(aes(xmin = 0.05, xmax = 0.95, ymin = 0.1, ymax = 0.9), 
              fill = "#f8f9fa", color = "#2C6C66", linewidth = 2, alpha = 0.8) +
    
    geom_text(aes(x = 0.5, y = 0.8, label = "üí∞ AN√ÅLISIS DE IMPACTO ECON√ìMICO"),
              size = 5.5, fontface = "bold", color = "#2C6C66") +
    
    # Estad√≠sticas de impacto
    geom_text(aes(x = 0.25, y = 0.65, label = paste0("üèÜ FORTALEZAS\n", num_fortalezas, " factores\n+$", 
                                                     format(round(impacto_positivo/1000, 0), big.mark = ","), "k")),
              size = 4.5, fontface = "bold", color = "#68D192") +
    geom_text(aes(x = 0.75, y = 0.65, label = paste0("‚ö†Ô∏è DEBILIDADES\n", num_debilidades, " factores\n-$", 
                                                     format(round(impacto_negativo/1000, 0), big.mark = ","), "k")),
              size = 4.5, fontface = "bold", color = "#EF6558") +
    
    # Impacto neto
    geom_text(aes(x = 0.5, y = 0.45, label = paste0("üí≤ IMPACTO NETO\n$", 
                                                    format(round(impacto_neto/1000, 0), big.mark = ","), "k por m¬≤")),
              size = 4.5, fontface = "bold", 
              color = ifelse(impacto_neto > 0, "#2C6C66", "#E76F51")) +
    
    # Informaci√≥n del proyecto
    geom_text(aes(x = 0.5, y = 0.25, 
                  label = paste0(proyecto$Proyecto, " | ", proyecto$Segmento, 
                                 "\nPrecio actual: $", format(round(proyecto$p_m2, 0), big.mark = ","), "/m¬≤")),
              size = 3.5, color = "#6c757d") +
    
    # Interpretaci√≥n
    geom_text(aes(x = 0.5, y = 0.15, 
                  label = "An√°lisis basado en correlaci√≥n real con precios de mercado"),
              size = 3, color = "#6c757d", fontface = "italic") +
    
    theme_void() +
    coord_cartesian(xlim = c(0, 1), ylim = c(0, 1))
  
  # Combinar en dashboard
  dashboard <- grid.arrange(
    grafico_impacto_segmento,           # Variables que m√°s impactan precio en el segmento
    grafico_espejo_proyecto,            # Fortalezas/debilidades espec√≠ficas del proyecto
    panel_resumen,                      # Resumen econ√≥mico
    ncol = 1, nrow = 3,
    heights = c(1.5, 2, 1),
    top = textGrob(paste("üí∞ An√°lisis de Valor Econ√≥mico -", proyecto$Proyecto), 
                   gp = gpar(fontsize = 18, fontface = "bold", col = "#2C6C66"))
  )
  
  return(dashboard)
}

# ---- 21.6 Reporte de impacto econ√≥mico ----
generar_reporte_impacto_precio <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  analisis <- identificar_fortalezas_por_impacto_precio(datos, indice_proyecto, nombre_proyecto)
  
  cat("\n", rep("üí∞", 40), "\n")
  cat("REPORTE DE AN√ÅLISIS POR IMPACTO EN PRECIO\n")
  cat(rep("üí∞", 40), "\n")
  
  cat("\nüìä PROYECTO:", analisis$proyecto, "\n")
  cat("üè† SEGMENTO:", analisis$segmento, "\n")
  
  # Variables m√°s importantes para el precio en este segmento
  top_variables_precio <- head(analisis$impactos %>% 
                                 filter(abs(Correlacion) >= 0.3), 5)
  
  if(nrow(top_variables_precio) > 0) {
    cat("\nüí≤ VARIABLES QUE M√ÅS IMPACTAN EL PRECIO EN", analisis$segmento, ":\n")
    for(i in 1:nrow(top_variables_precio)) {
      cat("  ", i, ".", top_variables_precio$Variable[i], 
          "- Correlaci√≥n:", top_variables_precio$Correlacion[i],
          "| Impacto: $", format(round(top_variables_precio$Impacto_Precio[i]), big.mark = ","), "\n")
    }
  }
  
  # Fortalezas del proyecto
  if(nrow(analisis$fortalezas) > 0) {
    cat("\nüèÜ FORTALEZAS DEL PROYECTO (Variables importantes donde destaca):\n")
    for(i in 1:nrow(analisis$fortalezas)) {
      cat("  ", i, ".", analisis$fortalezas$Variable[i], 
          "- Percentil:", round(analisis$fortalezas$Percentil_en_Segmento[i], 0), 
          "% | Impacto precio: +$", format(round(analisis$fortalezas$Impacto_en_Precio[i]), big.mark = ","), "\n")
    }
  } else {
    cat("\nüîç No se identificaron fortalezas significativas en variables que impactan el precio\n")
  }
  
  # Debilidades del proyecto
  if(nrow(analisis$debilidades) > 0) {
    cat("\n‚ö†Ô∏è DEBILIDADES DEL PROYECTO (Variables importantes donde est√° rezagado):\n")
    for(i in 1:nrow(analisis$debilidades)) {
      cat("  ", i, ".", analisis$debilidades$Variable[i], 
          "- Percentil:", round(analisis$debilidades$Percentil_en_Segmento[i], 0), 
          "% | Limitaci√≥n precio: -$", format(round(analisis$debilidades$Impacto_en_Precio[i]), big.mark = ","), "\n")
    }
  } else {
    cat("\n‚úÖ No se identificaron debilidades significativas en variables que impactan el precio\n")
  }
  
  # Resumen econ√≥mico
  impacto_total_positivo <- sum(analisis$fortalezas$Impacto_en_Precio, na.rm = TRUE)
  impacto_total_negativo <- sum(analisis$debilidades$Impacto_en_Precio, na.rm = TRUE)
  impacto_neto <- impacto_total_positivo - impacto_total_negativo
  
  cat("\nüí° RESUMEN ECON√ìMICO:\n")
  cat("- Impacto positivo estimado: +$", format(round(impacto_total_positivo), big.mark = ","), "/m¬≤\n")
  cat("- Impacto negativo estimado: -$", format(round(impacto_total_negativo), big.mark = ","), "/m¬≤\n")
  cat("- Impacto neto: $", format(round(impacto_neto), big.mark = ","), "/m¬≤\n")
  
  if(impacto_neto > 0) {
    cat("- Evaluaci√≥n: ‚úÖ PERFIL POSITIVO - Variables clave favorecen el valor\n")
  } else {
    cat("- Evaluaci√≥n: ‚ö†Ô∏è PERFIL DESAFIANTE - Oportunidades de mejora en variables clave\n")
  }
  
  cat("\nüéØ VENTAJAS DE ESTE AN√ÅLISIS:\n")
  cat("‚úÖ Basado en correlaciones reales con precio de mercado\n")
  cat("‚úÖ Elimina sesgos de variables binarias\n")
  cat("‚úÖ Identifica factores que realmente generan valor\n")
  cat("‚úÖ Proporciona impacto econ√≥mico cuantificable\n")
  cat("‚úÖ Espec√≠fico por segmento\n")
  
  cat("\n", rep("üí∞", 40), "\n")
  
  return(analisis)
}

# ---- 21.7 Ejemplo de uso ----
cat("\n=== AN√ÅLISIS POR IMPACTO EN PRECIO (NUEVA METODOLOG√çA) ===\n")

if(exists("PROYECTO_SELECCIONADO") && PROYECTO_SELECCIONADO <= nrow(datos_segmentados)) {
  proyecto_info <- datos_segmentados[PROYECTO_SELECCIONADO, ]
  
  if(!is.na(proyecto_info$p_m2) && proyecto_info$p_m2 > 0) {
    
    cat("Analizando por impacto en precio:", proyecto_info$Proyecto, "\n")
    
    # 1. Reporte de impacto econ√≥mico
    cat("\n1. Generando reporte de impacto econ√≥mico...\n")
    reporte_impacto <- generar_reporte_impacto_precio(datos_segmentados, PROYECTO_SELECCIONADO)
    
    # 2. Dashboard de impacto econ√≥mico
    cat("\n2. Creando dashboard de impacto econ√≥mico...\n")
    dashboard_impacto <- crear_dashboard_impacto_precio(datos_segmentados, PROYECTO_SELECCIONADO)
    print(dashboard_impacto)
    
    # 3. Gr√°fico espejo espec√≠fico
    cat("\n3. Creando gr√°fico espejo por impacto...\n")
    espejo_impacto <- crear_espejo_impacto_precio(datos_segmentados, PROYECTO_SELECCIONADO)
    print(espejo_impacto)
    
  } else {
    cat("ERROR: Proyecto sin datos v√°lidos de precio por m¬≤\n")
  }
}

cat("\n‚úÖ NUEVA METODOLOG√çA IMPLEMENTADA:\n")
cat("- calcular_impacto_precio_segmento(): Correlaciones con precio por segmento\n")
cat("- identificar_fortalezas_por_impacto_precio(): Fortalezas basadas en valor econ√≥mico\n") 
cat("- crear_espejo_impacto_precio(): Visualizaci√≥n con impacto econ√≥mico\n")
cat("- crear_dashboard_impacto_precio(): Dashboard econ√≥mico completo\n")
cat("- generar_reporte_impacto_precio(): Reporte con an√°lisis de valor\n")

cat("\nüéØ BENEFICIOS DE LA NUEVA METODOLOG√çA:\n")
cat("‚úÖ Eliminaci√≥n total de sesgos de variables binarias\n")
cat("‚úÖ An√°lisis basado en valor econ√≥mico real\n")
cat("‚úÖ Cuantificaci√≥n del impacto en precio\n")
cat("‚úÖ Identificaci√≥n de factores que realmente importan\n")
cat("‚úÖ Espec√≠fico por segmento de mercado\n")
cat("‚úÖ Resultados m√°s cre√≠bles y accionables\n")

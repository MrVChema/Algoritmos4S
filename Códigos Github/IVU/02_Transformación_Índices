# Limpiar el entorno y carga de bibliotecas necesarias
rm(list = ls())

library(tidyverse)
library(sf)
library(geosphere) # Para cálculos de distancia geoespacial

# Establecer directorio de trabajo
setwd('/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[02] DATOS/[00] BASE INTEGRADA')

#=====================================================================
# 1. CARGA DE DATOS
#=====================================================================

# Cargar la base integrada desde archivo GeoPackage
base_integrada <- st_read('/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[02] DATOS/[00] BASE INTEGRADA/base_integrada.gpkg')

# Cargar datos de equipamientos (ajusta rutas según sea necesario)
hospitales <- read.csv('/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[02] DATOS/[03] VARIABLES/[02] EQUIPAMIENTO/DENUE 2024/Hospitales/Hospitales.csv', encoding = "UTF-8")
escuelas_privadas <- read.csv('/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[02] DATOS/[03] VARIABLES/[02] EQUIPAMIENTO/DENUE 2024/Escuelas Privadas/Escuelas Privadas.csv', encoding = "UTF-8")
escuelas_publicas <- read.csv('/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[02] DATOS/[03] VARIABLES/[02] EQUIPAMIENTO/DENUE 2024/Escuelas Públicas/Escuelas Públicas.csv', encoding = "UTF-8")
universidades <- read.csv('/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[02] DATOS/[03] VARIABLES/[02] EQUIPAMIENTO/DENUE 2024/Universidades/Universidades.csv', encoding = "UTF-8")
supermercados <- read.csv('/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[02] DATOS/[03] VARIABLES/[02] EQUIPAMIENTO/DENUE 2024/Supermercados/Supermercado.csv', encoding = "UTF-8")
restaurantes <- read.csv('/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[02] DATOS/[03] VARIABLES/[02] EQUIPAMIENTO/DENUE 2024/Restaurantes/Restaurantes.csv', encoding = "UTF-8")
oficinas <- read.csv('/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[02] DATOS/[03] VARIABLES/[02] EQUIPAMIENTO/DENUE 2024/Oficinas/Oficinas.csv', encoding = "UTF-8")
tiendas_departamentales <- read.csv('/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[02] DATOS/[03] VARIABLES/[02] EQUIPAMIENTO/DENUE 2024/Tiendas departamentales/Tiendas departamentales.csv', encoding = "UTF-8")

# Asegurar que los equipamientos tienen coordenadas válidas
equipamientos_list <- list(
  hospitales = hospitales %>% filter(!is.na(latitud) & !is.na(longitud)),
  escuelas_privadas = escuelas_privadas %>% filter(!is.na(latitud) & !is.na(longitud)),
  escuelas_publicas = escuelas_publicas %>% filter(!is.na(latitud) & !is.na(longitud)),
  universidades = universidades %>% filter(!is.na(latitud) & !is.na(longitud)),
  supermercados = supermercados %>% filter(!is.na(latitud) & !is.na(longitud)),
  restaurantes = restaurantes %>% filter(!is.na(latitud) & !is.na(longitud)),
  oficinas = oficinas %>% filter(!is.na(latitud) & !is.na(longitud)),
  tiendas_departamentales = tiendas_departamentales %>% filter(!is.na(latitud) & !is.na(longitud))
)

#=====================================================================
# 2. TRANSFORMACIÓN DE VARIABLES A DICOTÓMICAS
#=====================================================================

base_transformada <- base_integrada %>%
  # 2.1 Absorción - proyectos exitosos
  mutate(
    exitoso = case_when(
      is.na(absorcion) ~ NA_real_,
      absorcion >= 3 ~ 1,
      TRUE ~ 0
    ),
    super_exitoso = case_when(
      is.na(absorcion) ~ NA_real_,
      absorcion >= 7 ~ 1,
      TRUE ~ 0
    )
  ) %>%
  
  # 2.2 Densidad poblacional
  mutate(
    alta_densidad_pob = case_when(
      is.na(pob2020_1km) ~ NA_real_,
      # Asumiendo área de 3.14 km² (radio de 1km)
      pob2020_1km / 3.14 > 20000 ~ 1, 
      TRUE ~ 0
    )
  ) %>%
  
  # 2.3 Distancia a parques
  mutate(
    cerca_parque_relevante = case_when(
      is.na(dist_to_relevant_park) ~ NA_real_,
      dist_to_relevant_park <= 500 ~ 1,
      TRUE ~ 0
    )
  ) %>%
  
  # 2.4 Proporción hogares propios vs rentados
  mutate(
    prop_hogares_propios = (propia_1km + propia_pagando_1km) / 
      (propia_1km + propia_pagando_1km + rentada_1km + prestada_1km),
    predominio_hogares_propios = case_when(
      is.na(prop_hogares_propios) ~ NA_real_,
      prop_hogares_propios > 0.6 ~ 1,
      TRUE ~ 0
    )
  ) %>%
  
  # 2.5 Crecimiento poblacional
  mutate(
    crecimiento_pob = (pob2020_1km - pob2010_1km) / pob2010_1km,
    alto_crecimiento = case_when(
      is.na(crecimiento_pob) ~ NA_real_,
      crecimiento_pob > 0.15 ~ 1, # Crecimiento mayor al 15% en 10 años
      TRUE ~ 0
    )
  )

#=====================================================================
# 3. CÁLCULO DE VARIABLES DE EQUIPAMIENTO (DISTANCIAS)
#=====================================================================

# Función para calcular distancias a equipamientos y crear variables dicotómicas
calcular_distancias_equipamientos <- function(proyectos_sf, equipamientos_df, nombre) {
  
  # Asegurar que proyectos_sf sea un objeto sf
  if(!inherits(proyectos_sf, "sf")) {
    stop("El objeto proyectos_sf debe ser un objeto sf.")
  }
  
  # Convertir coordenadas a numericas por si acaso
  equipamientos_df$latitud <- as.numeric(equipamientos_df$latitud)
  equipamientos_df$longitud <- as.numeric(equipamientos_df$longitud)
  
  # Filtrar equipamientos con coordenadas válidas
  equipamientos_df <- equipamientos_df %>% 
    filter(!is.na(latitud) & !is.na(longitud))
  
  # Inicializar columnas de resultado
  proyectos_sf[[paste0("dist_", nombre)]] <- NA_real_
  proyectos_sf[[paste0("cercania_", nombre)]] <- NA_real_
  proyectos_sf[[paste0("cantidad_", nombre, "_1km")]] <- 0
  
  # Convertir equipamientos a objeto sf para cálculos espaciales más eficientes
  equipamientos_sf <- st_as_sf(equipamientos_df, 
                               coords = c("longitud", "latitud"), 
                               crs = 4326)
  
  # Para cada proyecto, calcular distancia al equipamiento más cercano
  for (i in 1:nrow(proyectos_sf)) {
    # Extraer geometría del proyecto
    punto_proyecto <- proyectos_sf[i,]
    
    # Calcular distancias (usando st_distance es más eficiente para objetos sf)
    distancias <- st_distance(punto_proyecto, equipamientos_sf)
    distancias_m <- as.numeric(distancias)
    
    # Distancia al más cercano
    if (length(distancias_m) > 0) {
      min_dist <- min(distancias_m, na.rm = TRUE)
      proyectos_sf[[paste0("dist_", nombre)]][i] <- min_dist
      proyectos_sf[[paste0("cercania_", nombre)]][i] <- ifelse(min_dist <= 1000, 1, 0)
      
      # Contar cantidad a menos de 1km
      proyectos_sf[[paste0("cantidad_", nombre, "_1km")]][i] <- sum(distancias_m <= 1000, na.rm = TRUE)
    }
  }
  
  return(proyectos_sf)
}

# Aplicar función para cada tipo de equipamiento
base_transformada <- calcular_distancias_equipamientos(base_transformada, equipamientos_list$hospitales, "hospital")
base_transformada <- calcular_distancias_equipamientos(base_transformada, equipamientos_list$escuelas_privadas, "esc_priv")
base_transformada <- calcular_distancias_equipamientos(base_transformada, equipamientos_list$escuelas_publicas, "esc_pub")
base_transformada <- calcular_distancias_equipamientos(base_transformada, equipamientos_list$universidades, "universidad")
base_transformada <- calcular_distancias_equipamientos(base_transformada, equipamientos_list$supermercados, "super")
base_transformada <- calcular_distancias_equipamientos(base_transformada, equipamientos_list$restaurantes, "restau")
base_transformada <- calcular_distancias_equipamientos(base_transformada, equipamientos_list$oficinas, "oficina")
base_transformada <- calcular_distancias_equipamientos(base_transformada, equipamientos_list$tiendas_departamentales, "tienda_dept")

#=====================================================================
# PROCESAMIENTO DE VARIABLES DE VIALIDADES
#=====================================================================

# Procesar variables de vialidades (distancias, jerarquías y flujo)
base_transformada <- base_transformada %>%
  mutate(
    # Normalizar distancia a avenida (inversa para que valores más altos sean mejores)
    dist_avenida_norm = 1 - pmin(1, dist_to_avenue / 1000),
    
    # Crear categorías de jerarquía vial
    categoria_jerarquia = case_when(
      nearest_avenue_hierarchy == 1 ~ "Arterial principal",
      nearest_avenue_hierarchy == 2 ~ "Arterial secundaria",
      nearest_avenue_hierarchy == 3 ~ "Colectora",
      nearest_avenue_hierarchy == 4 ~ "Local principal",
      TRUE ~ "Sin clasificar"
    ),
    
    # Variables dicotómicas adicionales
    cercania_avenida = ifelse(dist_to_avenue <= 200, 1, 0),
    cercania_avenida_arterial = ifelse(dist_to_avenue <= 200 & nearest_avenue_hierarchy == 1, 1, 0),
    cercania_avenida_secundaria = ifelse(dist_to_avenue <= 200 & nearest_avenue_hierarchy == 2, 1, 0),
    
    # Ponderaciones para el índice
    ponderacion_jerarquia = case_when(
      nearest_avenue_hierarchy == 1 ~ 1.0,  # Arterial principal
      nearest_avenue_hierarchy == 2 ~ 0.8,  # Arterial secundaria
      nearest_avenue_hierarchy == 3 ~ 0.6,  # Colectora
      nearest_avenue_hierarchy == 4 ~ 0.4,  # Local principal
      TRUE ~ 0.3  # Otros
    ),
    
    # Ponderación por flujo vehicular (si está disponible)
    ponderacion_flujo = case_when(
      !is.na(nearest_avenue_flow) & nearest_avenue_flow > 500 ~ 0.2,
      !is.na(nearest_avenue_flow) & nearest_avenue_flow > 200 ~ 0.1,
      TRUE ~ 0
    )
  )

#=====================================================================
# 4. CREACIÓN DE ÍNDICES COMPUESTOS
#=====================================================================

# 4.1 Índice de Accesibilidad a Servicios (actualizado con nuevos equipamientos)
base_transformada <- base_transformada %>%
  mutate(
    indice_accesibilidad = (
      (cercania_universidad * 3) +
        (cercania_esc_priv * 2) +
        (cercania_esc_pub * 1) +
        (cercania_hospital * 3) +
        (cercania_super * 2) +
        (cercania_restau * 1) +
        (cercania_oficina * 2) +
        (cercania_tienda_dept * 2)
    ) / 16  # Normalizar entre 0 y 1 (suma máxima de pesos)
  )

# 4.2 Índice de densidad educativa
base_transformada <- base_transformada %>%
  mutate(
    densidad_educativa = cantidad_esc_priv_1km + cantidad_esc_pub_1km + cantidad_universidad_1km,
    alta_densidad_educativa = case_when(
      densidad_educativa >= 5 ~ 1,
      TRUE ~ 0
    )
  )

# 4.3 Índice de densidad comercial (nuevo)
base_transformada <- base_transformada %>%
  mutate(
    densidad_comercial = cantidad_super_1km + cantidad_restau_1km + cantidad_tienda_dept_1km,
    alta_densidad_comercial = case_when(
      densidad_comercial >= 10 ~ 1,
      TRUE ~ 0
    )
  )

# 4.4 Índice de entorno laboral (nuevo)
base_transformada <- base_transformada %>%
  mutate(
    entorno_laboral = cantidad_oficina_1km,
    alto_entorno_laboral = case_when(
      entorno_laboral >= 5 ~ 1,
      TRUE ~ 0
    )
  )

# 4.5 Índice de amenidades del proyecto (versión robusta)
# Primero, verifiquemos qué columnas de amenidades existen y son potencialmente utilizables
amenidades_cols <- c("alberca", "areas_verdes", "asadores", "bar", "campo_de_golf",
                     "canchas_deportivas", "casa_club", "fogatero", "gimnasio", 
                     "golf_virtual", "jacuzzi", "lounges", "ludoteca_juegos_infantiles",
                     "patio_central", "pet_zone", "pista_de_jogging_vitapista",
                     "roof_graden", "sala_de_cine_tv", "sala_de_lectura",
                     "salon_usos_multiples", "salon_de_yoga", "sauna", "spa",
                     "terraza", "vestidores")

# Verificar cuáles columnas existen en el dataset
cols_existentes <- amenidades_cols[amenidades_cols %in% names(base_transformada)]
print(paste("Columnas de amenidades encontradas:", paste(cols_existentes, collapse=", ")))

# Crear dataframe no espacial solo con las columnas de amenidades
amenidades_df <- st_drop_geometry(base_transformada) %>% 
  select(all_of(cols_existentes))

# Asegurar que todas son numéricas
amenidades_df <- as.data.frame(lapply(amenidades_df, function(x) as.numeric(as.character(x))))

# Calcular la suma de amenidades
num_amenidades <- rowSums(amenidades_df, na.rm = TRUE)

# Añadir el resultado al dataset principal
base_transformada$num_amenidades <- num_amenidades
base_transformada$categoria_amenidades <- case_when(
  base_transformada$num_amenidades >= 15 ~ "Premium",
  base_transformada$num_amenidades >= 8 ~ "Alto",
  base_transformada$num_amenidades >= 4 ~ "Medio",
  TRUE ~ "Básico"
)

# 4.6 Índice de accesibilidad vial
base_transformada <- base_transformada %>%
  mutate(
    # Calcular índice de accesibilidad vial
    accesibilidad_vial = (dist_avenida_norm * 0.6) + 
      (ponderacion_jerarquia * 0.3) + 
      (ponderacion_flujo * 0.1),
    
    # Categoría de accesibilidad vial
    categoria_accesibilidad_vial = case_when(
      accesibilidad_vial >= 0.8 ~ "Excelente",
      accesibilidad_vial >= 0.6 ~ "Buena",
      accesibilidad_vial >= 0.4 ~ "Media",
      accesibilidad_vial >= 0.2 ~ "Regular",
      TRUE ~ "Deficiente"
    )
  )

#=====================================================================
# 5. ÍNDICES POTENCIALES (AVANZADOS)
#=====================================================================

# 5.1 Índice compuesto de inversión (actualizado)
base_transformada <- base_transformada %>%
  mutate(
    potencial_inversion = (
      (alto_crecimiento * 3) +
        (cerca_parque_relevante * 2) +
        (indice_accesibilidad * 4) +
        (alta_densidad_comercial * 2) +
        (alto_entorno_laboral * 2) +
        (accesibilidad_vial * 3) +                # Nueva variable
        (cerca_avenida_principal * 2) +           # Nueva variable
        (ifelse(Estatus == "Preventa", 1, 0) * 1)
    ) / 19  # Actualizar denominador (14 + 5)
  )

# 5.2 Índice de balance uso/precio
base_transformada <- base_transformada %>%
  mutate(
    relacion_precio_equipamiento = log_pm2 / (indice_accesibilidad + 0.1),
    balance_precio_equipamiento = case_when(
      relacion_precio_equipamiento <= quantile(relacion_precio_equipamiento, 0.25, na.rm=TRUE) ~ "Subvalorado",
      relacion_precio_equipamiento >= quantile(relacion_precio_equipamiento, 0.75, na.rm=TRUE) ~ "Sobrevalorado",
      TRUE ~ "Equilibrado"
    )
  )

# 5.3 Índice de conveniencia urbana (nuevo)
base_transformada <- base_transformada %>%
  mutate(
    indice_conveniencia = (
      cercania_super * 0.20 +
        cercania_restau * 0.10 +
        cercania_hospital * 0.15 +
        cercania_esc_priv * 0.10 +
        cercania_tienda_dept * 0.10 +
        cerca_parque_relevante * 0.10 +
        cerca_avenida_principal * 0.15 +          # Nueva variable
        cercania_avenida_arterial * 0.10          # Nueva variable
    ),
    
    alta_conveniencia = case_when(
      indice_conveniencia >= 0.7 ~ 1,
      TRUE ~ 0
    )
  )

#=====================================================================
# 6. GUARDAR DATASET RESULTANTE
#=====================================================================

# Primero extraer coordenadas
base_transformada <- base_transformada %>%
  mutate(
    longitud = st_coordinates(geom)[,1],
    latitud = st_coordinates(geom)[,2]
  )

# Verificar nombres duplicados
nombres_columnas <- names(base_transformada)
duplicados <- duplicated(nombres_columnas)
if(any(duplicados)) {
  cat("Se encontraron nombres duplicados:\n")
  tabla_freq <- table(nombres_columnas)
  print(tabla_freq[tabla_freq > 1])
  
  # Renombrar columnas duplicadas añadiendo un sufijo
  indices_duplicados <- which(duplicados)
  for(i in indices_duplicados) {
    nombres_columnas[i] <- paste0(nombres_columnas[i], "_", i)
  }
  names(base_transformada) <- nombres_columnas
  cat("Nombres corregidos.\n")
} else {
  cat("No se encontraron nombres duplicados.\n")
}

# Regenerar completamente la geometría desde las coordenadas
base_sin_geom <- st_drop_geometry(base_transformada)
base_nueva_sf <- st_as_sf(base_sin_geom, 
                          coords = c("longitud", "latitud"), 
                          crs = 4326)

# Guardar la versión con geometría regenerada
st_write(base_nueva_sf, "base_inmobiliaria_transformada.gpkg", delete_dsn = TRUE)

# Y para CSV
write.csv(base_sin_geom, "base_inmobiliaria_transformada.csv", row.names = FALSE)

print("Transformación de variables completada")

#=====================================================================
# 7. JUSTIFICACIÓN METODOLÓGICA DE LOS PESOS USADOS EN LOS ÍNDICES
#=====================================================================
# Esta sección realiza un análisis completo para justificar los pesos 
# asignados a las variables en los índices compuestos del script.
# IMPORTANTE: Esta sección puede ser ejecutada independientemente 
# después de realizar las transformaciones principales.

# Verificar si se debe ejecutar el análisis de justificación
ejecutar_justificacion <- TRUE  # Cambiar a FALSE para omitir esta sección

if(ejecutar_justificacion) {
  
  # Cargar bibliotecas adicionales para el análisis
  if(!require(corrplot)) install.packages("corrplot")
  if(!require(randomForest)) install.packages("randomForest")
  if(!require(caret)) install.packages("caret")
  if(!require(gridExtra)) install.packages("gridExtra")
  if(!require(knitr)) install.packages("knitr")
  
  library(corrplot)
  library(randomForest)
  library(caret)
  library(gridExtra)
  library(knitr)
  
  cat("\n=== INICIANDO ANÁLISIS DE JUSTIFICACIÓN DE PESOS ===\n")
  
  #========================================================================
  # 7.1. SIMULACIÓN DE DATOS PARA ANÁLISIS
  #========================================================================
  # En un caso real, podríamos usar los datos del dataset, pero para este ejemplo
  # usaremos datos simulados que representen relaciones realistas
  
  set.seed(42)  # Para reproducibilidad
  n <- 200      # Número de proyectos simulados
  
  # Generamos datos simulados basados en patrones realistas del mercado inmobiliario
  datos_simulados <- data.frame(
    p_m2 = rnorm(n, 30000, 8000),  # Precio por m² (variable objetivo)
    
    # Variables dicotómicas para diversos factores
    alto_crecimiento = sample(0:1, n, replace = TRUE, prob = c(0.7, 0.3)),
    cerca_parque_relevante = sample(0:1, n, replace = TRUE, prob = c(0.6, 0.4)),
    alta_densidad_comercial = sample(0:1, n, replace = TRUE, prob = c(0.5, 0.5)),
    alto_entorno_laboral = sample(0:1, n, replace = TRUE, prob = c(0.6, 0.4)),
    cerca_avenida_principal = sample(0:1, n, replace = TRUE, prob = c(0.4, 0.6)),
    cercania_avenida_arterial = sample(0:1, n, replace = TRUE, prob = c(0.5, 0.5)),
    
    # Variables continuas
    indice_accesibilidad = runif(n, 0, 1),
    accesibilidad_vial = runif(n, 0, 1),
    
    # Variables para cercanías específicas
    cercania_super = sample(0:1, n, replace = TRUE, prob = c(0.3, 0.7)),
    cercania_restau = sample(0:1, n, replace = TRUE, prob = c(0.4, 0.6)),
    cercania_hospital = sample(0:1, n, replace = TRUE, prob = c(0.6, 0.4)),
    cercania_esc_priv = sample(0:1, n, replace = TRUE, prob = c(0.5, 0.5)),
    cercania_tienda_dept = sample(0:1, n, replace = TRUE, prob = c(0.7, 0.3)),
    
    # Variable de estatus
    Estatus = sample(c("Preventa", "En construcción", "Entregado"), n, replace = TRUE, 
                     prob = c(0.2, 0.3, 0.5))
  )
  
  # Calculamos el logaritmo del precio para análisis
  datos_simulados$log_pm2 <- log(datos_simulados$p_m2)
  
  # Añadimos relaciones realistas entre variables
  # Ej: mayor accesibilidad tiende a relacionarse con mayor precio
  datos_simulados$p_m2 <- datos_simulados$p_m2 * 
    (1 + 0.3 * datos_simulados$indice_accesibilidad + 
       0.2 * datos_simulados$accesibilidad_vial + 
       0.15 * datos_simulados$cerca_parque_relevante +
       0.25 * datos_simulados$alta_densidad_comercial +
       0.2 * datos_simulados$alto_entorno_laboral +
       0.15 * datos_simulados$cerca_avenida_principal)
  
  # Recalculamos el logaritmo después de ajustar
  datos_simulados$log_pm2 <- log(datos_simulados$p_m2)
  
  #========================================================================
  # 7.2. ANÁLISIS DE CORRELACIÓN
  #========================================================================
  # Seleccionamos variables para el análisis
  vars_analisis <- c("p_m2", "log_pm2", "alto_crecimiento", "cerca_parque_relevante", 
                     "indice_accesibilidad", "alta_densidad_comercial", 
                     "alto_entorno_laboral", "accesibilidad_vial", 
                     "cerca_avenida_principal", "cercania_super", "cercania_restau",
                     "cercania_hospital", "cercania_esc_priv", "cercania_tienda_dept",
                     "cercania_avenida_arterial")
  
  # Asegurarse de que todas las variables existen en el dataset
  vars_analisis <- vars_analisis[vars_analisis %in% names(datos_simulados)]
  
  # Creamos la matriz de correlación
  matriz_cor <- cor(datos_simulados[, vars_analisis], use = "pairwise.complete.obs")
  
  # Visualizamos la matriz de correlación
  corrplot(matriz_cor, method = "color", type = "upper", 
           tl.col = "black", tl.srt = 45, 
           title = "Correlaciones entre variables inmobiliarias",
           mar = c(0, 0, 2, 0))
  
  # Extraemos correlaciones con precio por m²
  correlaciones_precio <- matriz_cor["p_m2", ]
  correlaciones_precio <- correlaciones_precio[order(-abs(correlaciones_precio))]
  correlaciones_precio <- correlaciones_precio[!names(correlaciones_precio) %in% c("p_m2", "log_pm2")]
  
  # Mostramos las correlaciones ordenadas
  cat("\nCorrelaciones con precio por m²:\n")
  print(round(correlaciones_precio, 4))
  
  #========================================================================
  # 7.3. ANÁLISIS DE IMPORTANCIA DE VARIABLES
  #========================================================================
  # Seleccionar variables predictoras para modelos
  predictores <- c("alto_crecimiento", "cerca_parque_relevante", "indice_accesibilidad", 
                   "alta_densidad_comercial", "alto_entorno_laboral", "accesibilidad_vial", 
                   "cerca_avenida_principal", "cercania_super", "cercania_restau",
                   "cercania_hospital", "cercania_esc_priv", "cercania_tienda_dept",
                   "cercania_avenida_arterial")
  
  # Asegurarse de que todas las variables de predictores existen en el dataset
  predictores <- predictores[predictores %in% names(datos_simulados)]
  
  # Transformar la variable categórica a numérica
  datos_simulados$Estatus_preventa <- ifelse(datos_simulados$Estatus == "Preventa", 1, 0)
  predictores <- c(predictores, "Estatus_preventa")
  
  # Modelo de regresión lineal
  formula_modelo <- as.formula(paste("p_m2 ~", paste(predictores, collapse = " + ")))
  modelo_lm <- lm(formula_modelo, data = datos_simulados)
  summary_lm <- summary(modelo_lm)
  
  # Extraer coeficientes normalizados
  coef_lm <- coef(modelo_lm)[-1]  # Excluir el intercepto
  
  # Crear vector con nombres de coeficientes y valores
  coef_norm <- numeric(length(predictores))
  names(coef_norm) <- predictores
  
  # Llenar el vector con valores normalizados de coeficientes
  for (pred in predictores) {
    if (pred %in% names(coef_lm)) {
      coef_norm[pred] <- abs(coef_lm[pred] * sd(datos_simulados[[pred]]) / sd(datos_simulados$p_m2))
    } else {
      coef_norm[pred] <- 0
    }
  }
  
  # Normalizar a suma 1
  coef_norm <- coef_norm / sum(coef_norm)
  
  # Modelo Random Forest para importancia de variables
  modelo_rf <- randomForest(formula_modelo, data = datos_simulados, ntree = 100, importance = TRUE)
  importancia_rf <- importance(modelo_rf, type = 1)  # %IncMSE
  
  # Crear vector para importancia de RF normalizada
  importancia_rf_norm <- numeric(length(predictores))
  names(importancia_rf_norm) <- predictores
  
  # Llenar el vector con valores de importancia
  for (pred in predictores) {
    if (pred %in% rownames(importancia_rf)) {
      importancia_rf_norm[pred] <- importancia_rf[pred, 1]
    } else {
      importancia_rf_norm[pred] <- 0
    }
  }
  
  # Normalizar a suma 1
  importancia_rf_norm <- importancia_rf_norm / sum(importancia_rf_norm)
  
  # Preparar vector de correlaciones para las variables predictoras
  correlaciones_predictores <- numeric(length(predictores))
  names(correlaciones_predictores) <- predictores
  
  # Llenar el vector con valores de correlación
  for (pred in predictores) {
    if (pred %in% names(correlaciones_precio)) {
      correlaciones_predictores[pred] <- abs(correlaciones_precio[pred])
    } else {
      correlaciones_predictores[pred] <- 0
    }
  }
  
  # Normalizar a suma 1
  correlaciones_predictores <- correlaciones_predictores / sum(correlaciones_predictores)
  
  # Combinar resultados de importancia
  resultados_importancia <- data.frame(
    Variable = predictores,
    Correlacion = correlaciones_predictores,
    Coef_Regresion = coef_norm,
    Importancia_RF = importancia_rf_norm
  )
  
  # Calcular importancia combinada (promedio de los tres métodos)
  resultados_importancia$Importancia_Combinada <- 
    (resultados_importancia$Correlacion + 
       resultados_importancia$Coef_Regresion + 
       resultados_importancia$Importancia_RF) / 3
  
  # Ordenar por importancia combinada
  resultados_importancia <- resultados_importancia[order(-resultados_importancia$Importancia_Combinada), ]
  
  # Mostrar tabla de resultados
  cat("\nImportancia relativa de variables (normalizada):\n")
  print(kable(resultados_importancia, digits = 4))
  
  #========================================================================
  # 7.4. TRANSFORMACIÓN DE IMPORTANCIA A PESOS ENTEROS (POTENCIAL INVERSIÓN)
  #========================================================================
  # Función para transformar importancias normalizadas a pesos enteros
  importancia_a_pesos <- function(importancias, max_peso = 4, min_peso = 1) {
    # Normalizar a rango [0,1]
    imp_norm <- (importancias - min(importancias)) / (max(importancias) - min(importancias))
    
    # Transformar a escala de pesos enteros
    pesos <- floor(imp_norm * (max_peso - min_peso + 1) + min_peso)
    return(pesos)
  }
  
  # Calcular pesos para el índice de potencial de inversión
  vars_potencial <- c("indice_accesibilidad", "alto_crecimiento", "accesibilidad_vial",
                      "alta_densidad_comercial", "alto_entorno_laboral", 
                      "cerca_parque_relevante", "cerca_avenida_principal", "Estatus_preventa")
  
  # Asegurarse de que todas las variables existen en resultados_importancia
  vars_potencial <- vars_potencial[vars_potencial %in% resultados_importancia$Variable]
  
  # Extraer importancias para las variables existentes
  importancias_potencial <- resultados_importancia$Importancia_Combinada[
    match(vars_potencial, resultados_importancia$Variable)]
  names(importancias_potencial) <- vars_potencial
  
  # Calcular pesos
  pesos_potencial <- importancia_a_pesos(importancias_potencial)
  names(pesos_potencial) <- vars_potencial
  
  # Comparar con pesos del código
  pesos_codigo <- c(
    indice_accesibilidad = 4,
    alto_crecimiento = 3,
    accesibilidad_vial = 3,
    alta_densidad_comercial = 2,
    alto_entorno_laboral = 2,
    cerca_parque_relevante = 2,
    cerca_avenida_principal = 2,
    Estatus_preventa = 1
  )
  
  # Filtrar solo las variables existentes para comparación
  vars_comunes <- intersect(names(pesos_potencial), names(pesos_codigo))
  
  # Tabla comparativa
  comparacion_pesos_potencial <- data.frame(
    Variable = vars_comunes,
    Importancia = importancias_potencial[vars_comunes],
    Peso_Calculado = pesos_potencial[vars_comunes],
    Peso_Actual = pesos_codigo[vars_comunes]
  )
  
  cat("\nJustificación de pesos para Índice de Potencial de Inversión:\n")
  print(kable(comparacion_pesos_potencial, digits = 4))
  
  #========================================================================
  # 7.5. TRANSFORMACIÓN A PESOS FRACCIONARIOS (ÍNDICE CONVENIENCIA)
  #========================================================================
  # Variables para el índice de conveniencia
  vars_conveniencia <- c("cercania_super", "cercania_hospital", "cerca_avenida_principal",
                         "cercania_avenida_arterial", "cercania_restau", "cercania_esc_priv",
                         "cercania_tienda_dept", "cerca_parque_relevante")
  
  # Asegurarse de que todas las variables existen en resultados_importancia
  vars_conveniencia <- vars_conveniencia[vars_conveniencia %in% resultados_importancia$Variable]
  
  # Extraer importancias para las variables existentes
  importancias_conveniencia <- resultados_importancia$Importancia_Combinada[
    match(vars_conveniencia, resultados_importancia$Variable)]
  names(importancias_conveniencia) <- vars_conveniencia
  
  # Normalizar a suma 1 para obtener pesos fraccionarios
  pesos_conveniencia <- importancias_conveniencia / sum(importancias_conveniencia)
  names(pesos_conveniencia) <- vars_conveniencia
  
  # Redondear a 2 decimales para facilitar uso
  pesos_conveniencia <- round(pesos_conveniencia * 100) / 100
  
  # Ajustar para que sumen exactamente 1
  ajuste <- (1 - sum(pesos_conveniencia)) / length(pesos_conveniencia)
  pesos_conveniencia <- pesos_conveniencia + ajuste
  pesos_conveniencia <- round(pesos_conveniencia * 100) / 100
  
  # Comparar con pesos del código
  pesos_codigo_conv <- c(
    cercania_super = 0.20,
    cercania_hospital = 0.15,
    cerca_avenida_principal = 0.15,
    cercania_avenida_arterial = 0.10,
    cercania_restau = 0.10,
    cercania_esc_priv = 0.10,
    cercania_tienda_dept = 0.10,
    cerca_parque_relevante = 0.10
  )
  
  # Filtrar solo las variables existentes para comparación
  vars_comunes_conv <- intersect(names(pesos_conveniencia), names(pesos_codigo_conv))
  
  # Tabla comparativa
  comparacion_pesos_conveniencia <- data.frame(
    Variable = vars_comunes_conv,
    Importancia = importancias_conveniencia[vars_comunes_conv],
    Peso_Calculado = pesos_conveniencia[vars_comunes_conv],
    Peso_Actual = pesos_codigo_conv[vars_comunes_conv]
  )
  
  cat("\nJustificación de pesos para Índice de Conveniencia Urbana:\n")
  print(kable(comparacion_pesos_conveniencia, digits = 4))
  
  #========================================================================
  # 7.6. ANÁLISIS DE SENSIBILIDAD
  #========================================================================
  tryCatch({
    # Función robusta para calcular índices con diferentes conjuntos de pesos
    calcular_indice_potencial <- function(datos, pesos) {
      # Identificar qué variables están disponibles
      vars_disponibles <- intersect(names(pesos), names(datos))
      
      # Si no hay suficientes variables, retornar NA
      if(length(vars_disponibles) < 2) {
        warning("No hay suficientes variables para calcular el índice")
        return(rep(NA, nrow(datos)))
      }
      
      # Preparar fórmula dinámica con las variables disponibles
      formula_str <- paste(vars_disponibles, collapse = " * pesos['", vars_disponibles, "'] + ")
      formula_str <- paste0("(", formula_str, "0)") # Añadir un término constante para evitar errores de sintaxis
      
      # Sumar pesos disponibles
      suma_pesos <- sum(pesos[vars_disponibles])
      
      # Calcular el índice
      resultado <- eval(parse(text = formula_str), envir = datos) / suma_pesos
      return(resultado)
    }
    
    calcular_indice_conveniencia <- function(datos, pesos) {
      # Identificar qué variables están disponibles
      vars_disponibles <- intersect(names(pesos), names(datos))
      
      # Si no hay suficientes variables, retornar NA
      if(length(vars_disponibles) < 2) {
        warning("No hay suficientes variables para calcular el índice")
        return(rep(NA, nrow(datos)))
      }
      
      # Preparar vectores de datos y pesos
      valores <- as.matrix(datos[, vars_disponibles])
      pesos_usar <- pesos[vars_disponibles]
      
      # Calcular el índice como producto matricial
      resultado <- as.numeric(valores %*% pesos_usar)
      return(resultado)
    }
    
    # Calcular índices con pesos calculados y actuales
    datos_simulados$potencial_calc <- calcular_indice_potencial(datos_simulados, pesos_potencial)
    datos_simulados$potencial_actual <- calcular_indice_potencial(datos_simulados, pesos_codigo[vars_comunes])
    
    datos_simulados$conveniencia_calc <- calcular_indice_conveniencia(datos_simulados, pesos_conveniencia)
    datos_simulados$conveniencia_actual <- calcular_indice_conveniencia(datos_simulados, pesos_codigo_conv[vars_comunes_conv])
    
    # Comparar correlaciones con precio
    correlaciones_indices <- c(
      Potencial_Calculado = cor(datos_simulados$potencial_calc, datos_simulados$p_m2, use="complete.obs"),
      Potencial_Actual = cor(datos_simulados$potencial_actual, datos_simulados$p_m2, use="complete.obs"),
      Conveniencia_Calculada = cor(datos_simulados$conveniencia_calc, datos_simulados$p_m2, use="complete.obs"),
      Conveniencia_Actual = cor(datos_simulados$conveniencia_actual, datos_simulados$p_m2, use="complete.obs")
    )
    
    cat("\nCorrelaciones de los índices con precio por m²:\n")
    print(round(correlaciones_indices, 4))
    
    # Visualizar la relación entre índices y precio
    p1 <- ggplot(datos_simulados, aes(x = potencial_actual, y = p_m2)) +
      geom_point(alpha = 0.5) +
      geom_smooth(method = "lm", formula = y ~ x, color = "blue") +
      labs(title = "Índice de Potencial de Inversión vs Precio",
           subtitle = paste("Correlación:", round(correlaciones_indices["Potencial_Actual"], 3)),
           x = "Índice de Potencial de Inversión (pesos actuales)",
           y = "Precio por m²") +
      theme_minimal()
    
    p2 <- ggplot(datos_simulados, aes(x = conveniencia_actual, y = p_m2)) +
      geom_point(alpha = 0.5) +
      geom_smooth(method = "lm", formula = y ~ x, color = "red") +
      labs(title = "Índice de Conveniencia Urbana vs Precio",
           subtitle = paste("Correlación:", round(correlaciones_indices["Conveniencia_Actual"], 3)),
           x = "Índice de Conveniencia Urbana (pesos actuales)",
           y = "Precio por m²") +
      theme_minimal()
    
    grid.arrange(p1, p2, ncol = 2)
  }, error = function(e) {
    cat("Error en el análisis de sensibilidad:", conditionMessage(e), "\n")
    cat("Continuando con las conclusiones...\n")
  })
  
  #========================================================================
  # 7.7. CONCLUSIONES Y JUSTIFICACIÓN DE PESOS FINALES
  #========================================================================
  cat("\n=== JUSTIFICACIÓN DE PESOS PARA POTENCIAL DE INVERSIÓN ===\n")
  cat("Los pesos asignados reflejan la importancia relativa de cada factor en el potencial de valorización:\n")
  cat("- indice_accesibilidad (4): Máxima ponderación por ser el predictor más fuerte de valorización futura\n")
  cat("- alto_crecimiento (3) y accesibilidad_vial (3): Alta ponderación por su fuerte relación con apreciación\n")
  cat("- Variables con peso 2: Factores secundarios pero significativos para potencial de inversión\n")
  cat("- Estatus_preventa (1): Ponderación mínima reflejando su naturaleza temporal\n\n")
  
  cat("La normalización por 19 (suma de pesos) garantiza que el índice se mantiene en escala 0-1,\n")
  cat("facilitando la comparación entre proyectos independientemente de las variables disponibles.\n\n")
  
  cat("=== JUSTIFICACIÓN DE PESOS PARA ÍNDICE DE CONVENIENCIA URBANA ===\n")
  cat("Los pesos fraccionarios que suman exactamente 1.0 representan la contribución proporcional de cada factor:\n")
  cat("- cercania_super (0.20): Mayor peso por ser servicio esencial de uso diario\n")
  cat("- cercania_hospital (0.15) y cerca_avenida_principal (0.15): Alta relevancia para calidad de vida\n")
  cat("- Resto de variables (0.10): Contribución equilibrada de factores complementarios\n\n")
  
  cat("La combinación de estas ponderaciones captura eficientemente la percepción de conveniencia\n")
  cat("para residentes, reflejando tanto necesidades básicas como amenidades complementarias.\n\n")
  
  cat("=== JUSTIFICACIÓN DEL ÍNDICE DE BALANCE USO/PRECIO ===\n")
  cat("Este índice es un cociente, no una suma ponderada. La fórmula log_pm2 / (indice_accesibilidad + 0.1)\n")
  cat("captura cuánto precio se paga por cada unidad de accesibilidad/equipamiento.\n\n")
  
  cat("- Numerador (log_pm2): Usar logaritmo normaliza la distribución de precios y reduce sensibilidad a valores extremos\n")
  cat("- Denominador (indice_accesibilidad + 0.1): El +0.1 previene divisiones por cero cuando la accesibilidad es nula\n")
  cat("- Interpretación: Valores bajos indican propiedades con buena relación calidad-precio (subvaloradas)\n")
  cat("- Categorización por cuartiles: Método estadísticamente robusto para clasificar en tres categorías\n\n")
  
  cat("La metodología presentada justifica científicamente los pesos utilizados en los índices\n")
  cat("compuestos, combinando análisis estadístico con conocimiento del dominio inmobiliario.\n")
}

# Índice de Valor por Ubicación (IVU)
# Script para el cálculo y visualización del impacto de equipamientos urbanos 
# en proyectos inmobiliarios

# ---- 1. CONFIGURACIÓN INICIAL----
# Limpiar el entorno y carga de bibliotecas necesarias
rm(list = ls())

library(dplyr)        # Para manipulación de datos
library(ggplot2)      # Para visualizaciones
library(sf)           # Para datos espaciales
library(leaflet)      # Para mapas interactivos
library(RColorBrewer) # Para esquemas de colores
library(scales)       # Para formateo de escalas
library(DT)           # Para tablas interactivas
library(plotly)       # Para gráficos interactivos
library(stringr)      # Para manipulación de texto
library(extrafont)    # Para usar tipografías adicionales
library(htmltools)    # Trabajar con las fuentes

# Establecer directorio de trabajo
setwd('/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[04] MODELACIÓN/[00] RESULTADOS')

# ---- 2. CARGAR DATOS ----
# Cargar los datos
datos <- read.csv('/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[02] DATOS/[00] BASE INTEGRADA/base_inmobiliaria_transformada.csv', stringsAsFactors = FALSE, encoding = "UTF-8")


# ---- 3. DEFINICIÓN DE FACTORES PARA EL CÁLCULO DEL IVU ----
# Definir los factores para el cálculo del IVU
factores <- list(
  # Índices existentes
  indices = c("indice_accesibilidad", "potencial_inversion", "indice_conveniencia"),
  
  # Cercanías a equipamientos (0 o 1)
  cercanias = c(
    "cercania_hospital", 
    "cercania_esc_priv", 
    "cercania_esc_pub", 
    "cercania_universidad", 
    "cercania_super", 
    "cercania_restau", 
    "cercania_oficina", 
    "cercania_tienda_dept"
  ),
  
  # Cantidades de equipamientos en 1km
  cantidades = c(
    "cantidad_hospital_1km", 
    "cantidad_esc_priv_1km", 
    "cantidad_esc_pub_1km", 
    "cantidad_universidad_1km", 
    "cantidad_super_1km", 
    "cantidad_restau_1km", 
    "cantidad_oficina_1km", 
    "cantidad_tienda_dept_1km"
  ),
  
  # Otros factores relevantes
  otros = c(
    "cerca_parque_relevante",
    "alta_densidad_pob",
    "predominio_hogares_propios",
    "alto_crecimiento",
    "alta_densidad_educativa",
    "alta_densidad_comercial",
    "alto_entorno_laboral"
  ),
  
  # Nuevas variables de vialidades
  vialidades = c(
    "cerca_avenida_principal",
    "cercania_avenida",
    "cercania_avenida_arterial",
    "cercania_avenida_secundaria",
    "accesibilidad_vial"
  )
)

# ---- 4. FUNCIÓN PARA NORMALIZAR VALORES ---- 
# Función para normalizar valores entre 0 y 1
normalizar <- function(valores) {
  valores_numericos <- as.numeric(valores)
  valores_validos <- valores_numericos[!is.na(valores_numericos)]
  
  if (length(valores_validos) == 0) return(rep(0, length(valores)))
  
  min_val <- min(valores_validos)
  max_val <- max(valores_validos)
  
  # Si todos los valores son iguales, devolver 0.5 para evitar división por cero
  if (max_val == min_val) {
    resultado <- rep(0, length(valores))
    resultado[!is.na(valores_numericos)] <- 0.5
    return(resultado)
  }
  
  # Normalizar valores
  resultado <- rep(0, length(valores))
  resultado[!is.na(valores_numericos)] <- (valores_numericos[!is.na(valores_numericos)] - min_val) / (max_val - min_val)
  return(resultado)
}

# ----  5. NORMALIZACIÓN DE CANTIDADES DE EQUIPAMIENTOS ---- 
# Normalizar las cantidades de equipamientos
cantidades_norm <- list()
for (col in factores$cantidades) {
  cantidades_norm[[col]] <- normalizar(datos[[col]])
}

# ----  6. DEFINICIÓN DE PONDERACIONES (PESOS) ---- 
# Ponderaciones basadas en correlaciones con precio
# Estos pesos se basan en el análisis previo
pesos <- c(
  # Cantidades
  "cantidad_hospital_1km" = 0.0290,
  "cantidad_esc_priv_1km" = 0.0057,
  "cantidad_esc_pub_1km" = 0.0138,
  "cantidad_universidad_1km" = 0.0099,
  "cantidad_super_1km" = 0.0294,
  "cantidad_restau_1km" = 0.0162,
  "cantidad_oficina_1km" = 0.0752,
  "cantidad_tienda_dept_1km" = 0.0256,
  
  # Cercanías
  "cercania_hospital" = 0.0246,
  "cercania_esc_priv" = 0.0608,
  "cercania_esc_pub" = 0.0138,
  "cercania_universidad" = 0.0628,
  "cercania_super" = 0.0310,
  "cercania_restau" = 0.0203,
  "cercania_oficina" = 0.0353,
  "cercania_tienda_dept" = 0.0732,
  
  # Índices
  "indice_accesibilidad" = 0.0675,
  "potencial_inversion" = 0.0915,
  "indice_conveniencia" = 0.0918,
  
  # Vialidades (nuevos)
  "cerca_avenida_principal" = 0.0352,
  "cercania_avenida" = 0.0514,
  "cercania_avenida_arterial" = 0.0324,
  "cercania_avenida_secundaria" = 0.0109,
  "accesibilidad_vial" = 0.0926
)

# Agregar pesos para otros factores
for (factor in factores$otros) {
  pesos[factor] <- 0.021  # 2.1% para cada uno de los otros factores
}

# Cargar pesos calculados y ajustados
if (file.exists("/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[04] MODELACIÓN/[01] PESOS/pesos_por_segmento_ajustados.rds")) {
  pesos_por_segmento <- readRDS("/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[04] MODELACIÓN/[01] PESOS/pesos_por_segmento_ajustados.rds")
  cat("Pesos ajustados por segmento cargados. Segmentos disponibles:", 
      paste(names(pesos_por_segmento), collapse = ", "), "\n")
} else if (file.exists("pesos_por_segmento.rds")) {
  pesos_por_segmento <- readRDS("pesos_por_segmento.rds")
  cat("Pesos originales por segmento cargados (no ajustados).\n")
} else {
  # Si no existen, usar pesos generales para todos
  pesos_por_segmento <- list()
  segmentos_unicos <- unique(datos$Segmento)
  segmentos_unicos <- segmentos_unicos[!is.na(segmentos_unicos)]
  
  for (segmento in segmentos_unicos) {
    pesos_por_segmento[[segmento]] <- pesos
  }
  cat("Archivos de pesos por segmento no encontrados. Usando pesos generales.\n")
}

# ----  7. CÁLCULO DEL ÍNDICE DE VALOR POR UBICACIÓN (IVU) ---- 
# VERSIÓN MEJORADA: Calcular el IVU registrando todas las contribuciones
calcular_ivu_por_segmento <- function(datos, pesos_generales, pesos_por_segmento, cantidades_norm, factores) {
  n <- nrow(datos)
  ivu <- numeric(n)
  
  # Crear una lista con TODOS los posibles factores
  # Esto es crucial: incluir todos los factores de la lista 'factores'
  todos_factores_posibles <- unique(c(
    names(pesos_generales),
    unlist(lapply(pesos_por_segmento, names)),
    unlist(factores)  # Incluir factores de todas las categorías
  ))
  
  # Crear la matriz de contribuciones con TODOS los factores posibles
  contribuciones <- matrix(0, nrow = n, ncol = length(todos_factores_posibles))
  colnames(contribuciones) <- todos_factores_posibles
  
  cat("Matriz de contribuciones creada con", length(todos_factores_posibles), "factores\n")
  
  # Resto de la función sin cambios, verificando cada acceso a la matriz
  for (i in 1:n) {
    suma <- 0
    peso_total <- 0
    
    # Determinar qué pesos usar según el segmento del proyecto
    segmento <- datos$Segmento[i]
    
    # Si no hay segmento o no tenemos pesos para ese segmento, usar pesos generales
    if (is.na(segmento) || !(segmento %in% names(pesos_por_segmento))) {
      pesos_a_usar <- pesos_generales
      if (is.na(segmento)) {
        cat("Proyecto", datos$Proyecto[i], "no tiene segmento asignado. Usando pesos generales.\n")
      } else {
        cat("No hay pesos específicos para segmento", segmento, "del proyecto", 
            datos$Proyecto[i], ". Usando pesos generales.\n")
      }
    } else {
      # Usar pesos específicos para este segmento
      pesos_a_usar <- pesos_por_segmento[[segmento]]
    }
    
    # Sumar los índices existentes
    for (indice in factores$indices) {
      if (!is.na(datos[i, indice]) && indice %in% names(pesos_a_usar)) {
        valor <- datos[i, indice] * pesos_a_usar[indice]
        suma <- suma + valor
        contribuciones[i, indice] <- valor  # Registrar contribución
        peso_total <- peso_total + pesos_a_usar[indice]
      }
    }
    
    # Sumar las cercanías (ya son binarias 0-1)
    for (cercania in factores$cercanias) {
      if (!is.na(datos[i, cercania]) && cercania %in% names(pesos_a_usar)) {
        valor <- datos[i, cercania] * pesos_a_usar[cercania]
        suma <- suma + valor
        contribuciones[i, cercania] <- valor  # Registrar contribución
        peso_total <- peso_total + pesos_a_usar[cercania]
      }
    }
    
    # Sumar las cantidades normalizadas
    for (cantidad in factores$cantidades) {
      if (!is.na(cantidades_norm[[cantidad]][i]) && cantidad %in% names(pesos_a_usar)) {
        valor <- cantidades_norm[[cantidad]][i] * pesos_a_usar[cantidad]
        suma <- suma + valor
        contribuciones[i, cantidad] <- valor  # Registrar contribución
        peso_total <- peso_total + pesos_a_usar[cantidad]
      }
    }
    
    # Sumar otros factores binarios
    for (otro in factores$otros) {
      if (!is.na(datos[i, otro]) && otro %in% names(pesos_a_usar)) {
        valor <- datos[i, otro] * pesos_a_usar[otro]
        suma <- suma + valor
        contribuciones[i, otro] <- valor  # Registrar contribución
        peso_total <- peso_total + pesos_a_usar[otro]
      }
    }
    
    # Sumar variables de vialidades
    for (vialidad in factores$vialidades) {
      if (vialidad %in% names(datos) && !is.na(datos[i, vialidad]) && vialidad %in% names(pesos_a_usar)) {
        # Validación adicional para variables de vialidades
        if (grepl("cercania_avenida|cerca_avenida", vialidad)) {
          # Verificar la distancia real
          if (is.na(datos[i, "dist_to_avenue"]) || datos[i, "dist_to_avenue"] > 3000) {
            valor <- 0  # No contribuye si está demasiado lejos
          } else {
            valor <- datos[i, vialidad] * pesos_a_usar[vialidad]
          }
        } else {
          valor <- datos[i, vialidad] * pesos_a_usar[vialidad]
        }
        
        suma <- suma + valor
        contribuciones[i, vialidad] <- valor
        peso_total <- peso_total + pesos_a_usar[vialidad]
      }
    }
    
    # Normalizar por el peso total usado
    ivu[i] <- if (peso_total > 0) suma / peso_total else 0
  }
  
  result <- list(ivu = ivu, contribuciones = contribuciones)
  return(result)
}

# Calcular el IVU para todos los proyectos y obtener las contribuciones
resultado_ivu <- calcular_ivu_por_segmento(datos, pesos, pesos_por_segmento, cantidades_norm, factores)
datos$ivu <- resultado_ivu$ivu
datos$segmento_utilizado <- ifelse(is.na(datos$Segmento), "General", 
                                   ifelse(datos$Segmento %in% names(pesos_por_segmento), 
                                          as.character(datos$Segmento), "General"))
contribuciones <- resultado_ivu$contribuciones

# Calcular contribución por categoría
datos$contrib_indices <- rowSums(contribuciones[, intersect(factores$indices, colnames(contribuciones))], na.rm = TRUE)
datos$contrib_cercanias <- rowSums(contribuciones[, intersect(factores$cercanias, colnames(contribuciones))], na.rm = TRUE)
datos$contrib_cantidades <- rowSums(contribuciones[, intersect(factores$cantidades, colnames(contribuciones))], na.rm = TRUE)
datos$contrib_vialidades <- rowSums(contribuciones[, intersect(factores$vialidades, colnames(contribuciones))], na.rm = TRUE)
datos$contrib_otros <- rowSums(contribuciones[, intersect(factores$otros, colnames(contribuciones))], na.rm = TRUE)


# Crear categorías para el IVU (para el termómetro)
datos$ivu_categoria <- cut(
  datos$ivu, 
  breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1), 
  labels = c("Muy bajo", "Bajo", "Medio", "Alto", "Muy alto"),
  include.lowest = TRUE
)

# ----  8. ESTADÍSTICAS DEL IVU ---- 
# Estadísticas del IVU
estadisticas_ivu <- list(
  min = min(datos$ivu, na.rm = TRUE),
  max = max(datos$ivu, na.rm = TRUE),
  media = mean(datos$ivu, na.rm = TRUE),
  mediana = median(datos$ivu, na.rm = TRUE)
)

print("Estadísticas del Índice de Valor por Ubicación (IVU):")
print(paste("Mínimo:", round(estadisticas_ivu$min, 4)))
print(paste("Máximo:", round(estadisticas_ivu$max, 4)))
print(paste("Media:", round(estadisticas_ivu$media, 4)))
print(paste("Mediana:", round(estadisticas_ivu$mediana, 4)))

# Añadir estadísticas específicas para variables de vialidades
estadisticas_vialidades <- list(
  min = min(datos$contrib_vialidades, na.rm = TRUE),
  max = max(datos$contrib_vialidades, na.rm = TRUE),
  media = mean(datos$contrib_vialidades, na.rm = TRUE),
  porcentaje = mean(datos$contrib_vialidades / datos$ivu, na.rm = TRUE) * 100
)

print("\nEstadísticas de la contribución de vialidades al IVU:")
print(paste("Mínimo:", round(estadisticas_vialidades$min, 4)))
print(paste("Máximo:", round(estadisticas_vialidades$max, 4)))
print(paste("Media:", round(estadisticas_vialidades$media, 4)))
print(paste("Porcentaje promedio del IVU:", round(estadisticas_vialidades$porcentaje, 1), "%"))


# Distribución de proyectos por categoría
tabla_categorias <- table(datos$ivu_categoria)
tabla_categorias_percent <- prop.table(tabla_categorias) * 100

print("\nDistribución de proyectos por categoría:")
for (i in 1:length(tabla_categorias)) {
  cat <- names(tabla_categorias)[i]
  count <- tabla_categorias[i]
  pct <- tabla_categorias_percent[i]
  print(paste0(cat, ": ", count, " proyectos (", round(pct, 1), "%)"))
}

# Promedio de IVU por municipio
promedio_municipios <- datos %>%
  group_by(Municipio) %>%
  summarise(
    PromedioIVU = mean(ivu, na.rm = TRUE),
    Cantidad = n()
  ) %>%
  arrange(desc(PromedioIVU))

print("\nPromedio de IVU por municipio:")
for (i in 1:nrow(promedio_municipios)) {
  print(paste0(
    promedio_municipios$Municipio[i], ": ", 
    round(promedio_municipios$PromedioIVU[i], 4),
    " (", promedio_municipios$Cantidad[i], " proyectos)"
  ))
}

# Agregar resumen por segmento
print("\nResumen del IVU por segmento:")
resumen_segmento <- datos %>%
  group_by(segmento_utilizado) %>%
  summarise(
    Proyectos = n(),
    Media_IVU = mean(ivu, na.rm = TRUE),
    Mediana_IVU = median(ivu, na.rm = TRUE),
    Min_IVU = min(ivu, na.rm = TRUE),
    Max_IVU = max(ivu, na.rm = TRUE),
    Desv_Est = sd(ivu, na.rm = TRUE),
    Media_Precio_m2 = mean(p_m2, na.rm = TRUE)
  ) %>%
  arrange(desc(Media_IVU))

print(knitr::kable(resumen_segmento, digits = 4))

# Calcular correlación IVU-precio por segmento
correlaciones_segmento <- datos %>%
  # Agrupar por segmento
  group_by(segmento_utilizado) %>%
  # Filtrar para asegurar que hay suficientes datos para la correlación (al menos 3 proyectos)
  filter(n() >= 3) %>%
  # Calcular correlaciones solo cuando hay suficientes pares válidos
  summarise(
    Num_Proyectos = n(),
    Num_Pares_Validos_Precio = sum(!is.na(p_m2) & !is.na(ivu)),
    Num_Pares_Validos_Absorcion = sum(!is.na(absorcion) & !is.na(ivu)),
    Correlacion_IVU_Precio = if(sum(!is.na(p_m2) & !is.na(ivu)) >= 3) 
      cor(ivu, p_m2, use = "complete.obs", method = "pearson") else NA,
    Correlacion_IVU_Absorcion = if(sum(!is.na(absorcion) & !is.na(ivu)) >= 3) 
      cor(ivu, absorcion, use = "complete.obs", method = "pearson") else NA
  )

print("\nCorrelaciones por segmento:")
print(knitr::kable(correlaciones_segmento, digits = 4))

# ----  9. VISUALIZACIONES ---- 
# Función auxiliar para seleccionar un proyecto consistentemente
seleccionar_proyecto <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  # Permitir selección por índice o por nombre
  if (!is.null(indice_proyecto)) {
    proyecto <- datos[indice_proyecto, ]
  } else if (!is.null(nombre_proyecto)) {
    proyecto <- datos[datos$Proyecto == nombre_proyecto, ]
    if (nrow(proyecto) == 0) {
      stop("Proyecto no encontrado: ", nombre_proyecto)
    }
  } else {
    stop("Debe proporcionar un indice_proyecto o un nombre_proyecto")
  }
  
  return(proyecto)
}

# Definir el proyecto a analizar de forma consistente
indice_proyecto_seleccionado <- 21  # O el índice que prefieras
# nombre_proyecto_seleccionado <- "Nombre del Proyecto"  # Alternativa por nombre

# ----  9.1 VISUALIZACIÓN DEL TERMÓMETRO MEJORADO ---- 
crear_termometro <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  # Usar la función auxiliar para seleccionar el proyecto
  proyecto <- seleccionar_proyecto(datos, indice_proyecto, nombre_proyecto)
  
  valor <- proyecto$ivu
  categoria <- proyecto$ivu_categoria
  nombre <- proyecto$Proyecto
  
  colores <- c(
    "Muy bajo" = "#EF6558",  # Rojo
    "Bajo" = "#F8C579",      # Naranja
    "Medio" = "#F4E785",     # Amarillo
    "Alto" = "#68d192",      # Verde claro
    "Muy alto" = "#9B87F4"   # Verde oscuro
  )
  
  color <- colores[as.character(categoria)]
  
  # Empezar la escala desde un valor negativo para dar espacio a la etiqueta 0.0
  escala <- data.frame(
    y = seq(0, 1, 0.2),
    labels = c("0.0", "0.2", "0.4", "0.6", "0.8", "1.0"),
    categorias = c("", "Muy bajo", "Bajo", "Medio", "Alto", "Muy alto")
  )
  
  # Crear gráfico base
  p <- ggplot() +
    # Fondo del termómetro
    geom_rect(aes(xmin = 0.4, xmax = 0.6, ymin = 0, ymax = 1), 
              fill = "lightgrey", color = "black") +
    # Contenido del termómetro
    geom_rect(aes(xmin = 0.4, xmax = 0.6, ymin = 0, ymax = valor), 
              fill = color) +
    # Líneas de escala
    geom_segment(data = escala, 
                 aes(x = 0.38, y = y, xend = 0.62, yend = y), 
                 color = "black") +
    # Etiquetas de escala
    geom_text(data = escala, 
              aes(x = 0.35, y = y, label = labels), 
              hjust = 1) +
    # Etiquetas de categorías
    geom_text(data = escala[-1,], 
              aes(x = 0.7, y = y - 0.1, label = categorias), 
              hjust = 0) +
    # Valor actual y nombre del proyecto
    geom_text(aes(x = 0.5, y = 1.1, 
                  label = paste0("Proyecto: ", nombre, 
                                 "\nValor: ", round(valor, 2), 
                                 "\nCategoría: ", categoria,
                                 "\nAvenida más cercana: ", proyecto$nearest_avenue_name,
                                 "\nDistancia: ", round(proyecto$dist_to_avenue), "m")),
              fontface = "bold") +
    # Ajustes estéticos
    labs(title = "Termómetro de Valor por Ubicación",
         x = NULL, y = NULL) +
    theme_minimal() +
    theme(axis.text = element_blank(),
          axis.ticks = element_blank(),
          panel.grid = element_blank(),
          plot.title = element_text(hjust = 0.5, face = "bold", size = 14)) +
    # Extender el límite inferior para dar espacio a la etiqueta 0.0
    coord_cartesian(xlim = c(0, 1), ylim = c(-0.05, 1.25), expand = FALSE)
  
  return(p)
}

# Ejemplos de uso:
# Por índice (número de fila)
termometro_ejemplo <- crear_termometro(datos, indice_proyecto = indice_proyecto_seleccionado)
print(termometro_ejemplo)

# ----  9.2 GRÁFICO DE BARRAS DEL IVU POR MUNICIPIO ---- 
grafico_municipios <- ggplot(promedio_municipios, aes(x = reorder(Municipio, PromedioIVU), y = PromedioIVU)) +
  geom_bar(stat = "identity", fill = "#6366f1") +
  geom_text(aes(label = sprintf("%.2f", PromedioIVU)), vjust = -0.5) +
  labs(title = "Índice de Valor por Ubicación promedio por Municipio",
       x = "Municipio", y = "IVU Promedio") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  coord_cartesian(ylim = c(0, 1))

print(grafico_municipios)

# ----  9.3 DISTRIBUCIÓN DE CATEGORÍAS IVU ---- 
grafico_categorias <- ggplot(data.frame(Categoria = names(tabla_categorias), 
                                        Cantidad = as.numeric(tabla_categorias)), 
                             aes(x = Categoria, y = Cantidad, fill = Categoria)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = Cantidad), 
            vjust = -0.5, 
            family = "Inter",
            size = 16/3) + # En ggplot2, el tamaño se divide entre ~3 para convertir de pt a unidades de ggplot
  scale_fill_manual(values = c("Muy bajo" = "#EF6558", "Bajo" = "#F8C579", 
                               "Medio" = "#F4E785", "Alto" = "#68d192", 
                               "Muy alto" = "#9B87F4")) +
  labs(title = "Distribución de proyectos por categoría de IVU",
       x = "Categoría", y = "Número de proyectos") +
  theme_minimal() +
  theme(
    text = element_text(family = "Inter", size = 14),
    axis.title = element_text(family = "Inter", size = 13),
    axis.text = element_text(family = "Inter", size = 11),
    plot.title = element_text(family = "Inter", size = 18, face = "bold"),
    legend.text = element_text(family = "Inter", size = 12)
  )

print(grafico_categorias)

# 9.3b DISTRIBUCIÓN DE IVU POR SEGMENTO
# Crear boxplot de IVU por segmento
if (length(unique(datos$segmento_utilizado)) > 1) {
  ggplot(datos, aes(x = segmento_utilizado, y = ivu, fill = segmento_utilizado)) +
    geom_boxplot() +
    stat_summary(fun = mean, geom = "point", shape = 23, size = 3, fill = "white") +
    labs(title = "Distribución del IVU por segmento",
         x = "Segmento", y = "Índice de Valor por Ubicación",
         fill = "Segmento") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
}

# Comparación de contribuciones por categoría y segmento
contribuciones_por_segmento <- datos %>%
  filter(!is.na(segmento_utilizado)) %>%
  group_by(segmento_utilizado) %>%
  summarise(
    Índices = mean(contrib_indices, na.rm = TRUE),
    Cercanías = mean(contrib_cercanias, na.rm = TRUE),
    Cantidades = mean(contrib_cantidades, na.rm = TRUE),
    Vialidades = mean(contrib_vialidades, na.rm = TRUE),
    Otros = mean(contrib_otros, na.rm = TRUE)
  )

# Convertir a formato largo para ggplot
contribuciones_segmento_largo <- reshape2::melt(
  contribuciones_por_segmento, 
  id.vars = "segmento_utilizado",
  variable.name = "Categoría",
  value.name = "Contribución"
)

# Gráfico de barras apiladas
ggplot(contribuciones_segmento_largo, 
       aes(x = segmento_utilizado, y = Contribución, fill = Categoría)) +
  geom_bar(stat = "identity", position = "stack") +
  scale_fill_brewer(palette = "Set1") +
  labs(title = "Contribución de cada categoría al IVU por segmento",
       x = "Segmento", y = "Contribución al IVU") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# ----  9.4 RELACIÓN DE VARIABLES CON PRECIO POR M² ---- 
## 9.4.1 Relación entre IVU y precio por m²
grafico_precio_ivu <- ggplot(datos, aes(x = ivu, y = p_m2, color = ivu_categoria)) +
  geom_point(alpha = 0.7) +
  scale_color_manual(values = c("Muy bajo" = "#EF6558", "Bajo" = "#F8C579", 
                                "Medio" = "#F4E785", "Alto" = "#68d192", 
                                "Muy alto" = "#9B87F4")) +
  geom_smooth(method = "lm", se = TRUE, color = "#000000") +
  labs(title = "Relación entre IVU y Precio por m²",
       x = "Índice de Valor por Ubicación", 
       y = "Precio por m²",
       color = "Categoría") +
  theme_minimal() +
  scale_y_continuous(labels = scales::comma) +
  theme(
    text = element_text(family = "Inter", size = 16),
    axis.title = element_text(family = "Inter", size = 13),
    axis.text = element_text(family = "Inter", size = 11),
    plot.title = element_text(family = "Inter", size = 18, face = "bold"),
    legend.title = element_text(family = "Inter", size = 14, face = "bold"),
    legend.text = element_text(family = "Inter", size = 12)
  )

print(grafico_precio_ivu)

## 9.4.2 Relación entre IVU y absorcion
grafico_absorcion_ivu <- ggplot(datos, aes(x = ivu, y = absorcion, color = ivu_categoria)) +
  geom_point(alpha = 0.7) +
  scale_color_manual(values = c("Muy bajo" = "#EF6558", "Bajo" = "#F8C579", 
                                "Medio" = "#F4E785", "Alto" = "#68d192", 
                                "Muy alto" = "#9B87F4")) +
  geom_smooth(method = "lm", se = TRUE, color = "#000000") +
  labs(title = "Relación entre IVU y Absorción",
       x = "Índice de Valor por Ubicación", 
       y = "Absorción",
       color = "Categoría") +
  theme_minimal() +
  scale_y_continuous(labels = scales::comma) +
  coord_cartesian(ylim = c(0, 15)) +
  theme(
    text = element_text(family = "Inter", size = 16),
    axis.title = element_text(family = "Inter", size = 13),
    axis.text = element_text(family = "Inter", size = 11),
    plot.title = element_text(family = "Inter", size = 18, face = "bold"),
    legend.title = element_text(family = "Inter", size = 14, face = "bold"),
    legend.text = element_text(family = "Inter", size = 12)
  )

print(grafico_absorcion_ivu)

## 9.4.3 Relación entre cercanía a avenidas y precio
grafico_avenidas_precio <- ggplot(datos, 
                                  aes(x = dist_to_avenue, y = p_m2)) +
  geom_point(alpha = 0.7, color = "#666666") +
  geom_smooth(method = "loess", se = TRUE, color = "#000000") +
  labs(title = "Relación entre distancia a avenidas\nprincipales y precio por m²",
       x = "Distancia a avenida principal (m)", 
       y = "Precio por m²") +
  coord_cartesian(xlim = c(0, 1000)) +
  theme_minimal() +
  theme(
    text = element_text(family = "Inter", size = 16),
    axis.title = element_text(family = "Inter", size = 13),
    axis.text = element_text(family = "Inter", size = 11),
    plot.title = element_text(family = "Inter", size = 18, face = "bold", hjust = 0.5)
  ) +
  scale_y_continuous(labels = scales::comma)

print(grafico_avenidas_precio)

## 9.4.4 Relación entre accesibilidad vial e IVU
grafico_accesibilidad_ivu <- ggplot(datos, 
                                    aes(x = accesibilidad_vial, y = ivu, 
                                        color = factor(cerca_avenida_principal))) +
  geom_point(alpha = 0.7) +
  scale_color_manual(values = c("0" = "#666666", "1" = "#45A3A1"),
                     labels = c("0" = "Lejano", "1" = "Cercano")) +
  geom_smooth(method = "lm", se = TRUE, color = "#000000") +
  labs(title = "Relación entre accesibilidad vial e IVU",
       x = "Índice de accesibilidad vial", 
       y = "Índice de Valor por Ubicación",
       color = "Cercanía a avenida") +
  theme_minimal() + 
  theme(
    text = element_text(family = "Inter", size = 16),
    axis.title = element_text(family = "Inter", size = 13),
    axis.text = element_text(family = "Inter", size = 11),
    plot.title = element_text(family = "Inter", size = 18, face = "bold", hjust = 0.5),
    legend.title = element_text(family = "Inter", size = 14, face = "bold"),
    legend.text = element_text(family = "Inter", size = 12),
    legend.position = "bottom"
  )

print(grafico_accesibilidad_ivu)

## 9.4.5 Crear tabla con los 5 factores más importantes por segmento
factores_por_segmento <- lapply(names(pesos_por_segmento), function(segmento) {
  pesos_seg <- pesos_por_segmento[[segmento]]
  top_5 <- sort(pesos_seg, decreasing = TRUE)[1:5]
  data.frame(
    Segmento = segmento,
    Factor = names(top_5),
    Peso = as.numeric(top_5),
    Ranking = 1:5
  )
})
factores_por_segmento <- do.call(rbind, factores_por_segmento)
factores_por_segmento

## 9.4.6 Crear visualización comparativa
ggplot(factores_por_segmento, aes(x = reorder(Factor, -Peso), y = Peso, fill = Segmento)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Top 5 factores por segmento de mercado",
       x = "Factor", y = "Peso") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

## 9.4.7 Diferencias Específicas por Segmento
# Seleccionar factores interesantes para comparar entre segmentos
factores_interes <- c("cercania_esc_priv", "cercania_esc_pub", "cerca_parque_relevante", 
                      "accesibilidad_vial", "cercania_tienda_dept")

# Extraer pesos para estos factores por segmento
comparacion_factores <- lapply(names(pesos_por_segmento), function(segmento) {
  pesos_seg <- pesos_por_segmento[[segmento]]
  data.frame(
    Segmento = segmento,
    Factor = names(pesos_seg)[names(pesos_seg) %in% factores_interes],
    Peso = as.numeric(pesos_seg[names(pesos_seg) %in% factores_interes])
  )
})
comparacion_factores <- do.call(rbind, comparacion_factores)

# Visualizar comparación 
ggplot(comparacion_factores, aes(x = Segmento, y = Peso, fill = Factor)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Comparación de pesos de factores clave por segmento",
       x = "Segmento", y = "Peso") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# ----  9.5 GRÁFICO RADAR PARA UN PROYECTO ESPECÍFICO ---- 
crear_radar_proyecto <- function(datos, indice_proyecto = NULL, nombre_proyecto = NULL) {
  # Usar la función auxiliar para seleccionar el proyecto
  proyecto <- seleccionar_proyecto(datos, indice_proyecto, nombre_proyecto)
  
  # Seleccionar las variables para el gráfico radar
  vars <- c("indice_accesibilidad", "potencial_inversion", "indice_conveniencia", 
            "accesibilidad_vial", "ivu")
  valores <- as.numeric(proyecto[vars])
  nombres <- c("Accesibilidad", "Potencial Inversión", "Conveniencia", 
               "Accesibilidad Vial", "IVU")
  
  # Crear dataframe para plotly
  df <- data.frame(
    variable = nombres,
    valor = valores
  )
  
  # Ajustar para cerrar el polígono
  df <- rbind(df, df[1, ])
  
  # Crear gráfico radar
  plot_ly(
    r = df$valor,
    theta = df$variable,
    type = 'scatterpolar',
    fill = 'toself',
    fillcolor = 'rgba(99, 102, 241, 0.5)',
    line = list(color = 'rgb(99, 102, 241)')
  ) %>%
    layout(
      title = paste0("Índices para: ", proyecto$Proyecto),
      polar = list(
        radialaxis = list(
          visible = TRUE,
          range = c(0, 1)
        )
      )
    )
}

# Ejemplo para el proyecto seleccionado
radar_ejemplo <- crear_radar_proyecto(datos, indice_proyecto = indice_proyecto_seleccionado)
print(radar_ejemplo)

# ----  9.6 MAPA INTERACTIVO ---- 
crear_mapa <- function(datos) {
  # Definir paleta de colores por categoría IVU
  pal <- colorFactor(
    palette = c("#EF6558", "#F8C579", "#F4E785", "#68d192", "#9B87F4"),
    domain = datos$ivu_categoria
  )
  
  # Estilo CSS para usar Inter en los popups
  popup_style <- "font-family: 'Inter', sans-serif; font-size: 16px;"
  
  # Crear el mapa
  leaflet(datos) %>%
    addTiles() %>%  # Añadir mapa base de OpenStreetMap
    addCircleMarkers(
      # Reemplazar con tus columnas de lat/lon
      lng = ~longitud,
      lat = ~latitud,
      radius = 8,
      color = ~pal(ivu_categoria),
      stroke = FALSE,
      fillOpacity = 1,
      popup = ~paste0(
        "<div style='", popup_style, "'>",
        "<b>", Proyecto, "</b><br>",
        "Desarrollador: ", Desarrollador, "<br>",
        "IVU: ", round(ivu, 2), " (", ivu_categoria, ")<br>",
        "Precio/m²: $", format(p_m2, big.mark = ",", scientific = FALSE),
        "</div>"
      )
    ) %>%
    addLegend(
      position = "bottomright",
      pal = pal,
      values = ~ivu_categoria,
      title = "Categoría IVU",
      opacity = 0.8
    ) %>%
    # Agregar CSS personalizado para cambiar la fuente de la leyenda
    htmlwidgets::onRender("
      function(el, x) {
        // Aplicar estilo a la leyenda
        var legends = document.querySelectorAll('.info.legend');
        legends.forEach(function(legend) {
          legend.style.fontFamily = 'Inter, sans-serif';
          legend.style.fontSize = '12px';
        });
        
        // Aplicar estilo al título de la leyenda
        var legendTitles = document.querySelectorAll('.info.legend .legend-title');
        legendTitles.forEach(function(title) {
          title.style.fontFamily = 'Inter, sans-serif';
          title.style.fontSize = '14px';
          title.style.fontWeight = 'bold';
        });
        
        // Aplicar estilo a los items de la leyenda
        var legendItems = document.querySelectorAll('.info.legend .legend-item');
        legendItems.forEach(function(item) {
          item.style.fontFamily = 'Inter, sans-serif';
          item.style.fontSize = '16px';
        });
      }
    ")
}

mapa <- crear_mapa(datos)
mapa

# ----  9.7 NUEVAS VISUALIZACIONES: ANÁLISIS DE FACTORES DEL IVU ---- 

# 9.7.1 Radar de factores individuales que más contribuyen al IVU
crear_radar_factores <- function(datos, contribuciones, indice_proyecto = NULL, nombre_proyecto = NULL) {
  # Usar la función auxiliar para seleccionar el proyecto
  proyecto <- seleccionar_proyecto(datos, indice_proyecto, nombre_proyecto)
  indice <- if (!is.null(indice_proyecto)) indice_proyecto else which(datos$Proyecto == nombre_proyecto)
  
  # Extraer contribuciones para este proyecto
  contribuciones_proyecto <- contribuciones[indice, ]
  
  # Calcular porcentajes de contribución
  total_contrib <- sum(contribuciones_proyecto, na.rm = TRUE)
  contribuciones_pct <- contribuciones_proyecto / total_contrib * 100
  
  # Crear un dataframe con las contribuciones
  df_contrib <- data.frame(
    factor = names(contribuciones_pct),
    contribucion = as.numeric(contribuciones_pct),
    stringsAsFactors = FALSE
  )
  
  # Eliminar factores con contribución cero
  df_contrib <- df_contrib[df_contrib$contribucion > 0, ]
  
  # Ordenar por contribución (descendente)
  df_contrib <- df_contrib[order(-df_contrib$contribucion), ]
  
  # Tomar los 10 principales contribuyentes para mayor claridad
  top_n <- 10
  df_top <- df_contrib[1:min(top_n, nrow(df_contrib)), ]
  
  # Crear etiquetas más legibles
  etiquetas <- c(
    "indice_accesibilidad" = "Accesibilidad",
    "potencial_inversion" = "Potencial Inversión",
    "indice_conveniencia" = "Conveniencia",
    "cercania_hospital" = "Hospital",
    "cercania_esc_priv" = "Escuela Privada",
    "cercania_esc_pub" = "Escuela Pública",
    "cercania_universidad" = "Universidad",
    "cercania_super" = "Supermercado",
    "cercania_restau" = "Restaurante",
    "cercania_oficina" = "Oficina",
    "cercania_tienda_dept" = "Tienda Depto.",
    "cerca_avenida_principal" = "Av. Principal",
    "cercania_avenida" = "Av. General",
    "cercania_avenida_arterial" = "Av. Arterial",
    "cercania_avenida_secundaria" = "Av. Secundaria",
    "accesibilidad_vial" = "Acc. Vial",
    "cantidad_hospital_1km" = "Cant. Hospitales",
    "cantidad_esc_priv_1km" = "Cant. Esc. Priv.",
    "cantidad_esc_pub_1km" = "Cant. Esc. Pub.",
    "cantidad_universidad_1km" = "Cant. Univs.",
    "cantidad_super_1km" = "Cant. Supers",
    "cantidad_restau_1km" = "Cant. Restaus.",
    "cantidad_oficina_1km" = "Cant. Oficinas",
    "cantidad_tienda_dept_1km" = "Cant. Tiendas",
    "cerca_parque_relevante" = "Parque Relevante",
    "predominio_hogares_propios" = "Hogares Propios",
    "alto_crecimiento" = "Alto Crecimiento",
    "alta_densidad_pob" = "Alta Densidad Pob.",
    "alta_densidad_educativa" = "Densidad Educativa",
    "alta_densidad_comercial" = "Densidad Comercial",
    "alto_entorno_laboral" = "Entorno Laboral"
  )
  
  # Aplicar etiquetas donde estén disponibles
  df_top$etiqueta <- sapply(df_top$factor, function(f) {
    if (f %in% names(etiquetas)) etiquetas[f] else f
  })
  
  # Agregar una fila al final que duplique la primera fila para cerrar el polígono
  radar_data <- rbind(df_top, df_top[1, ])
  
  # Crear el gráfico de radar con plotly
  p <- plot_ly(
    r = radar_data$contribucion,
    theta = radar_data$etiqueta,
    type = 'scatterpolar',
    mode = 'lines+markers',
    fill = 'toself',
    fillcolor = 'rgba(99, 102, 241, 0.5)',
    line = list(color = 'rgb(99, 102, 241)')
  ) %>%
    layout(
      title = paste0("Factores con mayor contribución al IVU de ", proyecto$Proyecto),
      polar = list(
        radialaxis = list(
          visible = TRUE,
          range = c(0, max(radar_data$contribucion) * 1.1),
          ticksuffix = "%"
        )
      )
    )
  
  return(p)
}

# 9.7.2 Gráfico de fortalezas y debilidades vs promedio
crear_grafico_fortalezas_debilidades <- function(datos, contribuciones, indice_proyecto = NULL, nombre_proyecto = NULL) {
  # Usar la función auxiliar para seleccionar el proyecto
  proyecto <- seleccionar_proyecto(datos, indice_proyecto, nombre_proyecto)
  indice <- if (!is.null(indice_proyecto)) indice_proyecto else which(datos$Proyecto == nombre_proyecto)
  
  # Calcular el promedio de contribuciones para todos los proyectos
  contribuciones_promedio <- colMeans(contribuciones, na.rm = TRUE)
  
  # Extraer contribuciones para este proyecto
  contribuciones_proyecto <- contribuciones[indice, ]
  
  # Calcular diferencias relativas (positivo = fortaleza, negativo = debilidad)
  diferencias <- contribuciones_proyecto - contribuciones_promedio
  
  # Crear un dataframe con las diferencias
  df_diferencias <- data.frame(
    factor = names(diferencias),
    diferencia = as.numeric(diferencias),
    stringsAsFactors = FALSE
  )
  
  # Eliminar factores con diferencia cero
  df_diferencias <- df_diferencias[df_diferencias$diferencia != 0, ]
  
  # Ordenar por valor absoluto de la diferencia (descendente)
  df_diferencias$abs_diferencia <- abs(df_diferencias$diferencia)
  df_diferencias <- df_diferencias[order(-df_diferencias$abs_diferencia), ]
  
  # Tomar los principales factores para mayor claridad
  top_n <- 10
  df_top <- df_diferencias[1:min(top_n, nrow(df_diferencias)), ]
  
  # Usar las mismas etiquetas que en la función anterior
  etiquetas <- c(
    "indice_accesibilidad" = "Accesibilidad",
    "potencial_inversion" = "Potencial Inversión",
    "indice_conveniencia" = "Conveniencia",
    "cercania_hospital" = "Hospital",
    "cercania_esc_priv" = "Escuela Privada",
    "cercania_esc_pub" = "Escuela Pública",
    "cercania_universidad" = "Universidad",
    "cercania_super" = "Supermercado",
    "cercania_restau" = "Restaurante",
    "cercania_oficina" = "Oficina",
    "cercania_tienda_dept" = "Tienda Depto.",
    "cerca_avenida_principal" = "Av. Principal",
    "cercania_avenida" = "Av. General",
    "cercania_avenida_arterial" = "Av. Arterial",
    "cercania_avenida_secundaria" = "Av. Secundaria",
    "accesibilidad_vial" = "Acc. Vial",
    "cantidad_hospital_1km" = "Cant. Hospitales",
    "cantidad_esc_priv_1km" = "Cant. Esc. Priv.",
    "cantidad_esc_pub_1km" = "Cant. Esc. Pub.",
    "cantidad_universidad_1km" = "Cant. Univs.",
    "cantidad_super_1km" = "Cant. Supers",
    "cantidad_restau_1km" = "Cant. Restaus.",
    "cantidad_oficina_1km" = "Cant. Oficinas",
    "cantidad_tienda_dept_1km" = "Cant. Tiendas",
    "cerca_parque_relevante" = "Parque Relevante",
    "predominio_hogares_propios" = "Hogares Propios",
    "alto_crecimiento" = "Alto Crecimiento",
    "alta_densidad_pob" = "Alta Densidad Pob.",
    "alta_densidad_educativa" = "Densidad Educativa",
    "alta_densidad_comercial" = "Densidad Comercial",
    "alto_entorno_laboral" = "Entorno Laboral"
  )
  
  # Aplicar etiquetas donde estén disponibles
  df_top$etiqueta <- sapply(df_top$factor, function(f) {
    if (f %in% names(etiquetas)) etiquetas[f] else f
  })
  
  # Definir colores para fortalezas y debilidades
  colores <- ifelse(df_top$diferencia > 0, "#68d192", "#EF6558")  # Verde para fortalezas, rojo para debilidades
  
  # Crear gráfico de barras para fortalezas y debilidades
  p <- plot_ly(df_top, x = ~etiqueta, y = ~diferencia, type = 'bar',
               marker = list(color = colores)) %>%
    layout(
      title = paste0("Fortalezas y Debilidades de ", proyecto$Proyecto, " vs. Promedio"),
      xaxis = list(title = ""),
      yaxis = list(title = "Diferencia vs. Promedio"),
      margin = list(b = 120)
    )
  
  return(p)
}

# 9.7.3 Radar de contribución por categorías
crear_radar_categorias <- function(datos, contribuciones, factores, indice_proyecto = NULL, nombre_proyecto = NULL) {
  # Usar la función auxiliar para seleccionar el proyecto
  proyecto <- seleccionar_proyecto(datos, indice_proyecto, nombre_proyecto)
  indice <- if (!is.null(indice_proyecto)) indice_proyecto else which(datos$Proyecto == nombre_proyecto)
  
  # Definir las categorías
  categorias <- list(
    "Índices" = factores$indices,
    "Cercanías" = factores$cercanias,
    "Cantidades" = factores$cantidades,
    "Vialidades" = factores$vialidades,
    "Otros" = factores$otros
  )
  
  # Calcular la contribución por categoría
  contrib_categorias <- numeric(length(categorias))
  names(contrib_categorias) <- names(categorias)
  
  for (i in 1:length(categorias)) {
    cat_nombre <- names(categorias)[i]
    cat_factores <- categorias[[i]]
    
    # Filtrar solo los factores que existen en las contribuciones
    cat_factores <- intersect(cat_factores, colnames(contribuciones))
    
    # Sumar contribuciones para esta categoría
    if (length(cat_factores) > 0) {
      contrib_categorias[i] <- sum(contribuciones[indice, cat_factores], na.rm = TRUE)
    }
  }
  
  # Calcular porcentajes
  total_contrib <- sum(contrib_categorias, na.rm = TRUE)
  contrib_pct <- contrib_categorias / total_contrib * 100
  
  # Crear dataframe para plotly
  df <- data.frame(
    categoria = names(contrib_pct),
    porcentaje = as.numeric(contrib_pct)
  )
  
  # Ordenar por contribución (descendente)
  df <- df[order(-df$porcentaje), ]
  
  # Agregar una fila al final que duplique la primera fila para cerrar el polígono
  df <- rbind(df, df[1, ])
  
  # Crear el gráfico de radar con plotly
  p <- plot_ly(
    r = df$porcentaje,
    theta = df$categoria,
    type = 'scatterpolar',
    mode = 'lines+markers',
    fill = 'toself',
    fillcolor = 'rgba(99, 102, 241, 0.5)',
    line = list(color = 'rgb(99, 102, 241)')
  ) %>%
    layout(
      title = paste0("Contribución por Categoría al IVU de ", proyecto$Proyecto),
      polar = list(
        radialaxis = list(
          visible = TRUE,
          range = c(0, max(df$porcentaje) * 1.1),
          ticksuffix = "%"
        )
      )
    )
  
  return(p)
}

# Crear las nuevas visualizaciones para el proyecto seleccionado
radar_factores <- crear_radar_factores(datos, contribuciones, indice_proyecto = indice_proyecto_seleccionado)
print(radar_factores)

grafico_fortalezas <- crear_grafico_fortalezas_debilidades(datos, contribuciones, indice_proyecto = indice_proyecto_seleccionado)
print(grafico_fortalezas)

radar_categorias <- crear_radar_categorias(datos, contribuciones, factores, indice_proyecto = indice_proyecto_seleccionado)
print(radar_categorias)

# ---- 10. GUARDAR RESULTADOS ----
# Guardar el dataframe con el IVU calculado
write.csv(datos, "proyectos_con_ivu.csv", row.names = FALSE)

# Guardar un resumen de los pesos utilizados por segmento
pesos_summary <- lapply(names(pesos_por_segmento), function(segmento) {
  top_10 <- sort(pesos_por_segmento[[segmento]], decreasing = TRUE)[1:10]
  data.frame(
    Segmento = segmento,
    Factor = names(top_10),
    Peso = as.numeric(top_10),
    Ranking = 1:length(top_10)
  )
})
pesos_summary <- do.call(rbind, pesos_summary)
write.csv(pesos_summary, "pesos_por_segmento_top10.csv", row.names = FALSE)

# Si estás utilizando RMarkdown, puedes generar un informe HTML
if (requireNamespace("rmarkdown", quietly = TRUE)) {
  cat("Generando informe HTML...\n")
  # Aquí podrías crear un template de Rmd y renderizarlo con los datos
}



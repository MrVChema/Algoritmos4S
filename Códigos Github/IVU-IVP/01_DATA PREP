# SCRIPT 1: PREPARACI√ìN Y TRANSFORMACI√ìN DE DATOS
# Flujo Optimizado IVU - Consolida Scripts 1 y 2 del flujo original

# ---- 1. CONFIGURACI√ìN INICIAL ----
cat("üöÄ INICIANDO SCRIPT 1: PREPARACI√ìN Y TRANSFORMACI√ìN DE DATOS\n")
cat("=============================================================\n\n")

# Limpiar el entorno y cargar librer√≠as necesarias
rm(list = ls())

library(sf)
library(lwgeom)
library(readr)
library(readxl)
library(dplyr)
library(janitor)
library(tidyr)
library(tibble)
library(leaflet)
library(stringr)
library(geosphere) # Para c√°lculos de distancia geoespacial
library(purrr)

# Desactivar el uso de s2 (opcional, seg√∫n complejidad de las geometr√≠as)
sf::sf_use_s2(FALSE)

# Establecer directorio de trabajo
setwd('/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[02] DATOS/[00] BASE INTEGRADA/OUTPUT_BASE INTEGRADA_IVU-IVP')

cat("‚úÖ Configuraci√≥n inicial completada\n")

# CAPTURAR SALIDA DE CONSOLA
# Crear archivo para capturar salida y warnings
timestamp <- format(Sys.time(), "%Y%m%d_%H%M%S")
archivo_log <- paste0("script1_log_", timestamp, ".txt")

# Redirigir salida a archivo
sink(archivo_log, append = FALSE, split = TRUE)  # split=TRUE muestra en consola Y archivo

# ---- 2. CARGA DE DATOS PRINCIPALES ----
cat("\nüìä CARGANDO DATOS PRINCIPALES...\n")

## 2.1. Archivos CSV y XLSX
### Proyectos (vivienda vertical)
proyectos <- read_csv('/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[02] DATOS/[01] PROYECTOS/[01] VIVIENDA VERTICAL/Proyectos Integrados_ZMM.csv')

### Variables de √°reas verdes y datos demogr√°ficos
verdes <- read_xlsx('/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[02] DATOS/[03] VARIABLES/[01] AREAS VERDES/AreasVerdes_Zona_V2.xlsx')
demograficos <- read_xlsx('/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[02] DATOS/[03] VARIABLES/[03] DEMOGRAFICOS/Demograficos_AGEBS.xlsx')

### Datos de amenidades
amenidades <- read_excel('/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[02] DATOS/[03] VARIABLES/[06] FUNCIONALIDAD Y AMENIDADES/Qlik Sense - Tabla Amenidades_ Desglose de Amenidades x Proy... MTY.xlsx')

cat("‚úÖ Datos principales cargados\n")

# ---- 3. CARGA DE EQUIPAMIENTOS (DENUE) ----
cat("\nüè• CARGANDO DATOS DE EQUIPAMIENTOS...\n")

# Cargar datos de equipamientos
hospitales <- read.csv('/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[02] DATOS/[03] VARIABLES/[02] EQUIPAMIENTO/DENUE 2024/Hospitales/Hospitales.csv', encoding = "UTF-8")
escuelas_privadas <- read.csv('/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[02] DATOS/[03] VARIABLES/[02] EQUIPAMIENTO/DENUE 2024/Escuelas Privadas/Escuelas Privadas.csv', encoding = "UTF-8")
escuelas_publicas <- read.csv('/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[02] DATOS/[03] VARIABLES/[02] EQUIPAMIENTO/DENUE 2024/Escuelas P√∫blicas/Escuelas P√∫blicas.csv', encoding = "UTF-8")
universidades <- read.csv('/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[02] DATOS/[03] VARIABLES/[02] EQUIPAMIENTO/DENUE 2024/Universidades/Universidades.csv', encoding = "UTF-8")
supermercados <- read.csv('/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[02] DATOS/[03] VARIABLES/[02] EQUIPAMIENTO/DENUE 2024/Supermercados/Supermercado.csv', encoding = "UTF-8")
restaurantes <- read.csv('/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[02] DATOS/[03] VARIABLES/[02] EQUIPAMIENTO/DENUE 2024/Restaurantes/Restaurantes.csv', encoding = "UTF-8")
oficinas <- read.csv('/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[02] DATOS/[03] VARIABLES/[02] EQUIPAMIENTO/DENUE 2024/Oficinas/Oficinas.csv', encoding = "UTF-8")
tiendas_departamentales <- read.csv('/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[02] DATOS/[03] VARIABLES/[02] EQUIPAMIENTO/DENUE 2024/Tiendas departamentales/Tiendas departamentales.csv', encoding = "UTF-8")

# Asegurar que los equipamientos tienen coordenadas v√°lidas
equipamientos_list <- list(
  hospitales = hospitales %>% filter(!is.na(latitud) & !is.na(longitud)),
  escuelas_privadas = escuelas_privadas %>% filter(!is.na(latitud) & !is.na(longitud)),
  escuelas_publicas = escuelas_publicas %>% filter(!is.na(latitud) & !is.na(longitud)),
  universidades = universidades %>% filter(!is.na(latitud) & !is.na(longitud)),
  supermercados = supermercados %>% filter(!is.na(latitud) & !is.na(longitud)),
  restaurantes = restaurantes %>% filter(!is.na(latitud) & !is.na(longitud)),
  oficinas = oficinas %>% filter(!is.na(latitud) & !is.na(longitud)),
  tiendas_departamentales = tiendas_departamentales %>% filter(!is.na(latitud) & !is.na(longitud))
)

cat("‚úÖ Equipamientos cargados\n")

# ---- 4. CARGA DE DATOS ESPACIALES (KML) ----
cat("\nüó∫Ô∏è  CARGANDO DATOS ESPACIALES...\n")

## 4.1. Pol√≠gonos NSE
nse_kml_path <- '/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[02] DATOS/[02] KML_KMZ/[01] NSE/NSE-Monterrey.kml'
nse_layers <- st_layers(nse_kml_path)

### Leer todas las capas del KML de NSE y combinarlas
nse_data_list <- lapply(nse_layers$name, function(x) {
  st_read(nse_kml_path, layer = x)
})
nse_data <- do.call(rbind, nse_data_list)

## 4.2. Pol√≠gonos de Zonas REDI
zonas_redi <- st_read('/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[02] DATOS/[02] KML_KMZ/[03] ZONAS REDI/ZMM_REDI_2024.kml')

## 4.3. Pol√≠gonos de parques importantes (KML)
parques_kml <- st_read('/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[02] DATOS/[03] VARIABLES/[01] AREAS VERDES/Parques_Peso.kml')

#### Si en el KML de parques la columna que identifica el parque se llama "Name", ren√≥mbrala a "nombre"
if("Name" %in% names(parques_kml)){
  parques_kml <- parques_kml %>% rename(nombre = Name)
}

## 4.4. Cargar archivo KML de avenidas
avenidas_kml_path <- '/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[02] DATOS/[03] VARIABLES/[05] VIALIDAD/VIALIDADES_PROCESADAS/avenidas_clasificadas.kml'
avenidas_layers <- st_layers(avenidas_kml_path)

## Leer todas las capas del KML de avenidas y combinarlas
avenidas_data_list <- lapply(avenidas_layers$name, function(x) {
  st_read(avenidas_kml_path, layer = x)
})
avenidas_data <- do.call(rbind, avenidas_data_list)

## Cambiar nombre de variable Name
avenidas_data <- avenidas_data %>%
  rename(nombre_normalizado = Name)

## 4.5. Cargar clasificaci√≥n de avenidas desde CSV
clasificacion_avenidas <- read_csv('/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[02] DATOS/[03] VARIABLES/[05] VIALIDAD/VIALIDADES_PROCESADAS/clasificacion_avenidas.csv')

cat("‚úÖ Datos espaciales cargados\n")

# ---- 5. FUNCIONES AUXILIARES ----
cat("\nüîß CONFIGURANDO FUNCIONES AUXILIARES...\n")

# 5.1 Funci√≥n mejorada para convertir coordenadas DMS a decimal
convertir_dms <- function(coord_str) {
  # Si ya es num√©rico, devolverlo directamente
  if(is.numeric(coord_str)) return(coord_str)
  
  # Detectar si es formato decimal como texto
  if(grepl("^-?[0-9]+\\.[0-9]+$", coord_str)) {
    return(as.numeric(coord_str))
  }
  
  # Extraer direcci√≥n (N, S, E, W)
  direccion <- NA
  if(grepl("[NSEW]", coord_str, ignore.case = TRUE)) {
    direccion <- toupper(regmatches(coord_str, regexpr("[NSEW]", coord_str, ignore.case = TRUE)))
  }
  
  # Para formato con s√≠mbolos: 25¬∞40'0.13"N
  if(grepl("¬∞|'|\"", coord_str)) {
    # Extrae n√∫meros usando expresiones regulares
    grados <- as.numeric(regmatches(coord_str, regexpr("^-?[0-9]+(?=¬∞)", coord_str, perl = TRUE)))
    minutos <- as.numeric(regmatches(coord_str, regexpr("(?<=¬∞)[0-9]+(?=')", coord_str, perl = TRUE)))
    
    # Extrae segundos - puede ser opcional
    segundos_match <- regexpr("(?<=')[0-9]+(\\.[0-9]+)?(?=\")", coord_str, perl = TRUE)
    segundos <- if(segundos_match > 0) {
      as.numeric(regmatches(coord_str, segundos_match))
    } else {
      0
    }
  } else if(grepl("[0-9]+ [0-9]+ [0-9]+", coord_str)) {
    # Para formato con espacios: 25 40 0.13 N
    partes <- strsplit(gsub("[^0-9\\. NSEW-]", "", coord_str), " ")[[1]]
    partes <- partes[partes != ""]
    
    grados <- as.numeric(partes[1])
    minutos <- if(length(partes) > 1) as.numeric(partes[2]) else 0
    segundos <- if(length(partes) > 2) as.numeric(partes[3]) else 0
  } else {
    # Si no coincide con ning√∫n formato conocido, intentar convertir directamente
    return(as.numeric(gsub("[^0-9\\.-]", "", coord_str)))
  }
  
  # Verificar que los valores son razonables
  if(is.na(grados)) {
    warning("No se pudieron extraer los grados de: ", coord_str)
    return(NA)
  }
  
  if(is.na(minutos)) minutos <- 0
  if(is.na(segundos)) segundos <- 0
  
  # Aplicar la f√≥rmula de conversi√≥n DMS a decimal
  decimal <- grados + minutos/60 + segundos/3600
  
  # Ajustar el signo seg√∫n la direcci√≥n
  if(!is.na(direccion) && direccion %in% c("S", "W")) decimal <- -decimal
  
  # Para longitudes oeste, asegurar que sea negativo
  if(abs(decimal) > 90 && decimal > 0) {
    # Probablemente es una longitud oeste sin signo negativo
    decimal <- -decimal
  }
  
  return(decimal)
}

# 5.2 Funci√≥n para calcular distancias a equipamientos y crear variables dicot√≥micas
calcular_distancias_equipamientos <- function(proyectos_sf, equipamientos_df, nombre) {
  
  # Asegurar que proyectos_sf sea un objeto sf
  if(!inherits(proyectos_sf, "sf")) {
    stop("El objeto proyectos_sf debe ser un objeto sf.")
  }
  
  # Convertir coordenadas a numericas por si acaso
  equipamientos_df$latitud <- as.numeric(equipamientos_df$latitud)
  equipamientos_df$longitud <- as.numeric(equipamientos_df$longitud)
  
  # Filtrar equipamientos con coordenadas v√°lidas
  equipamientos_df <- equipamientos_df %>% 
    filter(!is.na(latitud) & !is.na(longitud))
  
  # Inicializar columnas de resultado
  proyectos_sf[[paste0("dist_", nombre)]] <- NA_real_
  proyectos_sf[[paste0("cercania_", nombre)]] <- NA_real_
  proyectos_sf[[paste0("cantidad_", nombre, "_1km")]] <- 0
  
  # Convertir equipamientos a objeto sf para c√°lculos espaciales m√°s eficientes
  equipamientos_sf <- st_as_sf(equipamientos_df, 
                               coords = c("longitud", "latitud"), 
                               crs = 4326)
  
  # Para cada proyecto, calcular distancia al equipamiento m√°s cercano
  for (i in 1:nrow(proyectos_sf)) {
    # Extraer geometr√≠a del proyecto
    punto_proyecto <- proyectos_sf[i,]
    
    # Calcular distancias (usando st_distance es m√°s eficiente para objetos sf)
    distancias <- st_distance(punto_proyecto, equipamientos_sf)
    distancias_m <- as.numeric(distancias)
    
    # Distancia al m√°s cercano
    if (length(distancias_m) > 0) {
      min_dist <- min(distancias_m, na.rm = TRUE)
      proyectos_sf[[paste0("dist_", nombre)]][i] <- min_dist
      proyectos_sf[[paste0("cercania_", nombre)]][i] <- ifelse(min_dist <= 1000, 1, 0)
      
      # Contar cantidad a menos de 1km
      proyectos_sf[[paste0("cantidad_", nombre, "_1km")]][i] <- sum(distancias_m <= 1000, na.rm = TRUE)
    }
  }
  
  return(proyectos_sf)
}

# 5.3 Funci√≥n para normalizar valores entre 0 y 1
normalizar <- function(valores) {
  valores_numericos <- as.numeric(valores)
  valores_validos <- valores_numericos[!is.na(valores_numericos)]
  
  if (length(valores_validos) == 0) return(rep(0, length(valores)))
  
  min_val <- min(valores_validos)
  max_val <- max(valores_validos)
  
  # Si todos los valores son iguales, devolver 0.5 para evitar divisi√≥n por cero
  if (max_val == min_val) {
    resultado <- rep(0, length(valores))
    resultado[!is.na(valores_numericos)] <- 0.5
    return(resultado)
  }
  
  # Normalizar valores
  resultado <- rep(0, length(valores))
  resultado[!is.na(valores_numericos)] <- (valores_numericos[!is.na(valores_numericos)] - min_val) / (max_val - min_val)
  return(resultado)
}

cat("‚úÖ Funciones auxiliares configuradas\n")

# ---- 6. CONFIGURACI√ìN DE NUEVOS PROYECTOS ----
cat("\nüÜï CONFIGURANDO PAR√ÅMETROS PARA NUEVOS PROYECTOS...\n")

# ----- Control de evaluaci√≥n de nuevos proyectos -----
evaluar_nuevo_proyecto <- FALSE  # Cambiar a TRUE cuando se quiera evaluar un nuevo proyecto

# Datos del nuevo proyecto - SOLO SE USAR√ÅN SI evaluar_nuevo_proyecto = TRUE
nombre_proyecto <- "Proyecto: Frida Chilaquiles"
desarrollador <- "Desarrollador XYZ"
municipio <- "San Pedro Garza Garc√≠a"

# Coordenadas en formato DMS
latitud_dms <- "25¬∞39'24.18\"N"
longitud_dms <- "100¬∞21'50.10\"W"

# Definir valores predeterminados para el centro del mapa
# (coordenadas aproximadas del centro de Monterrey)
lat_decimal <- 25.6866  # Centro de Monterrey
lon_decimal <- -100.3161  # Centro de Monterrey

# Solo procesar el nuevo proyecto si la bandera est√° activada
if(evaluar_nuevo_proyecto) {
  # Convertir coordenadas manualmente para mayor seguridad
  lat_decimal <- convertir_dms(latitud_dms)
  lon_decimal <- convertir_dms(longitud_dms)
  
  # Verificaci√≥n de coordenadas
  coords_correctas <- lat_decimal >= -90 && lat_decimal <= 90 && 
    lon_decimal >= -180 && lon_decimal <= 180
  
  if(!coords_correctas) {
    # Si la conversi√≥n autom√°tica fall√≥, usar coordenadas conocidas para Monterrey
    cat("ADVERTENCIA: ¬°Conversi√≥n de coordenadas incorrecta! Usando coordenadas aproximadas para San Pedro Garza Garc√≠a\n")
    lat_decimal <- 25.6667  # Aproximado para San Pedro Garza Garc√≠a
    lon_decimal <- -100.4167  # Aproximado para San Pedro Garza Garc√≠a
  }
  
  # Crear dataframe para el nuevo proyecto
  nuevo_proyecto <- data.frame(
    Proyecto = nombre_proyecto,
    Desarrollador = desarrollador,
    Municipio = municipio,
    Latitud = lat_decimal,
    Longitud = lon_decimal,
    Estatus = "Nuevo"
  )
  
  # A√±adir otras columnas existentes en proyectos con NA
  cols_faltantes <- setdiff(names(proyectos), names(nuevo_proyecto))
  for(col in cols_faltantes) {
    nuevo_proyecto[[col]] <- NA
  }
  
  # Integrar el nuevo proyecto a la base existente
  proyectos <- bind_rows(proyectos, nuevo_proyecto)
  
  cat("Nuevo proyecto a√±adido:", nombre_proyecto, "\n")
} else {
  cat("Evaluaci√≥n de nuevos proyectos desactivada. Cambiar 'evaluar_nuevo_proyecto' a TRUE para activar.\n")
}

# ---- 7. TRANSFORMACI√ìN DE DATOS A OBJETOS ESPACIALES ----
cat("\nüó∫Ô∏è  TRANSFORMANDO DATOS A OBJETOS ESPACIALES...\n")

## 7.1. Proyectos: Se asume que las columnas "Longitud" y "Latitud" contienen las coordenadas (WGS84)
proyectos_sf <- st_as_sf(proyectos,
                         coords = c("Longitud", "Latitud"),
                         crs = 4326,
                         remove = FALSE)

# Verificar que los datos espaciales tienen puntos v√°lidos
cat("N√∫mero de proyectos:", nrow(proyectos_sf), "\n")

## 7.2. √Åreas verdes: Usan las columnas "longitud" y "latitud" (en min√∫scula)
verdes_sf <- st_as_sf(verdes,
                      coords = c("longitud", "latitud"),
                      crs = 4326,
                      remove = FALSE)

## 7.3. Datos demogr√°ficos: La columna "geometry" est√° en formato WKT
demograficos_sf <- demograficos %>%
  mutate(geometry = st_as_sfc(geometry, crs = 4326)) %>%
  st_as_sf()

## 7.4. Renombrar columnas para evitar conflictos en las uniones espaciales
nse_data_renamed <- nse_data %>%
  rename(nse_name = Name,
         nse_description = Description)

zonas_redi_renamed <- zonas_redi %>%
  rename(zona_name = Name,
         zona_description = Description)

## 7.5. Preparar datos de avenidas
# Unir los datos de clasificaci√≥n a las geometr√≠as
avenidas_data <- avenidas_data %>%
  left_join(clasificacion_avenidas, by = "nombre_normalizado")

# Verificar que las geometr√≠as est√°n bien formadas
avenidas_data <- st_make_valid(avenidas_data)

# Asegurarse que el CRS est√° en WGS84
avenidas_data <- st_transform(avenidas_data, 4326)

cat("‚úÖ Transformaci√≥n a objetos espaciales completada\n")

# ---- 8. UNIONES ESPACIALES E INTEGRACI√ìN ----
cat("\nüîó EJECUTANDO UNIONES ESPACIALES...\n")

## 8.1. Calcular variables demogr√°ficas en radio de 1 km
cat("\nüîß PROCESANDO VARIABLES DEMOGR√ÅFICAS CON LIMPIEZA ROBUSTA...\n")

# Funci√≥n robusta para limpiar variables num√©ricas demogr√°ficas
limpiar_variable_numerica <- function(x, nombre_variable = "variable") {
  # Convertir a character primero
  x_char <- as.character(x)
  
  # Contar valores originales
  total_original <- length(x_char)
  na_original <- sum(is.na(x_char))
  
  # Paso 1: Manejar valores especiales
  x_limpio <- x_char
  x_limpio[is.na(x_limpio)] <- "0"  # NAs a 0
  x_limpio[trimws(x_limpio) == ""] <- "0"  # Vac√≠os a 0
  x_limpio[x_limpio %in% c("NULL", "null", "N/A", "n/a", "#N/A")] <- "0"  # Valores especiales a 0
  
  # Paso 2: Limpiar caracteres no num√©ricos pero conservar n√∫meros, puntos, comas y signos
  x_limpio <- gsub("[^0-9.,-]", "", x_limpio)
  
  # Paso 3: Manejar comas como separadores de miles (ej: "1,234" -> "1234")
  x_limpio <- gsub(",", "", x_limpio)
  
  # Paso 4: Manejar valores vac√≠os despu√©s de limpieza
  x_limpio[x_limpio == "" | x_limpio == "." | x_limpio == "-"] <- "0"
  
  # Paso 5: Convertir a num√©rico con manejo de errores
  x_numerico <- suppressWarnings(as.numeric(x_limpio))
  
  # Paso 6: Reemplazar NAs resultantes con 0
  x_numerico[is.na(x_numerico)] <- 0
  
  return(x_numerico)
}

# Lista de todas las variables demogr√°ficas que necesitan limpieza
variables_demograficas_a_limpiar <- c(
  "hogares2020", "pob2020", "viv2020", "habitadas2020", 
  "migrantes2020", "pob_ocupada_2020", "pob2010", 
  "hogares2010", "viv2010", "pob_ocupada_2010",
  "independiente", "empty_nesters", "separados_hijos",
  "pareja_sin_hijos", "pareja_hijos_10", "pareja_hijos_21",
  "pareja_hijos_1120", "joven_sin_hijos", "soltero_adulto",
  "soltero_joven", "prestada", "propia", "propia_pagando",
  "rentada", "intestada_litigio", "pob_masc", "pob_fem"
)

# Verificar cu√°les variables existen en el dataset
variables_existentes <- intersect(variables_demograficas_a_limpiar, names(demograficos_sf))
cat("Variables demogr√°ficas encontradas:", length(variables_existentes), "\n")

# Aplicar limpieza robusta a todas las variables demogr√°ficas
demograficos_sf <- demograficos_sf %>%
  mutate(across(all_of(variables_existentes), limpiar_variable_numerica))

cat("‚úÖ Variables demogr√°ficas limpiadas sin warnings\n")

### Ajustar variables a la categor√≠a correcta
demograficos_sf <- demograficos_sf %>%
  mutate(hogares2020 = as.numeric(hogares2020))

### Transformar a CRS proyectado adecuado (UTM 14N para Monterrey)
proyectos_proj <- st_transform(proyectos_sf, 32614)
demograficos_proj <- st_transform(demograficos_sf, 32614)

### Calcular √°rea de cada AGEB
demograficos_proj <- demograficos_proj %>% 
  mutate(ageb_area = st_area(.))

### Crear buffer de 1 km alrededor de cada proyecto
proyectos_buffer <- st_buffer(proyectos_proj, 1000)

### Encontrar intersecciones y calcular √°reas de superposici√≥n
intersecciones <- st_intersection(
  st_make_valid(proyectos_buffer),
  st_make_valid(demograficos_proj)
) %>% 
  mutate(
    interseccion_area = st_area(.),
    proporcion = as.numeric(interseccion_area / ageb_area)
  ) %>% 
  filter(proporcion > 0.001)  # Filtrar superposiciones m√≠nimas

### Lista de variables demogr√°ficas a agregar
variables_demograficas <- c(
  "pob2020", "hogares2020", "viv2020", "habitadas2020", 
  "migrantes2020", "pob_ocupada_2020", "pob2010", 
  "hogares2010", "viv2010", "pob_ocupada_2010",
  "independiente", "empty_nesters", "separados_hijos",
  "pareja_sin_hijos", "pareja_hijos_10", "pareja_hijos_21",
  "pareja_hijos_1120", "joven_sin_hijos", "soltero_adulto",
  "soltero_joven", "prestada", "propia", "propia_pagando",
  "rentada", "intestada_litigio", "pob_masc", "pob_fem"
)

### Agregar variables ponderadas por la proporci√≥n de √°rea
demografia_agregada <- intersecciones %>% 
  st_drop_geometry() %>% 
  group_by(Proyecto) %>% 
  summarise(
    across(
      all_of(variables_demograficas),
      ~sum(.x * proporcion, na.rm = TRUE),
      .names = "{.col}_1km"
    ),
    .groups = "drop"
  )

### Unir los datos agregados al dataset principal
proyectos_sf <- proyectos_sf %>% 
  left_join(demografia_agregada, by = "Proyecto")

## 8.2. Unir informaci√≥n de NSE: Agregar la zona NSE a cada proyecto.
proyectos_sf <- st_join(proyectos_sf,
                        nse_data_renamed,
                        join = st_intersects,
                        left = TRUE)

## 8.3. Unir informaci√≥n de zonas REDI
proyectos_sf <- st_join(proyectos_sf,
                        zonas_redi_renamed,
                        join = st_intersects,
                        left = TRUE)

## 8.4. Calcular el parque m√°s cercano usando la base "verdes"
nearest_idx <- st_nearest_feature(proyectos_sf, verdes_sf)
proyectos_sf$nearest_park <- verdes_sf$nombre[nearest_idx]
proyectos_sf$dist_to_park <- st_distance(proyectos_sf, verdes_sf[nearest_idx, ], by_element = TRUE)
proyectos_sf$dist_to_park <- as.numeric(proyectos_sf$dist_to_park)

## 8.5. Calcular el parque importante m√°s cercano (desde el KML)
nearest_idx_poly <- st_nearest_feature(proyectos_sf, parques_kml)
proyectos_sf$nearest_park_kml <- parques_kml$nombre[nearest_idx_poly]
proyectos_sf$dist_to_park_kml <- st_distance(proyectos_sf, parques_kml[nearest_idx_poly, ], by_element = TRUE)
proyectos_sf$dist_to_park_kml <- as.numeric(proyectos_sf$dist_to_park_kml)

cat("‚úÖ Uniones espaciales completadas\n")

# ---- 9. PROCESAMIENTO DE AMENIDADES ----
cat("\nüèä PROCESANDO DATOS DE AMENIDADES...\n")

### Limpiar nombres y convertir S√≠/No a 1/0
amenidades_clean <- amenidades %>%
  janitor::clean_names() %>%
  rename(Proyecto = proyecto) %>%
  mutate(across(c(control_de_acceso:vestidores), ~ ifelse(.x == "S√≠", 1, 0))) %>%
  select(-c(segmento, ciudad, zona, precio_promedio_inventario, absorcion_historica, absorcioo_del_ult_q))

## Unir informaci√≥n de amenidades
proyectos_sf <- proyectos_sf %>%
  left_join(amenidades_clean, by = "Proyecto") %>%
  mutate(across(c(control_de_acceso:vestidores), ~ ifelse(is.na(.x), 0, .x)))  # Convertir NA a 0

cat("‚úÖ Amenidades procesadas\n")

# ---- 10. C√ÅLCULO DE DISTANCIAS A EQUIPAMIENTOS ----
cat("\nüè• CALCULANDO DISTANCIAS A EQUIPAMIENTOS...\n")

# Aplicar funci√≥n para cada tipo de equipamiento
proyectos_sf <- calcular_distancias_equipamientos(proyectos_sf, equipamientos_list$hospitales, "hospital")
proyectos_sf <- calcular_distancias_equipamientos(proyectos_sf, equipamientos_list$escuelas_privadas, "esc_priv")
proyectos_sf <- calcular_distancias_equipamientos(proyectos_sf, equipamientos_list$escuelas_publicas, "esc_pub")
proyectos_sf <- calcular_distancias_equipamientos(proyectos_sf, equipamientos_list$universidades, "universidad")
proyectos_sf <- calcular_distancias_equipamientos(proyectos_sf, equipamientos_list$supermercados, "super")
proyectos_sf <- calcular_distancias_equipamientos(proyectos_sf, equipamientos_list$restaurantes, "restau")
proyectos_sf <- calcular_distancias_equipamientos(proyectos_sf, equipamientos_list$oficinas, "oficina")
proyectos_sf <- calcular_distancias_equipamientos(proyectos_sf, equipamientos_list$tiendas_departamentales, "tienda_dept")

cat("‚úÖ Distancias a equipamientos calculadas\n")

# ---- 11. PROCESAMIENTO DE VARIABLES DE VIALIDADES ----
cat("\nüõ£Ô∏è  PROCESANDO VARIABLES DE VIALIDADES...\n")

# Funci√≥n para calcular la distancia a la avenida principal m√°s cercana y su clasificaci√≥n
calcular_dist_avenidas <- function(proyectos_sf, avenidas_sf) {
  # Transformar a UTM para c√°lculos de distancia en metros
  proyectos_utm <- st_transform(proyectos_sf, 32614)  # UTM 14N para Monterrey
  avenidas_utm <- st_transform(avenidas_sf, 32614)
  
  # Inicializar columnas de resultado
  n <- nrow(proyectos_utm)
  dist_to_avenue <- numeric(n)
  nearest_avenue_name <- character(n)
  nearest_avenue_type <- character(n)
  nearest_avenue_hierarchy <- numeric(n)
  nearest_avenue_flow <- numeric(n)
  
  # Para cada proyecto, calcular distancia a la avenida m√°s cercana
  for (i in 1:n) {
    proyecto <- proyectos_utm[i, ]
    
    # Calcular distancias a todas las avenidas
    distancias <- st_distance(proyecto, avenidas_utm)
    
    # Encontrar la avenida m√°s cercana
    idx_min <- which.min(distancias)
    
    if (length(idx_min) > 0) {
      dist_to_avenue[i] <- as.numeric(distancias[idx_min])
      nearest_avenue_name[i] <- avenidas_sf$nombre_normalizado[idx_min]
      nearest_avenue_type[i] <- avenidas_sf$tipo_via[idx_min]
      nearest_avenue_hierarchy[i] <- avenidas_sf$jerarquia[idx_min]
      nearest_avenue_flow[i] <- avenidas_sf$flujo_promedio[idx_min]
    } else {
      dist_to_avenue[i] <- NA
      nearest_avenue_name[i] <- NA
      nearest_avenue_type[i] <- NA
      nearest_avenue_hierarchy[i] <- NA
      nearest_avenue_flow[i] <- NA
    }
  }
  
  # Crear data frame con resultados
  resultados <- data.frame(
    dist_to_avenue = dist_to_avenue,
    nearest_avenue_name = nearest_avenue_name,
    nearest_avenue_type = nearest_avenue_type,
    nearest_avenue_hierarchy = nearest_avenue_hierarchy,
    nearest_avenue_flow = nearest_avenue_flow
  )
  
  return(resultados)
}

# Calcular distancias
distancias_avenidas <- calcular_dist_avenidas(proyectos_sf, avenidas_data)

# Unir resultados a proyectos_sf
proyectos_sf <- cbind(proyectos_sf, distancias_avenidas)

# Crear variables dicot√≥micas de cercan√≠a a avenidas
proyectos_sf <- proyectos_sf %>%
  mutate(
    # Cercan√≠a a avenida (umbral de 200m)
    cerca_avenida_principal = ifelse(!is.na(nearest_avenue_hierarchy) & 
                                       dist_to_avenue <= 200 & 
                                       nearest_avenue_hierarchy %in% c(1, 2), 1, 0),
    
    # Variables adicionales de vialidades
    dist_avenida_norm = 1 - pmin(1, dist_to_avenue / 1000),
    
    categoria_jerarquia = case_when(
      nearest_avenue_hierarchy == 1 ~ "Arterial principal",
      nearest_avenue_hierarchy == 2 ~ "Arterial secundaria",
      nearest_avenue_hierarchy == 3 ~ "Colectora",
      nearest_avenue_hierarchy == 4 ~ "Local principal",
      TRUE ~ "Sin clasificar"
    ),
    
    cercania_avenida = ifelse(dist_to_avenue <= 200 & dist_to_avenue < 2000, 1, 0),
    cercania_avenida_arterial = ifelse(
      dist_to_avenue <= 200 & 
        nearest_avenue_hierarchy == 1 & 
        dist_to_avenue < 2000, 
      1, 
      0
    ),
    cercania_avenida_secundaria = ifelse(
      dist_to_avenue <= 200 & 
        nearest_avenue_hierarchy == 2 & 
        dist_to_avenue < 2000, 
      1, 
      0
    ),
    
    ponderacion_jerarquia = case_when(
      nearest_avenue_hierarchy == 1 ~ 1.0,  # Arterial principal
      nearest_avenue_hierarchy == 2 ~ 0.8,  # Arterial secundaria
      nearest_avenue_hierarchy == 3 ~ 0.6,  # Colectora
      nearest_avenue_hierarchy == 4 ~ 0.4,  # Local principal
      TRUE ~ 0.3  # Otros
    ),
    
    ponderacion_flujo = case_when(
      !is.na(nearest_avenue_flow) & nearest_avenue_flow > 500 ~ 0.2,
      !is.na(nearest_avenue_flow) & nearest_avenue_flow > 200 ~ 0.1,
      TRUE ~ 0
    )
  )

cat("‚úÖ Variables de vialidades procesadas\n")

# ---- 12. TRANSFORMACI√ìN DE VARIABLES A DICOT√ìMICAS ----
cat("\nüîÑ TRANSFORMANDO VARIABLES A DICOT√ìMICAS...\n")

base_transformada <- proyectos_sf %>%
  # 12.1 DENSIDAD POBLACIONAL (mover absorci√≥n para despu√©s)
  mutate(
    alta_densidad_pob = case_when(
      is.na(pob2020_1km) ~ NA_real_,
      # Asumiendo √°rea de 3.14 km¬≤ (radio de 1km)
      pob2020_1km / 3.14 > 20000 ~ 1, 
      TRUE ~ 0
    )
  ) %>%
  
  # 12.2 Distancia a parques
  mutate(
    cerca_parque_relevante = case_when(
      is.na(dist_to_park_kml) ~ NA_real_,
      dist_to_park_kml <= 500 ~ 1,
      TRUE ~ 0
    )
  ) %>%
  
  # 12.3 Proporci√≥n hogares propios vs rentados
  mutate(
    prop_hogares_propios = (propia_1km + propia_pagando_1km) / 
      (propia_1km + propia_pagando_1km + rentada_1km + prestada_1km),
    predominio_hogares_propios = case_when(
      is.na(prop_hogares_propios) ~ NA_real_,
      prop_hogares_propios > 0.6 ~ 1,
      TRUE ~ 0
    )
  ) %>%
  
  # 12.4 Crecimiento poblacional
  mutate(
    crecimiento_pob = (pob2020_1km - pob2010_1km) / pob2010_1km,
    alto_crecimiento = case_when(
      is.na(crecimiento_pob) ~ NA_real_,
      crecimiento_pob > 0.15 ~ 1, # Crecimiento mayor al 15% en 10 a√±os
      TRUE ~ 0
    )
  )

cat("‚úÖ Variables dicot√≥micas creadas (absorci√≥n se procesar√° despu√©s)\n")

# ---- 13. CREACI√ìN DE √çNDICES COMPUESTOS ----
cat("\nüìä CREANDO √çNDICES COMPUESTOS...\n")

# 13.1 √çndice de Accesibilidad a Servicios
base_transformada <- base_transformada %>%
  mutate(
    indice_accesibilidad = (
      (cercania_universidad * 3) +
        (cercania_esc_priv * 2) +
        (cercania_esc_pub * 1) +
        (cercania_hospital * 3) +
        (cercania_super * 2) +
        (cercania_restau * 1) +
        (cercania_oficina * 2) +
        (cercania_tienda_dept * 2)
    ) / 16  # Normalizar entre 0 y 1 (suma m√°xima de pesos)
  )

# 13.2 √çndice de densidad educativa
base_transformada <- base_transformada %>%
  mutate(
    densidad_educativa = cantidad_esc_priv_1km + cantidad_esc_pub_1km + cantidad_universidad_1km,
    alta_densidad_educativa = case_when(
      densidad_educativa >= 5 ~ 1,
      TRUE ~ 0
    )
  )

# 13.3 √çndice de densidad comercial
base_transformada <- base_transformada %>%
  mutate(
    densidad_comercial = cantidad_super_1km + cantidad_restau_1km + cantidad_tienda_dept_1km,
    alta_densidad_comercial = case_when(
      densidad_comercial >= 10 ~ 1,
      TRUE ~ 0
    )
  )

# 13.4 √çndice de entorno laboral
base_transformada <- base_transformada %>%
  mutate(
    entorno_laboral = cantidad_oficina_1km,
    alto_entorno_laboral = case_when(
      entorno_laboral >= 5 ~ 1,
      TRUE ~ 0
    )
  )

# 13.5 √çndice de amenidades del proyecto
# Verificar qu√© columnas de amenidades existen
amenidades_cols <- c("alberca", "areas_verdes", "asadores", "bar", "campo_de_golf",
                     "canchas_deportivas", "casa_club", "fogatero", "gimnasio", 
                     "golf_virtual", "jacuzzi", "lounges", "ludoteca_juegos_infantiles",
                     "patio_central", "pet_zone", "pista_de_jogging_vitapista",
                     "roof_graden", "sala_de_cine_tv", "sala_de_lectura",
                     "salon_usos_multiples", "salon_de_yoga", "sauna", "spa",
                     "terraza", "vestidores")

# Verificar cu√°les columnas existen en el dataset
cols_existentes <- amenidades_cols[amenidades_cols %in% names(base_transformada)]

# Crear dataframe no espacial solo con las columnas de amenidades
amenidades_df <- st_drop_geometry(base_transformada) %>% 
  select(all_of(cols_existentes))

# Asegurar que todas son num√©ricas
amenidades_df <- as.data.frame(lapply(amenidades_df, function(x) as.numeric(as.character(x))))

# Calcular la suma de amenidades
num_amenidades <- rowSums(amenidades_df, na.rm = TRUE)

# A√±adir el resultado al dataset principal
base_transformada$num_amenidades <- num_amenidades
base_transformada$categoria_amenidades <- case_when(
  base_transformada$num_amenidades >= 15 ~ "Premium",
  base_transformada$num_amenidades >= 8 ~ "Alto",
  base_transformada$num_amenidades >= 4 ~ "Medio",
  TRUE ~ "B√°sico"
)

# 13.6 √çndice de accesibilidad vial
base_transformada <- base_transformada %>%
  mutate(
    # Calcular √≠ndice de accesibilidad vial
    accesibilidad_vial = (dist_avenida_norm * 0.6) + 
      (ponderacion_jerarquia * 0.3) + 
      (ponderacion_flujo * 0.1),
    
    # Categor√≠a de accesibilidad vial
    categoria_accesibilidad_vial = case_when(
      accesibilidad_vial >= 0.8 ~ "Excelente",
      accesibilidad_vial >= 0.6 ~ "Buena",
      accesibilidad_vial >= 0.4 ~ "Media",
      accesibilidad_vial >= 0.2 ~ "Regular",
      TRUE ~ "Deficiente"
    )
  )

# 13.7 √çndice compuesto de inversi√≥n
base_transformada <- base_transformada %>%
  mutate(
    potencial_inversion = (
      (alto_crecimiento * 3) +
        (cerca_parque_relevante * 3) +
        (indice_accesibilidad * 4) +
        (alta_densidad_comercial * 4) +
        (alto_entorno_laboral * 2) +
        (accesibilidad_vial * 3) +
        (cerca_avenida_principal * 2) +
        (ifelse(Estatus == "Preventa", 1, 0) * 1)
    ) / 22
  )

# 13.8 √çndice de conveniencia urbana
base_transformada <- base_transformada %>%
  mutate(
    indice_conveniencia = (
      cercania_super * 0.10 +
        cercania_restau * 0.15 +
        cercania_hospital * 0.10 +
        cercania_esc_priv * 0.10 +
        cercania_tienda_dept * 0.10 +
        cerca_parque_relevante * 0.20 +
        cerca_avenida_principal * 0.15 +
        cercania_avenida_arterial * 0.10
    ),
    
    alta_conveniencia = case_when(
      indice_conveniencia >= 0.7 ~ 1,
      TRUE ~ 0
    )
  )

cat("‚úÖ √çndices compuestos creados\n")

# ---- 14. PROCESAMIENTO ADICIONAL DE VARIABLES (VERSI√ìN CORREGIDA) ----
cat("\nüîß PROCESAMIENTO ADICIONAL DE VARIABLES (VERSI√ìN CORREGIDA)...\n")

# CORRECCI√ìN 1: Limpieza robusta de la variable absorcion
cat("üîß Corrigiendo variable absorcion...\n")

# Verificar valores problem√°ticos en absorcion antes de convertir
valores_absorcion_original <- base_transformada$Absorcion.por.proyecto
cat("  - Valores √∫nicos en absorcion original (primeros 10):", 
    paste(head(unique(valores_absorcion_original[!is.na(valores_absorcion_original)]), 10), collapse = ", "), "\n")

# Funci√≥n robusta para convertir absorcion
convertir_absorcion_seguro <- function(x) {
  if(is.na(x)) return(NA_real_)
  
  # Convertir a character primero
  x_char <- as.character(x)
  
  # Limpiar caracteres no num√©ricos comunes
  x_limpio <- gsub("[^0-9.-]", "", x_char)
  
  # Intentar conversi√≥n
  resultado <- suppressWarnings(as.numeric(x_limpio))
  
  # Si falla, intentar parse_number
  if(is.na(resultado)) {
    resultado <- suppressWarnings(readr::parse_number(x_char))
  }
  
  return(resultado)
}

# CORRECCI√ìN 2: Funci√≥n robusta para divisi√≥n evitando ceros
division_segura <- function(numerador, denominador, valor_default = NA_real_) {
  ifelse(is.na(denominador) | denominador == 0, valor_default, numerador / denominador)
}

# CORRECCI√ìN 3: Funci√≥n robusta para logaritmos
log_seguro <- function(x, valor_default = NA_real_) {
  ifelse(is.na(x) | x <= 0, valor_default, log(x))
}

# CORRECCI√ìN 4: Funci√≥n robusta para distancias inversas
distancia_inversa_segura <- function(distancia, valor_default = 0.1) {
  ifelse(is.na(distancia) | distancia <= 0, valor_default, 1 / log(distancia + 1))
}

# Aplicar correcciones en el procesamiento principal
base_integrada <- base_transformada %>%
  # Extraer informaci√≥n de NSE con manejo robusto
  extract(
    col = nse_description, 
    into = c("nse_extraido", "personas_extraido", "hogares_extraido", "precio_vivienda_extraido"),
    regex = "NSE:\\s*([^\\s]+)\\s+Personas:\\s*([0-9,]+)\\s+Hogares:\\s*([0-9,]+)\\s+Precio Promedio de Vivienda:\\s*\\$?([0-9,\\.]+)",
    remove = FALSE
  ) %>%
  
  # APLICAR CORRECCIONES
  mutate(
    # CORRECCI√ìN 1: Absorcion con limpieza robusta
    absorcion = map_dbl(Absorcion.por.proyecto, convertir_absorcion_seguro),
    
    # CORRECCI√ìN 2: Crecimiento poblacional con divisi√≥n segura
    crecimiento_pob_seguro = division_segura(
      pob2020_1km - pob2010_1km, 
      pob2010_1km, 
      valor_default = 0  # Si no hay datos de 2010, asumir crecimiento 0
    ),
    
    # CORRECCI√ìN 3: Log seguro para precios
    log_pm2 = log_seguro(p_m2, valor_default = log(mean(p_m2, na.rm = TRUE))),
    
    # Renombrar variables para consistencia
    nearest_relevant_park = nearest_park_kml,
    dist_to_relevant_park = dist_to_park_kml
  ) %>%
  
  # ‚úÖ CORRECCI√ìN PRINCIPAL: Categorizaci√≥n de exitosos DESPU√âS de limpiar absorcion
  mutate(
    # üéØ ABSORCI√ìN - PROYECTOS EXITOSOS (CORREGIDO)
    exitoso = case_when(
      is.na(absorcion) ~ NA_real_,                    # ‚Üê Sin comillas, variable limpia
      absorcion >= 3 ~ 1,                             # ‚Üê Sin comillas, variable limpia
      TRUE ~ 0
    ),
    super_exitoso = case_when(
      is.na(absorcion) ~ NA_real_,                    # ‚Üê Sin comillas, variable limpia
      absorcion >= 7 ~ 1,                             # ‚Üê Sin comillas, variable limpia
      TRUE ~ 0
    )
  ) %>%
  
  # Procesar variables categ√≥ricas con limpieza
  mutate(
    # CORRECCI√ìN 4: Limpiar y categorizar NSE
    nse_limpio = case_when(
      # Mapear valores conocidos de NSE
      str_detect(toupper(nse_extraido), "A\\+|A PLUS") ~ "A+",
      str_detect(toupper(nse_extraido), "^A$|^A [^+]") ~ "A",
      str_detect(toupper(nse_extraido), "B") ~ "B",
      str_detect(toupper(nse_extraido), "C\\+|C PLUS") ~ "C+",
      str_detect(toupper(nse_extraido), "^C$|^C [^+]") ~ "C",
      str_detect(toupper(nse_extraido), "D\\+|D PLUS") ~ "D+",
      str_detect(toupper(nse_extraido), "^D$|D/E") ~ "D",
      str_detect(toupper(nse_extraido), "E") ~ "E",
      TRUE ~ "Sin_Clasificar"  # Para valores que no coinciden
    ),
    
    # CORRECCI√ìN 5: Limpiar y categorizar Segmento
    segmento_limpio = case_when(
      str_detect(toupper(Segmento), "PREMIUM PLUS|PREMIUN PLUS") ~ "Premium Plus",
      str_detect(toupper(Segmento), "^PREMIUM$|PREMIUM[^P]") ~ "Premium", 
      str_detect(toupper(Segmento), "RESIDENCIAL PLUS|RESIDENCIAL\\+") ~ "Residencial Plus",
      str_detect(toupper(Segmento), "^RESIDENCIAL$|RESIDENCIAL[^P]") ~ "Residencial",
      str_detect(toupper(Segmento), "MEDIO|MIDDLE") ~ "Medio",
      str_detect(toupper(Segmento), "ECONOMICO|SOCIAL") ~ "Econ√≥mico",
      TRUE ~ "Sin_Clasificar"
    ),
    
    # CORRECCI√ìN 6: Limpiar y categorizar Estatus
    estatus_limpio = case_when(
      str_detect(toupper(Estatus), "PREVENTA|PRE.VENTA") ~ "Preventa",
      str_detect(toupper(Estatus), "CONSTRUCCION|EN OBRA") ~ "En construcci√≥n", 
      str_detect(toupper(Estatus), "ENTREGADO|TERMINADO|COMPLETED") ~ "Entregado",
      str_detect(toupper(Estatus), "NUEVO") ~ "Nuevo",
      TRUE ~ "Sin_Clasificar"
    ),
    
    # Procesar variables num√©ricas extra√≠das con parse_number seguro
    personas = suppressWarnings(readr::parse_number(personas_extraido)),
    hogares = suppressWarnings(readr::parse_number(hogares_extraido)), 
    precio_vivienda = suppressWarnings(readr::parse_number(precio_vivienda_extraido)),
    
    # Convertir a factores las variables categ√≥ricas limpias
    nse = as.factor(nse_limpio),
    Segmento = as.factor(segmento_limpio),
    Estatus = as.factor(estatus_limpio),
    Municipio = as.factor(Municipio),
    nearest_park = as.factor(nearest_park),
    nearest_relevant_park = as.factor(nearest_relevant_park),
    zona_name = as.factor(zona_name)
  )

# Actualizar la variable de crecimiento poblacional en el dataset
base_integrada <- base_integrada %>%
  mutate(crecimiento_pob = crecimiento_pob_seguro) %>%
  select(-crecimiento_pob_seguro)  # Remover variable temporal

# Agregar la variable de "Unidades Vendidas"
base_integrada <- base_integrada %>%
  mutate(unidades_vendidas = unidades_totales - unidades_inv) %>%
  relocate(unidades_vendidas, .after = unidades_inv) %>%
  relocate(log_pm2, .after = p_m2)

# CORRECCI√ìN 7: Calificaci√≥n robusta de proximidad a parques relevantes
base_integrada <- base_integrada %>%
  mutate(
    # Usar funci√≥n segura para evitar problemas con distancias ‚â§ 0
    inv_dist_to_park = distancia_inversa_segura(dist_to_relevant_park),
    inv_dist_to_park = as.numeric(scale(inv_dist_to_park))  # Normalizar
  ) %>%
  relocate(inv_dist_to_park, .after = dist_to_relevant_park)

# Usar las coordenadas existentes (simplemente renombrar para consistencia)
base_integrada <- base_integrada %>%
  mutate(
    longitud = Longitud,
    latitud = Latitud
  )

# Verificar correcciones aplicadas
cat("‚úÖ Correcciones aplicadas:\n")
cat("  - Absorcion convertida de forma segura:", sum(!is.na(base_integrada$absorcion)), "valores v√°lidos\n")
cat("  - Crecimiento poblacional calculado de forma segura\n")
cat("  - Log de precios calculado de forma segura\n") 
cat("  - Distancia inversa a parques calculada de forma segura\n")
cat("  - Variables categ√≥ricas limpiadas y convertidas a factores\n")

# Mostrar estad√≠sticas de limpieza categ√≥rica
cat("\nüìä Estad√≠sticas de variables categ√≥ricas limpias:\n")
cat("  - NSE:", length(levels(base_integrada$nse)), "niveles:", paste(levels(base_integrada$nse), collapse = ", "), "\n")
cat("  - Segmento:", length(levels(base_integrada$Segmento)), "niveles:", paste(levels(base_integrada$Segmento), collapse = ", "), "\n")
cat("  - Estatus:", length(levels(base_integrada$Estatus)), "niveles:", paste(levels(base_integrada$Estatus), collapse = ", "), "\n")

cat("‚úÖ Procesamiento adicional completado SIN WARNINGS\n")

# ---- VERIFICACI√ìN DE CATEGORIZACI√ìN CORREGIDA ----
cat("\nüîç VERIFICANDO CATEGORIZACI√ìN DE EXITOSOS...\n")

# Estad√≠sticas de absorci√≥n
absorcion_stats <- base_integrada %>%
  summarise(
    min_absorcion = min(absorcion, na.rm = TRUE),
    max_absorcion = max(absorcion, na.rm = TRUE),
    mean_absorcion = mean(absorcion, na.rm = TRUE),
    median_absorcion = median(absorcion, na.rm = TRUE),
    na_absorcion = sum(is.na(absorcion))
  )

cat("üìä Estad√≠sticas de absorci√≥n:\n")
print(absorcion_stats)

# Estad√≠sticas de categorizaci√≥n
categoria_stats <- base_integrada %>%
  summarise(
    total_proyectos = n(),
    exitosos = sum(exitoso == 1, na.rm = TRUE),
    super_exitosos = sum(super_exitoso == 1, na.rm = TRUE),
    no_exitosos = sum(exitoso == 0, na.rm = TRUE),
    pct_exitosos = round(mean(exitoso == 1, na.rm = TRUE) * 100, 1),
    pct_super_exitosos = round(mean(super_exitoso == 1, na.rm = TRUE) * 100, 1)
  )

cat("\nüìä Estad√≠sticas de categorizaci√≥n CORREGIDA:\n")
print(categoria_stats)

# Verificar distribuci√≥n de absorci√≥n por rangos
distribucion_absorcion <- base_integrada %>%
  filter(!is.na(absorcion)) %>%
  mutate(
    rango_absorcion = case_when(
      absorcion < 1 ~ "< 1",
      absorcion >= 1 & absorcion < 3 ~ "1-3",
      absorcion >= 3 & absorcion < 7 ~ "3-7 (Exitoso)",
      absorcion >= 7 ~ ">= 7 (Super Exitoso)"
    )
  ) %>%
  count(rango_absorcion) %>%
  mutate(porcentaje = round(n / sum(n) * 100, 1))

cat("\nüìä Distribuci√≥n por rangos de absorci√≥n:\n")
print(distribucion_absorcion)

cat("‚úÖ Verificaci√≥n completada - Categorizaci√≥n corregida\n")

# ---- 15. GUARDAR DATASET RESULTANTE ----
cat("\nüíæ GUARDANDO DATASET RESULTANTE...\n")

# Verificar nombres duplicados
nombres_columnas <- names(base_integrada)
duplicados <- duplicated(nombres_columnas)
if(any(duplicados)) {
  cat("Se encontraron nombres duplicados:\n")
  tabla_freq <- table(nombres_columnas)
  print(tabla_freq[tabla_freq > 1])
  
  # Renombrar columnas duplicadas a√±adiendo un sufijo
  indices_duplicados <- which(duplicados)
  for(i in indices_duplicados) {
    nombres_columnas[i] <- paste0(nombres_columnas[i], "_", i)
  }
  names(base_integrada) <- nombres_columnas
  cat("Nombres corregidos.\n")
} else {
  cat("No se encontraron nombres duplicados.\n")
}

# Regenerar completamente la geometr√≠a desde las coordenadas
base_sin_geom <- st_drop_geometry(base_integrada)
base_nueva_sf <- st_as_sf(base_sin_geom, 
                          coords = c("longitud", "latitud"), 
                          crs = 4326)

# Guardar la versi√≥n con geometr√≠a
st_write(base_nueva_sf, "base_inmobiliaria_preparada.gpkg", delete_dsn = TRUE)

# Y para CSV
write.csv(base_sin_geom, "base_inmobiliaria_preparada.csv", row.names = FALSE)

cat("‚úÖ Dataset guardado como:\n")
cat("   - base_inmobiliaria_preparada.gpkg (con geometr√≠a)\n")
cat("   - base_inmobiliaria_preparada.csv (sin geometr√≠a)\n")

# ---- 16. RESUMEN EJECUTIVO ----
cat("\n", rep("=", 60), "\n")
cat("SCRIPT 1: PREPARACI√ìN Y TRANSFORMACI√ìN - COMPLETADO\n")
cat(rep("=", 60), "\n")

cat("\nüìä ESTAD√çSTICAS FINALES:\n")
cat("- Proyectos procesados:", nrow(base_sin_geom), "\n")
cat("- Variables creadas:", ncol(base_sin_geom), "\n")
cat("- Equipamientos analizados:", length(equipamientos_list), "\n")
cat("- √çndices compuestos creados: 8\n")

cat("\nüèóÔ∏è  TAREAS COMPLETADAS:\n")
cat("‚úÖ Carga e integraci√≥n de datos de m√∫ltiples fuentes\n")
cat("‚úÖ Transformaci√≥n de coordenadas DMS a decimal\n")
cat("‚úÖ Uniones espaciales (NSE, REDI, parques, demograf√≠a)\n")
cat("‚úÖ C√°lculo de distancias a equipamientos urbanos\n")
cat("‚úÖ Procesamiento de variables de vialidades\n")
cat("‚úÖ Transformaci√≥n de variables a dicot√≥micas\n")
cat("‚úÖ Creaci√≥n de √≠ndices compuestos\n")
cat("‚úÖ Limpieza y validaci√≥n de datos\n")

cat("\nüìà √çNDICES CREADOS:\n")
cat("- √çndice de Accesibilidad a Servicios\n")
cat("- √çndice de Densidad Educativa\n")
cat("- √çndice de Densidad Comercial\n")
cat("- √çndice de Entorno Laboral\n")
cat("- √çndice de Amenidades del Proyecto\n")
cat("- √çndice de Accesibilidad Vial\n")
cat("- √çndice de Potencial de Inversi√≥n\n")
cat("- √çndice de Conveniencia Urbana\n")

cat("\nüéØ VARIABLES CLAVE CALCULADAS:\n")
cat("- Distancias a", length(equipamientos_list), "tipos de equipamientos\n")
cat("- Variables demogr√°ficas agregadas en radio de 1km\n")
cat("- Variables dicot√≥micas de cercan√≠a y densidad\n")
cat("- Categorizaci√≥n de amenidades y accesibilidad vial\n")
cat("- M√©tricas de crecimiento poblacional y hogares\n")

cat("\nüîÑ SIGUIENTE PASO:\n")
cat("Ejecutar Script 2: CONSTRUCCI√ìN DE √çNDICES PRINCIPALES\n")
cat("para calcular IVU, IVP y modelo de evoluci√≥n NSE\n")

cat("\n", rep("=", 60), "\n")

# FINALIZAR CAPTURA
sink()  # Cerrar redirecci√≥n
cat("üìÑ Log guardado en:", archivo_log, "\n")

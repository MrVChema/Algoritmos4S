# SCRIPT 4 CORREGIDO: VISUALIZACIONES CON CATEGORIZACI√ìN 4S CORRECTA
# Flujo Optimizado IVU-IVP - Visualizaciones para an√°lisis inmobiliario

# ---- 1. CONFIGURACI√ìN INICIAL ----
cat("üöÄ INICIANDO SCRIPT 4 CORREGIDO: VISUALIZACIONES CON CATEGORIZACI√ìN 4S CORRECTA\n")
cat("================================================================\n\n")

# Limpiar el entorno y cargar librer√≠as necesarias
rm(list = ls())

library(dplyr)
library(ggplot2)
library(plotly)
library(leaflet)
library(sf)
library(RColorBrewer)
library(htmlwidgets)
library(htmltools)
library(DT)
library(corrplot)
library(gridExtra)
library(scales)
library(viridis)
library(forcats)
library(stringr)
library(tidyr)
library(readr)

# Establecer directorio de trabajo
setwd('/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[04] MODELACI√ìN/[02] IVU-IVP/VISUALIZACION')

cat("‚úÖ Configuraci√≥n inicial completada\n")

# CAPTURAR SALIDA DE CONSOLA
timestamp <- format(Sys.time(), "%Y%m%d_%H%M%S")
archivo_log <- paste0("script4_corregido_log_", timestamp, ".txt")
sink(archivo_log, append = FALSE, split = TRUE)

# ---- 2. CARGAR DATOS ----
cat("\nüìä CARGANDO DATOS CON M√âTRICAS AVANZADAS...\n")

# Cargar datos del Script 3
archivos_posibles <- c(
  "base_con_metricas_avanzadas.csv",
  "/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[04] MODELACI√ìN/[02] IVU-IVP/base_con_metricas_avanzadas.csv"
)

datos <- NULL
for(archivo in archivos_posibles) {
  if(file.exists(archivo)) {
    datos <- read.csv(archivo, stringsAsFactors = FALSE, encoding = "UTF-8")
    cat("‚úÖ Archivo cargado:", basename(archivo), "\n")
    break
  }
}

if(is.null(datos)) {
  stop("‚ùå No se pudo cargar el archivo con m√©tricas avanzadas.")
}

cat("‚úÖ Datos cargados - Proyectos:", nrow(datos), "\n")

# ---- 3. CORRECCI√ìN DE CATEGORIZACI√ìN 4S ----
cat("\nüîß CORRIGIENDO CATEGORIZACI√ìN 4S...\n")

# Funci√≥n para categorizaci√≥n 4S CORRECTA basada en posici√≥n en matriz
categorizar_4s_correcto <- function(ivu, ivp) {
  case_when(
    ivu >= 0.5 & ivp >= 0.5 ~ "SUPERIOR",     # Alto IVU + Alto IVP
    ivu >= 0.5 & ivp < 0.5 ~ "SUSTENTABLE",   # Alto IVU + Bajo IVP  
    ivu < 0.5 & ivp >= 0.5 ~ "S√ìLIDO",        # Bajo IVU + Alto IVP
    ivu < 0.5 & ivp < 0.5 ~ "SINGULAR",       # Bajo IVU + Bajo IVP
    TRUE ~ "SIN_CLASIFICAR"
  )
}

# Aplicar categorizaci√≥n correcta
datos <- datos %>%
  mutate(
    # Asegurar que tenemos las m√©tricas base
    ivu_base = ifelse(is.na(ivu), 0, ivu),
    ivp_base = ifelse(is.na(ivp_v2), 0, ivp_v2),
    
    # Categorizaci√≥n 4S CORRECTA
    categoria_4s_correcta = categorizar_4s_correcto(ivu_base, ivp_base),
    
    # Reemplazar la categorizaci√≥n anterior
    categoria_4s = categoria_4s_correcta,
    
    # Crear etiquetas de diagn√≥stico
    diagnostico_posicion = paste0(
      "IVU: ", round(ivu_base, 3), 
      " | IVP: ", round(ivp_base, 3),
      " | Categor√≠a: ", categoria_4s
    )
  )

# Verificar la correcci√≥n
cat("üîç VERIFICANDO CATEGORIZACI√ìN CORREGIDA:\n")
verificacion <- datos %>%
  filter(!is.na(ivu_base) & !is.na(ivp_base)) %>%
  group_by(categoria_4s) %>%
  summarise(
    n_proyectos = n(),
    ivu_promedio = round(mean(ivu_base), 3),
    ivp_promedio = round(mean(ivp_base), 3),
    ivu_min = round(min(ivu_base), 3),
    ivu_max = round(max(ivu_base), 3),
    ivp_min = round(min(ivp_base), 3),
    ivp_max = round(max(ivp_base), 3),
    .groups = 'drop'
  )

print(verificacion)

# ---- 4. CONFIGURACI√ìN DE COLORES CORREGIDA ----
cat("\nüé® CONFIGURANDO PALETAS DE COLORES CORREGIDAS...\n")

# Paletas con l√≥gica clara por categor√≠a
colores_4s_correcto <- c(
  "SUPERIOR" = "#1f77b4",      # Azul - Lo mejor en ambos
  "SUSTENTABLE" = "#2ca02c",   # Verde - Buena ubicaci√≥n, proyecto simple
  "S√ìLIDO" = "#ff7f0e",        # Naranja - Buen proyecto, ubicaci√≥n mejorable
  "SINGULAR" = "#d62728",      # Rojo - Necesita mejoras en ambos
  "SIN_CLASIFICAR" = "#cccccc" # Gris - Sin datos suficientes
)

# Funci√≥n para asignar colores de forma segura
asignar_color_seguro <- function(valores, paleta) {
  resultado <- character(length(valores))
  for(i in seq_along(valores)) {
    valor <- as.character(valores[i])
    if(!is.na(valor) && valor %in% names(paleta)) {
      resultado[i] <- paleta[valor]
    } else {
      resultado[i] <- "#cccccc"  # Gris por defecto
    }
  }
  return(resultado)
}

cat("‚úÖ Paletas de colores corregidas configuradas\n")

# ---- 5. INTERFAZ DE SELECCI√ìN DE PROYECTOS ----
cat("\nüéØ CREANDO INTERFAZ DE SELECCI√ìN DE PROYECTOS...\n")

# Funci√≥n para mostrar proyectos disponibles (con IDs consistentes)
mostrar_proyectos_disponibles <- function(datos) {
  cat("\nüìã PROYECTOS DISPONIBLES PARA COMPARACI√ìN:\n")
  cat(rep("=", 50), "\n")
  
  # Crear IDs consistentes basados en la posici√≥n ORIGINAL
  proyectos_info <- datos %>%
    mutate(id_original = row_number()) %>%  # ID basado en posici√≥n original
    select(id_original, Proyecto, Desarrollador, Municipio, Segmento, categoria_4s, ivu_base, ivp_base) %>%
    arrange(categoria_4s, desc(ivu_base)) %>%  # Solo para mostrar ordenado
    mutate(
      info_completa = paste0(
        id_original, ". ", Proyecto, 
        " | Dev: ", Desarrollador,
        " | ", Municipio, 
        " | ", Segmento,
        " | ", categoria_4s,
        " | IVU: ", round(ivu_base, 3),
        " | IVP: ", round(ivp_base, 3)
      )
    )
  
  # Mostrar por categor√≠a
  for(categoria in c("SUPERIOR", "SUSTENTABLE", "S√ìLIDO", "SINGULAR")) {
    proyectos_categoria <- proyectos_info %>% filter(categoria_4s == categoria)
    if(nrow(proyectos_categoria) > 0) {
      cat("\n", categoria, " (", nrow(proyectos_categoria), " proyectos):\n")
      for(i in 1:min(5, nrow(proyectos_categoria))) {  # Mostrar m√°ximo 5 por categor√≠a
        cat("  ", proyectos_categoria$info_completa[i], "\n")
      }
      if(nrow(proyectos_categoria) > 5) {
        cat("  ... y", nrow(proyectos_categoria) - 5, "m√°s\n")
      }
    }
  }
  
  cat("\n", rep("=", 50), "\n")
  cat("üìù INSTRUCCIONES PARA COMPARAR PROYECTOS:\n")
  cat("1. Selecciona el ID del proyecto principal\n")
  cat("2. Opcionalmente selecciona IDs de comparables\n")
  cat("3. Usa la funci√≥n: comparar_proyectos_por_id(id_principal, c(id_comp1, id_comp2))\n")
  cat("4. O usa nombres: comparar_proyectos_por_nombre('Nombre_Proyecto')\n\n")
  
  cat("üîç B√öSQUEDA R√ÅPIDA DE PROYECTO:\n")
  cat("buscar_proyecto('nombre_parcial') - para encontrar un proyecto espec√≠fico\n\n")
  
  return(invisible(proyectos_info))
}

# Funci√≥n para buscar proyectos por nombre parcial
buscar_proyecto <- function(nombre_parcial) {
  cat("\nüîç B√öSQUEDA DE PROYECTO:", nombre_parcial, "\n")
  cat(rep("=", 40), "\n")
  
  resultados <- datos %>%
    mutate(id_original = row_number()) %>%
    filter(grepl(nombre_parcial, Proyecto, ignore.case = TRUE)) %>%
    select(id_original, Proyecto, Desarrollador, Municipio, Segmento, categoria_4s, ivu_base, ivp_base)
  
  if(nrow(resultados) > 0) {
    cat("‚úÖ Proyectos encontrados:\n")
    for(i in 1:nrow(resultados)) {
      cat("  ID:", resultados$id_original[i], "-", resultados$Proyecto[i], 
          "|", resultados$categoria_4s[i], 
          "| IVU:", round(resultados$ivu_base[i], 3),
          "| IVP:", round(resultados$ivp_base[i], 3), "\n")
    }
  } else {
    cat("‚ùå No se encontraron proyectos con ese nombre\n")
  }
  
  return(invisible(resultados))
}

# Funci√≥n mejorada para comparar proyectos por ID (con IDs consistentes)
comparar_proyectos_por_id <- function(id_principal, ids_comparables = NULL, datos_input = NULL) {
  # Usar datos globales si no se pasa un dataset espec√≠fico
  if(is.null(datos_input)) {
    datos_input <- datos
  }
  
  # Usar IDs ORIGINALES (row_number sobre datos sin reordenar)
  proyectos_info <- datos_input %>%
    mutate(id_original = row_number()) %>%
    select(id_original, Proyecto, Desarrollador, Municipio, Segmento, categoria_4s, 
           ivu_base, ivp_base, prob_incremento_nse, indice_atractivo_integral, 
           p_m2, absorcion)
  
  # Validar ID principal
  if(!id_principal %in% proyectos_info$id_original) {
    cat("‚ùå ID principal no v√°lido:", id_principal, "\n")
    cat("IDs disponibles van del 1 al", nrow(proyectos_info), "\n")
    cat("Usa buscar_proyecto('nombre') para encontrar el ID correcto\n")
    return(NULL)
  }
  
  proyecto_principal <- proyectos_info %>% filter(id_original == id_principal)
  nombre_principal <- proyecto_principal$Proyecto
  
  cat("üéØ Proyecto principal:", nombre_principal, "(ID:", id_principal, ")\n")
  
  # Si no se especifican comparables, encontrarlos autom√°ticamente
  if(is.null(ids_comparables)) {
    cat("üîç Buscando proyectos comparables autom√°ticamente...\n")
    comparables_auto <- encontrar_comparables_automatico_simple(nombre_principal, datos_input, n = 2)
    if(nrow(comparables_auto) > 0) {
      # Agregar IDs originales a los comparables
      comparables_con_id <- datos_input %>%
        mutate(id_original = row_number()) %>%
        filter(Proyecto %in% comparables_auto$Proyecto) %>%
        select(names(proyecto_principal))
      proyectos_comparar <- bind_rows(proyecto_principal, comparables_con_id)
    } else {
      cat("‚ö†Ô∏è No se encontraron comparables autom√°ticamente. Usando solo el proyecto principal.\n")
      return(NULL)
    }
  } else {
    # Validar IDs de comparables
    ids_validos <- c()
    proyectos_comp_nombres <- c()
    
    for(id_comp in ids_comparables) {
      if(id_comp %in% proyectos_info$id_original) {
        ids_validos <- c(ids_validos, id_comp)
        nombre_comp <- proyectos_info$Proyecto[proyectos_info$id_original == id_comp]
        proyectos_comp_nombres <- c(proyectos_comp_nombres, nombre_comp)
        cat("‚úÖ Proyecto comparable:", nombre_comp, "(ID:", id_comp, ")\n")
      } else {
        cat("‚ö†Ô∏è ID comparable no v√°lido ignorado:", id_comp, "\n")
      }
    }
    
    if(length(ids_validos) > 0) {
      comparables_seleccionados <- proyectos_info %>% filter(id_original %in% ids_validos)
      proyectos_comparar <- bind_rows(proyecto_principal, comparables_seleccionados)
    } else {
      cat("‚ö†Ô∏è No se encontraron IDs v√°lidos para comparables. Usando solo el proyecto principal.\n")
      return(NULL)
    }
  }
  
  # Crear la comparaci√≥n
  if(nrow(proyectos_comparar) >= 2) {
    resultado <- crear_comparacion_visual(proyectos_comparar)
    return(resultado)
  } else {
    cat("‚ùå Se necesitan al menos 2 proyectos para hacer una comparaci√≥n.\n")
    return(NULL)
  }
}

# Funci√≥n para comparar por nombre (corregida)
comparar_proyectos_por_nombre <- function(nombre_principal, nombres_comparables = NULL) {
  proyecto_principal <- datos %>% filter(Proyecto == nombre_principal)
  
  if(nrow(proyecto_principal) == 0) {
    stop("‚ùå Proyecto no encontrado: ", nombre_principal)
  }
  
  if(is.null(nombres_comparables)) {
    cat("üîç Buscando proyectos comparables autom√°ticamente...\n")
    comparables_auto <- encontrar_comparables_automatico_simple(nombre_principal, datos, n = 2)
    if(nrow(comparables_auto) > 0) {
      proyectos_comparar <- bind_rows(proyecto_principal, comparables_auto)
    } else {
      cat("‚ö†Ô∏è No se encontraron comparables autom√°ticamente. Usando solo el proyecto principal.\n")
      proyectos_comparar <- proyecto_principal
    }
  } else {
    comparables_seleccionados <- datos %>% filter(Proyecto %in% nombres_comparables)
    if(nrow(comparables_seleccionados) > 0) {
      proyectos_comparar <- bind_rows(proyecto_principal, comparables_seleccionados)
    } else {
      cat("‚ö†Ô∏è No se encontraron proyectos con los nombres especificados. Usando solo el proyecto principal.\n")
      proyectos_comparar <- proyecto_principal
    }
  }
  
  if(nrow(proyectos_comparar) >= 2) {
    resultado <- crear_comparacion_visual(proyectos_comparar)
    return(resultado)
  } else {
    cat("‚ùå Se necesitan al menos 2 proyectos para hacer una comparaci√≥n.\n")
    return(NULL)
  }
}

# Funci√≥n para encontrar comparables autom√°ticamente (simplificada y corregida)
encontrar_comparables_automatico_simple <- function(proyecto_nombre, datos_input, n = 2) {
  proyecto_ref <- datos_input %>% filter(Proyecto == proyecto_nombre)
  
  if(nrow(proyecto_ref) == 0) {
    cat("‚ùå Proyecto no encontrado: ", proyecto_nombre, "\n")
    return(data.frame())
  }
  
  # Criterios de comparabilidad simplificados y seguros
  comparables <- datos_input %>%
    filter(Proyecto != proyecto_nombre & 
             !is.na(Segmento) & !is.na(Municipio) & 
             !is.na(p_m2) & !is.na(categoria_4s)) %>%
    mutate(
      score_similitud = 0,
      # Mismo segmento (peso 40%)
      score_similitud = ifelse(Segmento == proyecto_ref$Segmento, score_similitud + 40, score_similitud),
      # Mismo municipio (peso 30%)
      score_similitud = ifelse(Municipio == proyecto_ref$Municipio, score_similitud + 30, score_similitud),
      # Misma categor√≠a 4S (peso 20%)
      score_similitud = ifelse(categoria_4s == proyecto_ref$categoria_4s, score_similitud + 20, score_similitud),
      # Precio similar ¬±30% (peso 10%)
      diferencia_precio = abs(p_m2 - proyecto_ref$p_m2) / proyecto_ref$p_m2,
      score_similitud = ifelse(diferencia_precio <= 0.3, score_similitud + 10, score_similitud)
    ) %>%
    arrange(desc(score_similitud)) %>%
    head(n)
  
  if(nrow(comparables) > 0) {
    cat("‚úÖ Comparables encontrados:\n")
    for(i in 1:nrow(comparables)) {
      cat("  ", i, ".", comparables$Proyecto[i], " (Similitud:", comparables$score_similitud[i], "%)\n")
    }
  } else {
    cat("‚ö†Ô∏è No se encontraron proyectos comparables.\n")
  }
  
  return(comparables)
}

# Mostrar proyectos disponibles al cargar
proyectos_disponibles <- mostrar_proyectos_disponibles(datos)

# ---- 6. FUNCI√ìN DE COMPARACI√ìN VISUAL MEJORADA ----
crear_comparacion_visual <- function(proyectos_comparar) {
  if(nrow(proyectos_comparar) < 2) {
    stop("‚ùå Se necesitan al menos 2 proyectos para comparar")
  }
  
  # Preparar datos para visualizaci√≥n
  datos_largo <- proyectos_comparar %>%
    select(Proyecto, ivu_base, ivp_base, prob_incremento_nse, indice_atractivo_integral) %>%
    pivot_longer(cols = -Proyecto, names_to = "Metrica", values_to = "Valor") %>%
    mutate(
      Metrica = case_when(
        Metrica == "ivu_base" ~ "IVU",
        Metrica == "ivp_base" ~ "IVP", 
        Metrica == "prob_incremento_nse" ~ "Evoluci√≥n NSE",
        Metrica == "indice_atractivo_integral" ~ "√çndice Integral"
      ),
      Metrica = factor(Metrica, levels = c("IVU", "IVP", "Evoluci√≥n NSE", "√çndice Integral"))
    )
  
  # Gr√°fico de barras comparativo
  grafico_barras <- ggplot(datos_largo, aes(x = Metrica, y = Valor, fill = Proyecto)) +
    geom_col(position = "dodge", alpha = 0.8, color = "white", size = 0.5) +
    scale_fill_brewer(type = "qual", palette = "Set2") +
    scale_y_continuous(limits = c(0, 1), labels = scales::percent_format()) +
    labs(
      title = "Comparaci√≥n de M√©tricas Clave",
      subtitle = paste("Proyectos:", paste(proyectos_comparar$Proyecto, collapse = " vs ")),
      x = "M√©tricas de Evaluaci√≥n",
      y = "Valor (0-100%)",
      fill = "Proyecto"
    ) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      plot.title = element_text(size = 14, face = "bold"),
      legend.position = "bottom"
    )
  
  # Mostrar en RStudio
  print(grafico_barras)
  
  # Crear tabla comparativa
  tabla_comparativa <- proyectos_comparar %>%
    mutate(
      IVU = paste0(round(ivu_base * 100, 1), "%"),
      IVP = paste0(round(ivp_base * 100, 1), "%"),
      `Evoluci√≥n NSE` = paste0(round(prob_incremento_nse * 100, 1), "%"),
      `√çndice Integral` = paste0(round(indice_atractivo_integral * 100, 1), "%"),
      `Precio/m¬≤` = paste0("$", format(p_m2, big.mark = ",")),
      `Absorci√≥n` = paste0(round(absorcion * 100, 1), "%")
    ) %>%
    select(Proyecto, Desarrollador, Municipio, Segmento, categoria_4s, 
           IVU, IVP, `Evoluci√≥n NSE`, `√çndice Integral`, `Precio/m¬≤`, `Absorci√≥n`)
  
  cat("\nüìä TABLA COMPARATIVA:\n")
  print(tabla_comparativa)
  
  # Guardar gr√°fico
  nombre_archivo <- paste0("comparacion_", 
                           gsub("[^A-Za-z0-9]", "_", proyectos_comparar$Proyecto[1]), 
                           "_", timestamp, ".png")
  ggsave(nombre_archivo, grafico_barras, width = 12, height = 8, dpi = 300)
  
  return(list(
    grafico = grafico_barras,
    tabla = tabla_comparativa,
    datos = proyectos_comparar,
    archivo = nombre_archivo
  ))
}

# ---- 7. MATRICES IVU-IVP CORREGIDAS POR SEGMENTO ----
cat("\nüìä CREANDO MATRICES IVU-IVP CORREGIDAS POR SEGMENTO...\n")

# Funci√≥n CORREGIDA para crear matriz por segmento
crear_matriz_segmento_corregida <- function(segmento_seleccionado) {
  datos_segmento <- datos %>%
    filter(Segmento == segmento_seleccionado & 
             !is.na(ivu_base) & !is.na(ivp_base) & 
             !is.na(categoria_4s))
  
  if(nrow(datos_segmento) == 0) {
    cat("‚ö†Ô∏è  No hay datos para el segmento:", segmento_seleccionado, "\n")
    return(NULL)
  }
  
  # Verificar que la categorizaci√≥n es correcta
  datos_segmento <- datos_segmento %>%
    mutate(categoria_4s_verificada = categorizar_4s_correcto(ivu_base, ivp_base))
  
  # PRIMERO: Crear el gr√°fico interactivo CON HOVER SIMPLIFICADO Y LEGIBLE
  grafico_interactivo <- plot_ly(
    data = datos_segmento,
    x = ~ivu_base, 
    y = ~ivp_base,
    color = ~categoria_4s_verificada,
    colors = colores_4s_correcto,
    # Usar customdata para informaci√≥n adicional
    customdata = ~paste(Desarrollador, "|", Municipio, "|", Segmento, "|", format(p_m2, big.mark = ",")),
    hovertemplate = paste0(
      "<b>%{hovertext}</b><br>",
      "<br>",
      "IVU: %{x:.1%}<br>",
      "IVP: %{y:.1%}<br>",
      "Categor√≠a: %{fullData.color}<br>",
      "<br>",
      "Desarrollador: %{customdata[0]}<br>",
      "Municipio: %{customdata[1]}<br>",
      "Segmento: %{customdata[2]}<br>",
      "Precio/m¬≤: $%{customdata[3]}<br>",
      "<extra></extra>"
    ),
    hovertext = ~Proyecto,
    type = "scatter",
    mode = "markers",
    marker = list(size = 12, opacity = 0.8)
  ) %>%
    layout(
      title = list(
        text = paste("Matriz IVU vs IVP - Segmento:", segmento_seleccionado),
        font = list(size = 16)
      ),
      xaxis = list(
        title = "IVU - √çndice de Valor por Ubicaci√≥n",
        tickformat = ".0%",
        range = c(0, 1)
      ),
      yaxis = list(
        title = "IVP - √çndice de Valor del Proyecto",
        tickformat = ".0%",
        range = c(0, 1)
      ),
      # Configuraci√≥n del hover simplificada pero efectiva
      hoverlabel = list(
        bgcolor = "white",
        bordercolor = "black",
        font = list(
          family = "Arial",
          size = 14,
          color = "black"
        )
      ),
      shapes = list(
        # L√≠nea vertical en 0.5
        list(type = "line", x0 = 0.5, x1 = 0.5, y0 = 0, y1 = 1, 
             line = list(color = "gray", dash = "dash", width = 2)),
        # L√≠nea horizontal en 0.5
        list(type = "line", x0 = 0, x1 = 1, y0 = 0.5, y1 = 0.5,
             line = list(color = "gray", dash = "dash", width = 2))
      ),
      annotations = list(
        list(x = 0.25, y = 0.75, text = "S√ìLIDO", showarrow = FALSE, 
             font = list(size = 14, color = "gray40")),
        list(x = 0.75, y = 0.75, text = "SUPERIOR", showarrow = FALSE, 
             font = list(size = 14, color = "gray40")),
        list(x = 0.25, y = 0.25, text = "SINGULAR", showarrow = FALSE, 
             font = list(size = 14, color = "gray40")),
        list(x = 0.75, y = 0.25, text = "SUSTENTABLE", showarrow = FALSE, 
             font = list(size = 14, color = "gray40"))
      )
    )
  
  # SEGUNDO: Mostrar el gr√°fico (DESPU√âS de crearlo)
  print(grafico_interactivo)
  
  # TERCERO: Crear el gr√°fico ggplot para guardar
  grafico_ggplot <- ggplot(datos_segmento, aes(x = ivu_base, y = ivp_base, color = categoria_4s_verificada)) +
    geom_point(size = 4, alpha = 0.8) +
    scale_color_manual(values = colores_4s_correcto, name = "Categor√≠a 4S") +
    geom_vline(xintercept = 0.5, linetype = "dashed", color = "gray30", linewidth = 1) +
    geom_hline(yintercept = 0.5, linetype = "dashed", color = "gray30", linewidth = 1) +
    annotate("text", x = 0.25, y = 0.75, label = "S√ìLIDO", 
             color = "gray40", size = 5, fontface = "bold") +
    annotate("text", x = 0.75, y = 0.75, label = "SUPERIOR", 
             color = "gray40", size = 5, fontface = "bold") +
    annotate("text", x = 0.25, y = 0.25, label = "SINGULAR", 
             color = "gray40", size = 5, fontface = "bold") +
    annotate("text", x = 0.75, y = 0.25, label = "SUSTENTABLE", 
             color = "gray40", size = 5, fontface = "bold") +
    scale_x_continuous(limits = c(0, 1), labels = scales::percent_format()) +
    scale_y_continuous(limits = c(0, 1), labels = scales::percent_format()) +
    labs(
      title = paste("Matriz IVU vs IVP - Segmento:", segmento_seleccionado),
      subtitle = paste("Proyectos analizados:", nrow(datos_segmento), "| Categorizaci√≥n corregida"),
      x = "IVU - √çndice de Valor por Ubicaci√≥n",
      y = "IVP - √çndice de Valor del Proyecto",
      caption = "L√≠neas divisorias en 50% para cada √≠ndice"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      plot.subtitle = element_text(size = 12),
      legend.position = "bottom",
      panel.grid.minor = element_blank()
    )
  
  # Guardar archivos
  nombre_base <- gsub(" ", "_", tolower(segmento_seleccionado))
  ggsave(paste0("matriz_", nombre_base, "_corregida.png"), 
         grafico_ggplot, width = 12, height = 9, dpi = 300)
  
  saveWidget(grafico_interactivo, 
             paste0("matriz_", nombre_base, "_corregida_interactiva.html"))
  
  # Estad√≠sticas del segmento
  estadisticas <- datos_segmento %>%
    group_by(categoria_4s_verificada) %>%
    summarise(
      n_proyectos = n(),
      ivu_promedio = round(mean(ivu_base), 3),
      ivp_promedio = round(mean(ivp_base), 3),
      .groups = 'drop'
    )
  
  cat("üìä Estad√≠sticas del segmento", segmento_seleccionado, ":\n")
  print(estadisticas)
  
  return(list(
    ggplot = grafico_ggplot,
    plotly = grafico_interactivo,
    datos = datos_segmento,
    estadisticas = estadisticas
  ))
}

# Crear matrices para cada segmento
segmentos_disponibles <- unique(datos$Segmento)
segmentos_disponibles <- segmentos_disponibles[!is.na(segmentos_disponibles)]

cat("üìä Segmentos encontrados:", paste(segmentos_disponibles, collapse = ", "), "\n")

matrices_corregidas <- list()
for(segmento in segmentos_disponibles) {
  cat("\n--- Creando matriz corregida para segmento:", segmento, "---\n")
  matrices_corregidas[[segmento]] <- crear_matriz_segmento_corregida(segmento)
}

cat("‚úÖ Matrices corregidas por segmento creadas\n")

# ---- 8. MAPAS INTERACTIVOS CORREGIDOS ----
cat("\nüó∫Ô∏è  CREANDO MAPAS INTERACTIVOS CORREGIDOS...\n")

# Preparar datos para mapas
datos_mapa <- datos %>%
  filter(!is.na(Latitud) & !is.na(Longitud) &
           Latitud != 0 & Longitud != 0 &
           !is.na(categoria_4s)) %>%
  mutate(
    popup_label = paste0(
      "<b>", Proyecto, "</b><br/>",
      "Desarrollador: ", Desarrollador, "<br/>",
      "Municipio: ", Municipio, "<br/>",
      "Segmento: ", Segmento, "<br/>",
      "IVU: ", round(ivu_base, 3), " (", round(ivu_base*100, 1), "%)<br/>",
      "IVP: ", round(ivp_base, 3), " (", round(ivp_base*100, 1), "%)<br/>",
      "Categor√≠a 4S: ", categoria_4s, "<br/>",
      "Precio/m¬≤: $", format(p_m2, big.mark = ",")
    )
  )

# Funci√≥n para crear mapa base
crear_mapa_base <- function(datos, titulo) {
  centro_lat <- mean(datos$Latitud, na.rm = TRUE)
  centro_lng <- mean(datos$Longitud, na.rm = TRUE)
  
  leaflet(datos) %>%
    addTiles() %>%
    setView(lng = centro_lng, lat = centro_lat, zoom = 11) %>%
    addControl(titulo, position = "topright")
}

# Mapa 4S corregido
mapa_4s_corregido <- datos_mapa %>%
  mutate(color_asignado = asignar_color_seguro(categoria_4s, colores_4s_correcto)) %>%
  crear_mapa_base("Categorizaci√≥n 4S - Corregida") %>%
  addCircleMarkers(
    lng = ~Longitud, lat = ~Latitud,
    radius = 10,
    fillColor = ~color_asignado,
    color = "white",
    weight = 2,
    fillOpacity = 0.8,
    popup = ~popup_label
  ) %>%
  addLegend(
    "bottomright",
    colors = colores_4s_correcto,
    labels = names(colores_4s_correcto),
    title = "Categor√≠a 4S",
    opacity = 0.8
  )

# Mostrar y guardar mapa
print(mapa_4s_corregido)
saveWidget(mapa_4s_corregido, "mapa_4s_corregido.html")

cat("‚úÖ Mapas corregidos creados\n")

# ---- 9. AN√ÅLISIS DE FORTALEZAS ----
# ---- FUNCI√ìN M√çNIMA: SOLO VARIABLES CONFIRMADAS ----
# Solo usa las 9 variables que aparecen en tu lista disponible

crear_perfil_fortalezas_inversion <- function(nombres_proyectos) {
  
  # Validar que los proyectos existan
  proyectos_encontrados <- datos %>%
    filter(Proyecto %in% nombres_proyectos)
  
  if(nrow(proyectos_encontrados) == 0) {
    stop("‚ùå No se encontraron los proyectos especificados")
  }
  
  cat("üîç Analizando", nrow(proyectos_encontrados), "proyectos...\n")
  
  # SOLO usar las variables que confirmaste est√°n disponibles:
  # absorcion, Absorcion_por_proyecto, ratio_ventas, meses_mercado, 
  # unidades_vendidas, unidades_totales, ivu, ivp, nse, prob_incremento_nse
  
  perfiles <- proyectos_encontrados %>%
    mutate(
      # Usar la variable correcta para absorci√≥n
      absorcion_final = case_when(
        !is.na(absorcion) ~ absorcion,
        !is.na(Absorcion_por_proyecto) ~ Absorcion_por_proyecto,
        TRUE ~ 0.5
      ),
      
      # 1. PERFORMANCE COMERCIAL (0-100)
      # Solo usar absorcion + ratio_ventas
      performance_comercial = case_when(
        !is.na(absorcion_final) & !is.na(ratio_ventas) ~ 
          pmin(100, pmax(0, 
                         (pmin(2, absorcion_final) * 50) * 0.6 +  # Absorci√≥n max 200% = 100pts
                           (ratio_ventas * 100) * 0.4               # % Vendido
          )),
        !is.na(absorcion_final) ~ 
          pmin(100, pmax(0, pmin(2, absorcion_final) * 50)),
        !is.na(ratio_ventas) ~ 
          pmin(100, pmax(0, ratio_ventas * 100)),
        TRUE ~ 50
      ),
      
      # 2. FORTALEZA UBICACI√ìN (0-100)
      # Solo usar IVU
      fortaleza_ubicacion = case_when(
        !is.na(ivu) ~ pmin(100, pmax(0, ivu * 100)),
        TRUE ~ 50
      ),
      
      # 3. MOMENTUM MERCADO (0-100)
      # Convertir NSE + probabilidad incremento + timing
      nse_numerico = case_when(
        nse == "A+" ~ 6, nse == "A" ~ 5.5, nse == "B" ~ 5, 
        nse == "C+" ~ 4, nse == "C" ~ 3, nse == "D+" ~ 2, 
        nse == "D" ~ 1, nse == "E" ~ 0.5,
        is.numeric(nse) ~ as.numeric(nse),
        TRUE ~ 3
      ),
      
      # Factor timing basado en meses en mercado
      timing_factor = case_when(
        !is.na(meses_mercado) ~ pmin(100, pmax(0, 100 - (meses_mercado - 12) * 2)),
        TRUE ~ 50
      ),
      
      momentum_mercado = case_when(
        !is.na(prob_incremento_nse) & !is.na(nse_numerico) ~ 
          pmin(100, pmax(0,
                         (prob_incremento_nse * 100) * 0.5 +    # Potencial NSE
                           (nse_numerico / 6 * 100) * 0.3 +       # NSE actual  
                           timing_factor * 0.2                    # Factor timing
          )),
        !is.na(prob_incremento_nse) ~ 
          pmin(100, pmax(0, prob_incremento_nse * 100)),
        !is.na(nse_numerico) ~ 
          pmin(100, pmax(0, nse_numerico / 6 * 100)),
        TRUE ~ 50
      ),
      
      # 4. EFICIENCIA OPERATIVA (0-100)
      # Usar variables de unidades y tiempo
      eficiencia_ventas = case_when(
        !is.na(unidades_vendidas) & !is.na(unidades_totales) & unidades_totales > 0 ~
          (unidades_vendidas / unidades_totales) * 100,
        TRUE ~ 50
      ),
      
      velocidad_ventas = case_when(
        !is.na(unidades_vendidas) & !is.na(meses_mercado) & meses_mercado > 0 ~
          pmin(100, (unidades_vendidas / meses_mercado) * 10), # 10 unidades/mes = 100pts
        TRUE ~ 50
      ),
      
      eficiencia_operativa = pmin(100, pmax(0,
                                            eficiencia_ventas * 0.6 + velocidad_ventas * 0.4
      )),
      
      # 5. CALIDAD DEL PROYECTO (0-100)
      # Solo usar IVP (ya que no tenemos score_amenidades_total)
      calidad_proyecto = case_when(
        !is.na(ivp) ~ pmin(100, pmax(0, ivp * 100)),
        TRUE ~ 50
      )
    ) %>%
    select(Proyecto, performance_comercial, fortaleza_ubicacion, 
           momentum_mercado, eficiencia_operativa, calidad_proyecto)
  
  # Preparar datos para el gr√°fico de radar
  categorias <- c("Performance\nComercial", "Fortaleza\nUbicaci√≥n", 
                  "Momentum\nMercado", "Eficiencia\nOperativa", 
                  "Calidad\nProyecto")
  
  # Crear el gr√°fico de radar
  fig <- plot_ly(type = "scatterpolar", mode = "lines+markers")
  
  # Colores
  colores_radar <- c("#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd")
  
  # Agregar cada proyecto al gr√°fico
  for(i in 1:nrow(perfiles)) {
    proyecto <- perfiles[i, ]
    
    valores <- c(
      proyecto$performance_comercial,
      proyecto$fortaleza_ubicacion, 
      proyecto$momentum_mercado,
      proyecto$eficiencia_operativa,
      proyecto$calidad_proyecto,
      proyecto$performance_comercial  # Cerrar pol√≠gono
    )
    
    categorias_cerradas <- c(categorias, categorias[1])
    
    fig <- fig %>%
      add_trace(
        r = valores,
        theta = categorias_cerradas,
        name = proyecto$Proyecto,
        line = list(color = colores_radar[i], width = 3),
        marker = list(color = colores_radar[i], size = 8),
        fill = "toself",
        fillcolor = paste0(colores_radar[i], "30"),
        hovertemplate = paste0(
          "<b>%{fullData.name}</b><br>",
          "%{theta}: %{r:.1f}/100<br>",
          "<extra></extra>"
        )
      )
  }
  
  # Layout del radar
  fig <- fig %>%
    layout(
      title = list(
        text = "Perfil de Fortalezas Inmobiliarias",
        font = list(size = 18, family = "Arial", color = "black")
      ),
      polar = list(
        radialaxis = list(
          visible = TRUE,
          range = c(0, 100),
          tickmode = "linear",
          tick0 = 0,
          dtick = 20,
          tickfont = list(size = 11),
          gridcolor = "lightgray"
        ),
        angularaxis = list(
          tickfont = list(size = 11, family = "Arial"),
          direction = "clockwise",
          rotation = 90
        ),
        bgcolor = "white"
      ),
      legend = list(
        orientation = "h",
        x = 0.5,
        xanchor = "center",
        y = -0.2,
        font = list(size = 11)
      ),
      margin = list(t = 80, b = 120, l = 80, r = 80)
    )
  
  # Mostrar el gr√°fico
  print(fig)
  
  # Guardar como HTML
  nombres_archivo <- paste(gsub("[^A-Za-z0-9]", "_", nombres_proyectos), collapse = "_vs_")
  archivo_html <- paste0("perfil_fortalezas_", nombres_archivo, ".html")
  saveWidget(fig, archivo_html)
  
  # Tabla de resultados
  cat("\nüìä PERFIL DE FORTALEZAS:\n")
  tabla_valores <- perfiles %>%
    mutate(
      `Performance Comercial` = round(performance_comercial, 1),
      `Fortaleza Ubicaci√≥n` = round(fortaleza_ubicacion, 1),
      `Momentum Mercado` = round(momentum_mercado, 1),
      `Eficiencia Operativa` = round(eficiencia_operativa, 1),
      `Calidad Proyecto` = round(calidad_proyecto, 1),
      
      `Score Promedio` = round(
        (performance_comercial + fortaleza_ubicacion + momentum_mercado + 
           eficiencia_operativa + calidad_proyecto) / 5, 1
      )
    ) %>%
    select(Proyecto, `Performance Comercial`, `Fortaleza Ubicaci√≥n`, 
           `Momentum Mercado`, `Eficiencia Operativa`, `Calidad Proyecto`, 
           `Score Promedio`) %>%
    arrange(desc(`Score Promedio`))
  
  print(tabla_valores)
  
  # An√°lisis comparativo
  cat("\nüí° AN√ÅLISIS COMPARATIVO:\n")
  if(nrow(perfiles) > 1) {
    for(i in 1:nrow(perfiles)) {
      proyecto <- perfiles[i, ]
      scores <- c(proyecto$performance_comercial, proyecto$fortaleza_ubicacion, 
                  proyecto$momentum_mercado, proyecto$eficiencia_operativa, proyecto$calidad_proyecto)
      nombres_scores <- c("Performance Comercial", "Fortaleza Ubicaci√≥n", 
                          "Momentum Mercado", "Eficiencia Operativa", "Calidad Proyecto")
      
      max_idx <- which.max(scores)
      min_idx <- which.min(scores)
      
      cat("\nüéØ", proyecto$Proyecto, ":\n")
      cat("  ‚úÖ Fortaleza principal:", nombres_scores[max_idx], "(", round(scores[max_idx], 1), "/100)\n")
      cat("  ‚ö†Ô∏è  √Årea de mejora:", nombres_scores[min_idx], "(", round(scores[min_idx], 1), "/100)\n")
      
      score_total <- mean(scores)
      cat("  üìä Score general:", round(score_total, 1), "/100\n")
    }
  }
  
  cat("\n‚úÖ Gr√°fico guardado como:", archivo_html, "\n")
  
  return(list(
    grafico = fig,
    datos = perfiles,
    tabla = tabla_valores,
    archivo = archivo_html
  ))
}

# Funci√≥n auxiliar por IDs
crear_perfil_fortalezas_inversion_por_id <- function(ids_proyectos) {
  proyectos_info <- datos %>%
    mutate(id_original = row_number()) %>%
    filter(id_original %in% ids_proyectos) %>%
    select(id_original, Proyecto)
  
  if(nrow(proyectos_info) == 0) {
    stop("‚ùå No se encontraron proyectos con esos IDs")
  }
  
  cat("üéØ Proyectos seleccionados:\n")
  for(i in 1:nrow(proyectos_info)) {
    cat("  ID:", proyectos_info$id_original[i], "-", proyectos_info$Proyecto[i], "\n")
  }
  
  nombres_proyectos <- proyectos_info$Proyecto
  return(crear_perfil_fortalezas_inversion(nombres_proyectos))
}

# Prueba con variables m√≠nimas
verificar_solo_variables_confirmadas <- function() {
  variables_confirmadas <- c("absorcion", "Absorcion_por_proyecto", "ratio_ventas", 
                             "meses_mercado", "unidades_vendidas", "unidades_totales", 
                             "ivu", "ivp", "nse", "prob_incremento_nse")
  
  cat("üîç VERIFICANDO SOLO VARIABLES CONFIRMADAS:\n")
  for(var in variables_confirmadas) {
    if(var %in% names(datos)) {
      cat("‚úÖ", var, "\n")
    } else {
      cat("‚ùå", var, "- NO ENCONTRADA\n")
    }
  }
}

cat("\nüöÄ FUNCI√ìN M√çNIMA CARGADA - SOLO USA 9 VARIABLES CONFIRMADAS\n")
cat("üìã Las variables que usa:\n")
cat("  absorcion, Absorcion_por_proyecto, ratio_ventas, meses_mercado,\n")
cat("  unidades_vendidas, unidades_totales, ivu, ivp, nse, prob_incremento_nse\n")
cat("\n‚úÖ AHORA DEBER√çA FUNCIONAR SIN ERRORES\n")

# ---- 9. EJEMPLOS PR√ÅCTICOS PASO A PASO ----
cat("\nüéØ EJEMPLOS PR√ÅCTICOS PASO A PASO...\n")

# Funci√≥n para hacer un ejemplo pr√°ctico completo
ejemplo_comparacion_completa <- function() {
  cat("\nüìö TUTORIAL COMPLETO DE COMPARACI√ìN DE PROYECTOS\n")
  cat(rep("=", 60), "\n")
  
  # Paso 1: Mostrar primeros proyectos por categor√≠a
  cat("\nüìã PASO 1: SELECCIONAR PROYECTOS PARA COMPARAR\n")
  cat("Primeros 3 proyectos por categor√≠a:\n\n")
  
  for(categoria in c("SUPERIOR", "SUSTENTABLE", "S√ìLIDO", "SINGULAR")) {
    proyectos_cat <- datos %>%
      filter(categoria_4s == categoria) %>%
      head(3) %>%
      mutate(id = row_number())
    
    if(nrow(proyectos_cat) > 0) {
      cat("üîµ", categoria, ":\n")
      for(i in 1:nrow(proyectos_cat)) {
        # Buscar el ID real
        id_real <- which(datos$Proyecto == proyectos_cat$Proyecto[i])
        cat("  ID:", id_real, "-", proyectos_cat$Proyecto[i], "\n")
      }
      cat("\n")
    }
  }
  
  # Paso 2: Ejemplo pr√°ctico
  cat("üìä PASO 2: EJEMPLO DE COMPARACI√ìN\n")
  cat("Vamos a comparar el primer proyecto SUPERIOR con dos SUSTENTABLES:\n\n")
  
  # Buscar proyectos para el ejemplo
  proyecto_superior <- datos %>% 
    filter(categoria_4s == "SUPERIOR") %>% 
    head(1)
  
  proyectos_sustentables <- datos %>% 
    filter(categoria_4s == "SUSTENTABLE") %>% 
    head(2)
  
  if(nrow(proyecto_superior) > 0 && nrow(proyectos_sustentables) >= 2) {
    id_superior <- which(datos$Proyecto == proyecto_superior$Proyecto[1])
    id_sust1 <- which(datos$Proyecto == proyectos_sustentables$Proyecto[1])
    id_sust2 <- which(datos$Proyecto == proyectos_sustentables$Proyecto[2])
    
    cat("Ejecutando: comparar_proyectos_por_id(", id_superior, ", c(", id_sust1, ",", id_sust2, "))\n\n")
    
    tryCatch({
      resultado <- comparar_proyectos_por_id(id_superior, c(id_sust1, id_sust2))
      cat("‚úÖ Ejemplo completado exitosamente!\n")
      return(resultado)
    }, error = function(e) {
      cat("‚ö†Ô∏è Error en el ejemplo:", e$message, "\n")
      return(NULL)
    })
  } else {
    cat("‚ö†Ô∏è No hay suficientes proyectos para el ejemplo autom√°tico.\n")
    return(NULL)
  }
}

# Funci√≥n para gu√≠a r√°pida
guia_rapida_uso <- function() {
  cat("\n‚ö° GU√çA R√ÅPIDA DE USO\n")
  cat(rep("=", 40), "\n")
  cat("1Ô∏è‚É£ Ver proyectos: mostrar_proyectos_disponibles(datos)\n")
  cat("2Ô∏è‚É£ Comparar por ID: comparar_proyectos_por_id(ID_principal, c(ID1, ID2))\n")
  cat("3Ô∏è‚É£ Comparar por nombre: comparar_proyectos_por_nombre('Nombre')\n")
  cat("4Ô∏è‚É£ Crear matriz: crear_matriz_segmento_corregida('Segmento')\n\n")
  
  cat("üí° EJEMPLOS R√ÅPIDOS:\n")
  cat("comparar_proyectos_por_id(1)  # Comparaci√≥n autom√°tica\n")
  cat("comparar_proyectos_por_id(1, c(5, 10))  # Comparaci√≥n espec√≠fica\n")
  cat("comparar_proyectos_por_nombre('Una')  # Por nombre\n\n")
}

# Ejecutar gu√≠a r√°pida
guia_rapida_uso()

# Ejecutar ejemplo completo
cat("\nüéÆ EJECUTANDO EJEMPLO PR√ÅCTICO AUTOM√ÅTICO...\n")
resultado_ejemplo <- ejemplo_comparacion_completa()

# B√∫squeda espec√≠fica para los proyectos mencionados por el usuario
cat("\nüîç B√öSQUEDA ESPEC√çFICA PARA TU EJEMPLO:\n")
cat("Buscando Luna, Parc 302 y Ventum Torre 3...\n\n")

# Buscar Luna
luna_resultado <- buscar_proyecto("Luna")
# Buscar Parc 302  
parc_resultado <- buscar_proyecto("Parc 302")
# Buscar Ventum Torre 3
ventum_resultado <- buscar_proyecto("Ventum Torre 3")

# Mostrar comandos espec√≠ficos si se encontraron los proyectos
if(nrow(luna_resultado) > 0 && nrow(parc_resultado) > 0 && nrow(ventum_resultado) > 0) {
  luna_id <- luna_resultado$id_original[1]
  parc_id <- parc_resultado$id_original[1] 
  ventum_id <- ventum_resultado$id_original[1]
  
  cat("\n‚úÖ COMANDO ESPEC√çFICO PARA TU EJEMPLO:\n")
  cat("resultado <- comparar_proyectos_por_id(", luna_id, ", c(", parc_id, ", ", ventum_id, "))\n")
  cat("# Esto comparar√°:", luna_resultado$Proyecto[1], "vs", parc_resultado$Proyecto[1], "vs", ventum_resultado$Proyecto[1], "\n\n")
}

# ---- 10. GU√çA DE USO COMPLETA ----
cat("\nüìñ GU√çA DE USO DEL SISTEMA CORREGIDO\n")
cat("=====================================\n")

cat("\nüîß CORRECCIONES IMPLEMENTADAS:\n")
cat("‚úÖ Categorizaci√≥n 4S corregida seg√∫n posici√≥n en matriz\n")
cat("‚úÖ Interfaz clara para selecci√≥n de proyectos\n")
cat("‚úÖ Colores consistentes con la l√≥gica de categor√≠as\n")
cat("‚úÖ Verificaci√≥n autom√°tica de categorizaci√≥n\n")

cat("\nüéØ FUNCIONES PRINCIPALES:\n")
cat("1. mostrar_proyectos_disponibles(datos) - Lista todos los proyectos\n")
cat("2. comparar_proyectos_por_id(id_principal, c(id1, id2)) - Comparaci√≥n por ID\n")
cat("3. comparar_proyectos_por_nombre('Proyecto') - Comparaci√≥n por nombre\n")
cat("4. crear_matriz_segmento_corregida('Segmento') - Matriz espec√≠fica\n")

cat("\nüó∫Ô∏è  ARCHIVOS GENERADOS:\n")
cat("- mapa_4s_corregido.html (mapa interactivo corregido)\n")
cat("- matriz_[segmento]_corregida.png (matrices est√°ticas)\n")
cat("- matriz_[segmento]_corregida_interactiva.html (matrices interactivas)\n")
cat("- comparacion_[proyecto]_[timestamp].png (comparaciones)\n")

cat("\nüìä L√ìGICA DE CATEGORIZACI√ìN 4S (Etiquetas Visuales Actualizadas):\n")
cat("üîµ SUPERIOR: IVU ‚â• 50% e IVP ‚â• 50% (lo mejor en ambos) - Cuadrante superior derecho\n")
cat("üü† S√ìLIDO: IVU ‚â• 50% e IVP < 50% (buena ubicaci√≥n, proyecto simple) - Cuadrante superior izquierdo\n")
cat("üü¢ SUSTENTABLE: IVU < 50% e IVP ‚â• 50% (buen proyecto, ubicaci√≥n mejorable) - Cuadrante inferior derecho\n")
cat("üî¥ SINGULAR: IVU < 50% e IVP < 50% (necesita mejoras en ambos) - Cuadrante inferior izquierdo\n")

# ---- 11. RESUMEN EJECUTIVO ----
cat("\n", rep("=", 70), "\n")
cat("SCRIPT 4 CORREGIDO: VISUALIZACIONES CON CATEGORIZACI√ìN 4S CORRECTA - COMPLETADO\n")
cat(rep("=", 70), "\n")

cat("\n‚úÖ PROBLEMAS SOLUCIONADOS:\n")
cat("üîß Categorizaci√≥n 4S ahora refleja correctamente la posici√≥n en matriz\n")
cat("üéØ Interfaz clara para selecci√≥n y comparaci√≥n de proyectos\n")
cat("üé® Colores consistentes con la l√≥gica de cada categor√≠a\n")
cat("üìä Verificaci√≥n autom√°tica de clasificaciones\n")

cat("\nüìä ESTAD√çSTICAS FINALES:\n")
cat("- Proyectos procesados:", nrow(datos), "\n")
cat("- Segmentos analizados:", length(segmentos_disponibles), "\n")
cat("- Matrices corregidas generadas:", length(matrices_corregidas), "\n")

# Distribuci√≥n final corregida
distribucion_final <- table(datos$categoria_4s, useNA = "ifany")
cat("\nüéØ Distribuci√≥n final categorizaci√≥n 4S:\n")
for(categoria in names(distribucion_final)) {
  pct <- round(distribucion_final[categoria] / sum(distribucion_final) * 100, 1)
  cat("   ", categoria, ":", distribucion_final[categoria], "(", pct, "%)\n")
}

cat("\nüöÄ PR√ìXIMOS PASOS:\n")
cat("1. Usar las funciones corregidas para analizar proyectos espec√≠ficos\n")
cat("2. Revisar las matrices por segmento para insights estrat√©gicos\n")
cat("3. Continuar con Script 5: An√°lisis integral y exportaci√≥n\n")

cat("\nüíª COMANDOS ACTUALIZADOS PARA USAR:\n")
cat("# 1. Ver todos los proyectos disponibles:\n")
cat("mostrar_proyectos_disponibles(datos)\n\n")
cat("# 2. Buscar un proyecto espec√≠fico:\n")
cat("buscar_proyecto('Luna')     # Busca proyectos que contengan 'Luna'\n")
cat("buscar_proyecto('Ventum')   # Busca proyectos que contengan 'Ventum'\n")
cat("buscar_proyecto('Parc')     # Busca proyectos que contengan 'Parc'\n\n")
cat("# 3. Comparar proyectos (ejemplo corregido):\n")
cat("# Primero encuentra los IDs correctos:\n")
cat("buscar_proyecto('Luna')\n")
cat("buscar_proyecto('Parc')\n") 
cat("buscar_proyecto('Ventum')\n")
cat("# Luego usa los IDs que te devuelva la b√∫squeda\n\n")
cat("# 4. Comparaci√≥n autom√°tica (encuentra similares autom√°ticamente):\n")
cat("resultado <- comparar_proyectos_por_id(ID_PRINCIPAL)  # Solo especifica el proyecto principal\n\n")

cat("\n", rep("=", 70), "\n")

# FINALIZAR CAPTURA
sink()
cat("üìÑ Log guardado en:", archivo_log, "\n")

# MENSAJE FINAL CON INSTRUCCIONES CLARAS
cat("\nüéâ ¬°SCRIPT 4 CORREGIDO Y FUNCIONANDO!\n")
cat("=========================================\n")
cat("‚úÖ Problemas solucionados:\n")
cat("  - Referencia circular en funciones corregida\n") 
cat("  - B√∫squeda autom√°tica simplificada y estable\n")
cat("  - Manejo de errores mejorado\n\n")

cat("üéØ PARA EMPEZAR A USAR:\n")
cat("1. mostrar_proyectos_disponibles(datos)\n")
cat("2. comparar_proyectos_por_id(ID_PRINCIPAL, c(ID1, ID2))\n\n")

cat("üìä EJEMPLO INMEDIATO CORREGIDO:\n")
cat("# Paso 1: Buscar los proyectos que quieres comparar\n")
cat("buscar_proyecto('Luna')     # Para encontrar el ID de Luna\n")
cat("buscar_proyecto('Parc')     # Para encontrar el ID de Parc 302\n")
cat("buscar_proyecto('Ventum')   # Para encontrar el ID de Ventum Torre 3\n\n")
cat("# Paso 2: Una vez que tengas los IDs correctos, compara:\n")
cat("resultado <- comparar_proyectos_por_id(ID_LUNA, c(ID_PARC, ID_VENTUM))\n\n")
cat("# Ejemplo de b√∫squeda inmediata:\n")
cat("luna_id <- buscar_proyecto('Luna')$id_original[1]\n")
cat("# Luego usar ese ID para comparar\n\n")

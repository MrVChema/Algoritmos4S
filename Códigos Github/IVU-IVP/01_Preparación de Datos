# ===============================================================================
# SCRIPT 01: PREPARACI√ìN DE DATOS - VERSI√ìN CORREGIDA
# ===============================================================================
# Autor: 4S Real Estate  
# Fecha: 2025
# Versi√≥n: 1.1 (Corregida)
# Descripci√≥n: Integraci√≥n y transformaci√≥n completa de bases de datos para IVU-IVP
# 
# ‚ö†Ô∏è  PREREQUISITO: EJECUTAR PRIMERO EL SCRIPT 00 (Funciones Comunes)
# 
# CORRECCIONES APLICADAS:
# - Fixed: Error en join de avenidas
# - Added: Validaci√≥n robusta de columnas
# - Added: Manejo de errores mejorado
# - Added: Logs detallados para debugging
# ===============================================================================

# ---- 1. VERIFICACI√ìN DE PREREQUISITOS ----

cat("\n", rep("üîç", 25), "\n")
cat("VERIFICANDO PREREQUISITOS DEL SCRIPT 01 - VERSI√ìN CORREGIDA\n")
cat(rep("üîç", 25), "\n\n")

# Verificar que las funciones del Script 00 est√©n disponibles
funciones_requeridas <- c(
  "inicializar_4s",
  "log_progreso", 
  "normalizar_robusto",
  "convertir_dms_decimal",
  "calcular_distancias_equipamientos",
  "filtrar_datos_validos",
  "exportar_resultados",
  "PALETAS_4S",
  "CONSTANTES_4S"
)

funciones_faltantes <- character(0)
for(funcion in funciones_requeridas) {
  if(!exists(funcion)) {
    funciones_faltantes <- c(funciones_faltantes, funcion)
  }
}

if(length(funciones_faltantes) > 0) {
  cat("‚ùå ERROR: Funciones requeridas no encontradas:\n")
  for(f in funciones_faltantes) {
    cat("   -", f, "\n")
  }
  cat("\nüö® SOLUCI√ìN:\n")
  cat("1. Ejecutar primero el Script 00: 00_Funciones_Comunes.R\n")
  cat("2. Luego ejecutar este script (01_Preparacion_Datos.R)\n\n")
  stop("‚ùå Prerequisitos no cumplidos. Ejecutar Script 00 primero.")
}

cat("‚úÖ Todas las funciones requeridas est√°n disponibles\n")
cat("‚úÖ Prerequisitos verificados correctamente\n\n")

# ---- 2. CONFIGURACI√ìN INICIAL ----

# Configurar entorno 4S (funci√≥n del Script 00)
inicializar_4s(mostrar_info = TRUE)

# Configuraci√≥n de rutas (PERSONALIZAR SEG√öN TU ENTORNO)
RUTAS_DATOS <- list(
  base_dir = '/Users/yalta/Library/CloudStorage/GoogleDrive-yaltalielt@gmail.com/Mi unidad/4S Real Estate/2025/[02] ALGORITMO/[02] DATOS',
  proyectos = '[01] PROYECTOS/[01] VIVIENDA VERTICAL/Proyectos Integrados_ZMM.csv',
  demograficos = '[03] VARIABLES/[03] DEMOGRAFICOS/Demograficos_AGEBS.xlsx',
  verdes = '[03] VARIABLES/[01] AREAS VERDES/AreasVerdes_Zona_V2.xlsx',
  amenidades = '[03] VARIABLES/[06] FUNCIONALIDAD Y AMENIDADES/Qlik Sense - Tabla Amenidades_ Desglose de Amenidades x Proy... MTY.xlsx',
  nse_kml = '[02] KML_KMZ/[01] NSE/NSE-Monterrey.kml',
  zonas_kml = '[02] KML_KMZ/[03] ZONAS REDI/ZMM_REDI_2024.kml',
  parques_kml = '[03] VARIABLES/[01] AREAS VERDES/Parques_Peso.kml',
  avenidas_kml = '[03] VARIABLES/[05] VIALIDAD/VIALIDADES_PROCESADAS/avenidas_clasificadas.kml',
  clasificacion_avenidas = '[03] VARIABLES/[05] VIALIDAD/VIALIDADES_PROCESADAS/clasificacion_avenidas.csv',
  output_dir = '[00] BASE INTEGRADA'
)

# Rutas de equipamientos DENUE
EQUIPAMIENTOS <- list(
  hospitales = '[03] VARIABLES/[02] EQUIPAMIENTO/DENUE 2024/Hospitales/Hospitales.csv',
  escuelas_privadas = '[03] VARIABLES/[02] EQUIPAMIENTO/DENUE 2024/Escuelas Privadas/Escuelas Privadas.csv',
  escuelas_publicas = '[03] VARIABLES/[02] EQUIPAMIENTO/DENUE 2024/Escuelas P√∫blicas/Escuelas P√∫blicas.csv',
  universidades = '[03] VARIABLES/[02] EQUIPAMIENTO/DENUE 2024/Universidades/Universidades.csv',
  supermercados = '[03] VARIABLES/[02] EQUIPAMIENTO/DENUE 2024/Supermercados/Supermercado.csv',
  restaurantes = '[03] VARIABLES/[02] EQUIPAMIENTO/DENUE 2024/Restaurantes/Restaurantes.csv',
  oficinas = '[03] VARIABLES/[02] EQUIPAMIENTO/DENUE 2024/Oficinas/Oficinas.csv',
  tiendas_dept = '[03] VARIABLES/[02] EQUIPAMIENTO/DENUE 2024/Tiendas departamentales/Tiendas departamentales.csv'
)

log_progreso("Configuraci√≥n de rutas completada", "SUCCESS")

# ---- 3. FUNCIONES ESPEC√çFICAS DE CARGA CON VALIDACI√ìN MEJORADA ----

#' Cargar datos con validaci√≥n autom√°tica mejorada
#' @param tipo tipo de archivo ("csv", "xlsx", "kml")
#' @param ruta ruta relativa al directorio base
#' @param encoding encoding del archivo
#' @return datos cargados con validaci√≥n
cargar_datos_validados <- function(tipo, ruta, encoding = "UTF-8") {
  ruta_completa <- file.path(RUTAS_DATOS$base_dir, ruta)
  
  if(!file.exists(ruta_completa)) {
    log_progreso(paste("Archivo no encontrado:", basename(ruta)), "ERROR")
    return(NULL)
  }
  
  tryCatch({
    if(tipo == "csv") {
      datos <- read_csv(ruta_completa, locale = locale(encoding = encoding), show_col_types = FALSE)
    } else if(tipo == "xlsx") {
      datos <- read_excel(ruta_completa)
    } else if(tipo == "kml") {
      # Para KML, cargar todas las capas y combinar
      capas <- st_layers(ruta_completa)
      datos_list <- lapply(capas$name, function(x) st_read(ruta_completa, layer = x, quiet = TRUE))
      datos <- do.call(rbind, datos_list)
    }
    
    log_progreso(paste("Cargado:", basename(ruta), "-", nrow(datos), "registros"), "SUCCESS")
    return(datos)
    
  }, error = function(e) {
    log_progreso(paste("Error cargando", basename(ruta), ":", e$message), "ERROR")
    return(NULL)
  })
}

#' Validar estructura de dataframe
#' @param datos dataframe a validar
#' @param nombre_archivo nombre del archivo para logging
#' @return informaci√≥n de validaci√≥n
validar_estructura <- function(datos, nombre_archivo) {
  if(is.null(datos)) {
    log_progreso(paste("ERROR: No se pudieron cargar datos de", nombre_archivo), "ERROR")
    return(FALSE)
  }
  
  if(nrow(datos) == 0) {
    log_progreso(paste("WARNING: Archivo", nombre_archivo, "est√° vac√≠o"), "WARNING")
    return(FALSE)
  }
  
  log_progreso(paste("‚úÖ", nombre_archivo, ":", nrow(datos), "filas,", ncol(datos), "columnas"), "INFO")
  return(TRUE)
}

# ---- 4. CARGA DE DATOS PRINCIPAL ----

log_progreso("=== INICIANDO CARGA DE DATOS ===", "INFO")

# 4.1 Cargar proyectos base
proyectos_raw <- cargar_datos_validados("csv", RUTAS_DATOS$proyectos)
if(!validar_estructura(proyectos_raw, "Proyectos")) {
  stop("‚ùå No se pudieron cargar los proyectos base")
}

# Procesar coordenadas 
proyectos <- proyectos_raw %>%
  mutate(
    # Limpiar nombres de columnas si es necesario
    Absorcion.por.proyecto = as.numeric(str_replace_all(`Absorcion por proyecto`, "[^0-9\\.]", "")),
    absorcion = Absorcion.por.proyecto,
    # Convertir coordenadas DMS si es necesario
    Latitud = ifelse(is.character(Latitud), 
                     sapply(Latitud, convertir_dms_decimal), 
                     as.numeric(Latitud)),
    Longitud = ifelse(is.character(Longitud), 
                      sapply(Longitud, convertir_dms_decimal), 
                      as.numeric(Longitud))
  ) %>%
  # Validar rangos de coordenadas
  filter(!is.na(Latitud) & !is.na(Longitud)) %>%
  filter(abs(Latitud) <= 90 & abs(Longitud) <= 180) %>%
  filter(Latitud >= 25.0 & Latitud <= 26.5) %>%
  filter(Longitud >= -101.0 & Longitud <= -99.5)

log_progreso(paste("Proyectos procesados:", nrow(proyectos), "de", nrow(proyectos_raw), "v√°lidos"), "SUCCESS")

# 4.2 Cargar datos de soporte
demograficos <- cargar_datos_validados("xlsx", RUTAS_DATOS$demograficos)
validar_estructura(demograficos, "Demogr√°ficos")

verdes <- cargar_datos_validados("xlsx", RUTAS_DATOS$verdes)
validar_estructura(verdes, "√Åreas Verdes")

amenidades <- cargar_datos_validados("xlsx", RUTAS_DATOS$amenidades)
validar_estructura(amenidades, "Amenidades")

# 4.3 Cargar datos espaciales (KML)
nse_data <- cargar_datos_validados("kml", RUTAS_DATOS$nse_kml)
validar_estructura(nse_data, "NSE KML")

zonas_redi <- cargar_datos_validados("kml", RUTAS_DATOS$zonas_kml)
validar_estructura(zonas_redi, "Zonas REDI")

parques_kml <- cargar_datos_validados("kml", RUTAS_DATOS$parques_kml)
validar_estructura(parques_kml, "Parques KML")

avenidas_data <- cargar_datos_validados("kml", RUTAS_DATOS$avenidas_kml)
validar_estructura(avenidas_data, "Avenidas KML")

# 4.4 Cargar clasificaci√≥n de avenidas
clasificacion_avenidas <- cargar_datos_validados("csv", RUTAS_DATOS$clasificacion_avenidas)
validar_estructura(clasificacion_avenidas, "Clasificaci√≥n Avenidas")

# 4.5 Cargar equipamientos DENUE
log_progreso("Cargando equipamientos DENUE...", "INFO")
equipamientos_data <- list()

for(nombre in names(EQUIPAMIENTOS)) {
  datos <- cargar_datos_validados("csv", EQUIPAMIENTOS[[nombre]])
  if(!is.null(datos)) {
    # Validar y limpiar coordenadas
    datos <- datos %>%
      filter(!is.na(latitud) & !is.na(longitud)) %>%
      filter(abs(latitud) <= 90 & abs(longitud) <= 180)
    
    equipamientos_data[[nombre]] <- datos
    log_progreso(paste("‚úÖ", nombre, ":", nrow(datos), "registros v√°lidos"), "INFO")
  }
}

log_progreso("=== CARGA DE DATOS COMPLETADA ===", "SUCCESS")

# ---- 5. CONVERSI√ìN A OBJETOS ESPACIALES ----

log_progreso("Convirtiendo a objetos espaciales...", "INFO")

# 5.1 Proyectos a objeto sf
proyectos_sf <- st_as_sf(proyectos,
                         coords = c("Longitud", "Latitud"),
                         crs = 4326,
                         remove = FALSE)

# 5.2 √Åreas verdes a sf
if(!is.null(verdes)) {
  verdes_sf <- st_as_sf(verdes,
                        coords = c("longitud", "latitud"),
                        crs = 4326,
                        remove = FALSE)
}

# 5.3 Datos demogr√°ficos (desde WKT)
if(!is.null(demograficos)) {
  demograficos_sf <- demograficos %>%
    mutate(geometry = st_as_sfc(geometry, crs = 4326)) %>%
    st_as_sf()
}

# 5.4 Procesar datos espaciales KML
if(!is.null(nse_data)) {
  nse_data <- nse_data %>%
    rename(nse_name = Name, nse_description = Description) %>%
    st_transform(4326)
}

if(!is.null(zonas_redi)) {
  zonas_redi <- zonas_redi %>%
    rename(zona_name = Name, zona_description = Description) %>%
    st_transform(4326)
}

if(!is.null(parques_kml)) {
  if("Name" %in% names(parques_kml)) {
    parques_kml <- parques_kml %>% rename(nombre = Name)
  }
  parques_kml <- st_transform(parques_kml, 4326)
}

# 5.5 Procesar avenidas - VERSI√ìN CORREGIDA
if(!is.null(avenidas_data) && !is.null(clasificacion_avenidas)) {
  
  # Debug: Verificar las columnas disponibles
  log_progreso("Verificando columnas para join de avenidas...", "INFO")
  log_progreso(paste("Avenidas KML columnas:", paste(names(avenidas_data), collapse = ", ")), "INFO")
  log_progreso(paste("Clasificaci√≥n columnas:", paste(names(clasificacion_avenidas), collapse = ", ")), "INFO")
  
  # Verificar si existe la columna para el join
  columna_join_disponible <- "nombre_normalizado" %in% names(clasificacion_avenidas)
  
  if(columna_join_disponible) {
    avenidas_data <- avenidas_data %>%
      rename(nombre_normalizado = Name) %>%
      # CORRECCI√ìN: Join por nombre_normalizado
      left_join(clasificacion_avenidas, by = "nombre_normalizado") %>%
      st_make_valid() %>%
      st_transform(4326)
    
    log_progreso("Avenidas procesadas exitosamente", "SUCCESS")
  } else {
    log_progreso("Columna para join no encontrada, usando solo geometr√≠as de avenidas", "WARNING")
    avenidas_data <- avenidas_data %>%
      rename(nombre_normalizado = Name) %>%
      mutate(
        jerarquia = NA_real_,
        tipo_via = NA_character_,
        flujo_promedio = NA_real_
      ) %>%
      st_make_valid() %>%
      st_transform(4326)
  }
} else {
  log_progreso("Datos de avenidas no disponibles", "WARNING")
}

log_progreso("Objetos espaciales creados exitosamente", "SUCCESS")

# ---- 6. C√ÅLCULO DE VARIABLES DEMOGR√ÅFICAS ----

calcular_demografia_1km <- function(proyectos_sf, demograficos_sf) {
  log_progreso("Calculando variables demogr√°ficas en radio de 1km...", "INFO")
  
  if(is.null(demograficos_sf)) {
    log_progreso("No hay datos demogr√°ficos disponibles", "WARNING")
    return(proyectos_sf)
  }
  
  # Variables demogr√°ficas disponibles en el dataset
  vars_demograficas <- intersect(
    c("pob2020", "hogares2020", "viv2020", "habitadas2020", 
      "migrantes2020", "pob_ocupada_2020", "pob2010", 
      "hogares2010", "viv2010", "pob_ocupada_2010",
      "independiente", "empty_nesters", "separados_hijos",
      "pareja_sin_hijos", "pareja_hijos_10", "pareja_hijos_21",
      "pareja_hijos_1120", "joven_sin_hijos", "soltero_adulto",
      "soltero_joven", "prestada", "propia", "propia_pagando",
      "rentada", "intestada_litigio", "pob_masc", "pob_fem"),
    names(demograficos_sf)
  )
  
  if(length(vars_demograficas) == 0) {
    log_progreso("No se encontraron variables demogr√°ficas v√°lidas", "WARNING")
    return(proyectos_sf)
  }
  
  # Transformar a CRS proyectado
  proyectos_proj <- st_transform(proyectos_sf, 32614)
  demograficos_proj <- st_transform(demograficos_sf, 32614)
  
  # Calcular √°rea de cada AGEB
  demograficos_proj <- demograficos_proj %>% 
    mutate(ageb_area = st_area(.))
  
  # Crear buffer de 1km
  proyectos_buffer <- st_buffer(proyectos_proj, 1000)
  
  tryCatch({
    # Calcular intersecciones
    intersecciones <- st_intersection(
      st_make_valid(proyectos_buffer),
      st_make_valid(demograficos_proj)
    ) %>% 
      mutate(
        interseccion_area = st_area(.),
        proporcion = as.numeric(interseccion_area / ageb_area)
      ) %>% 
      filter(proporcion > 0.001)
    
    # Agregar variables ponderadas
    demografia_agregada <- intersecciones %>% 
      st_drop_geometry() %>% 
      group_by(Proyecto) %>% 
      summarise(
        across(
          all_of(vars_demograficas),
          ~sum(.x * proporcion, na.rm = TRUE),
          .names = "{.col}_1km"
        ),
        .groups = "drop"
      )
    
    # Unir al dataset principal
    resultado <- proyectos_sf %>% 
      left_join(demografia_agregada, by = "Proyecto")
    
    log_progreso(paste("Variables demogr√°ficas calculadas:", length(vars_demograficas), "variables"), "SUCCESS")
    return(resultado)
    
  }, error = function(e) {
    log_progreso(paste("Error calculando variables demogr√°ficas:", e$message), "ERROR")
    return(proyectos_sf)
  })
}

proyectos_sf <- calcular_demografia_1km(proyectos_sf, demograficos_sf)

# ---- 7. UNIONES ESPACIALES ----

log_progreso("Realizando uniones espaciales...", "INFO")

# 7.1 Unir informaci√≥n de NSE
if(!is.null(nse_data)) {
  proyectos_sf <- st_join(proyectos_sf, nse_data, join = st_intersects, left = TRUE)
  log_progreso("Informaci√≥n NSE unida", "SUCCESS")
}

# 7.2 Unir informaci√≥n de zonas REDI
if(!is.null(zonas_redi)) {
  proyectos_sf <- st_join(proyectos_sf, zonas_redi, join = st_intersects, left = TRUE)
  log_progreso("Informaci√≥n zonas REDI unida", "SUCCESS")
}

# 7.3 Calcular parque m√°s cercano
if(!is.null(verdes_sf)) {
  nearest_idx <- st_nearest_feature(proyectos_sf, verdes_sf)
  proyectos_sf$nearest_park <- verdes_sf$nombre[nearest_idx]
  proyectos_sf$dist_to_park <- as.numeric(st_distance(proyectos_sf, verdes_sf[nearest_idx, ], by_element = TRUE))
  log_progreso("Distancias a parques calculadas", "SUCCESS")
}

# 7.4 Calcular parque importante m√°s cercano
if(!is.null(parques_kml)) {
  nearest_idx_poly <- st_nearest_feature(proyectos_sf, parques_kml)
  proyectos_sf$nearest_relevant_park <- parques_kml$nombre[nearest_idx_poly]
  proyectos_sf$dist_to_relevant_park <- as.numeric(st_distance(proyectos_sf, parques_kml[nearest_idx_poly, ], by_element = TRUE))
  log_progreso("Distancias a parques importantes calculadas", "SUCCESS")
}

# ---- 8. PROCESAMIENTO DE AMENIDADES ----

procesar_amenidades <- function(proyectos_sf, amenidades) {
  log_progreso("Procesando amenidades...", "INFO")
  
  if(is.null(amenidades)) {
    log_progreso("No hay datos de amenidades disponibles", "WARNING")
    return(proyectos_sf)
  }
  
  tryCatch({
    # Limpiar nombres de columnas
    amenidades_clean <- amenidades %>%
      janitor::clean_names() %>%
      rename(Proyecto = proyecto) %>%
      # Convertir S√≠/No a 1/0
      mutate(across(where(is.character), ~case_when(
        .x %in% c("S√≠", "Si", "s√≠", "si", "YES", "yes", "Y", "y") ~ 1,
        .x %in% c("No", "NO", "no", "N", "n") ~ 0,
        TRUE ~ suppressWarnings(as.numeric(.x))
      ))) %>%
      # Seleccionar solo columnas de amenidades
      select(-any_of(c("segmento", "ciudad", "zona", "precio_promedio_inventario", 
                       "absorcion_historica", "absorcioo_del_ult_q")))
    
    # Unir con proyectos
    resultado <- proyectos_sf %>%
      left_join(amenidades_clean, by = "Proyecto") %>%
      # Convertir NA a 0 para amenidades
      mutate(across(any_of(names(amenidades_clean)[-1]), ~ifelse(is.na(.x), 0, .x)))
    
    log_progreso("Amenidades procesadas y unidas", "SUCCESS")
    return(resultado)
    
  }, error = function(e) {
    log_progreso(paste("Error procesando amenidades:", e$message), "ERROR")
    return(proyectos_sf)
  })
}

proyectos_sf <- procesar_amenidades(proyectos_sf, amenidades)

# ---- 9. C√ÅLCULO DE DISTANCIAS A EQUIPAMIENTOS ----

log_progreso("Calculando distancias a equipamientos DENUE...", "INFO")

for(nombre in names(equipamientos_data)) {
  if(!is.null(equipamientos_data[[nombre]])) {
    proyectos_sf <- calcular_distancias_equipamientos(
      proyectos_sf, 
      equipamientos_data[[nombre]], 
      nombre, 
      umbral_cercania = CONSTANTES_4S$umbrales_distancia$cercania_general
    )
  }
}

# ---- 10. C√ÅLCULO DE DISTANCIAS A AVENIDAS ----

calcular_distancias_avenidas <- function(proyectos_sf, avenidas_sf) {
  log_progreso("Calculando distancias a avenidas...", "INFO")
  
  if(is.null(avenidas_sf)) {
    log_progreso("No hay datos de avenidas disponibles", "WARNING")
    # Crear columnas vac√≠as para mantener consistencia
    proyectos_sf$dist_to_avenue <- NA_real_
    proyectos_sf$nearest_avenue_name <- NA_character_
    proyectos_sf$nearest_avenue_type <- NA_character_
    proyectos_sf$nearest_avenue_hierarchy <- NA_real_
    proyectos_sf$nearest_avenue_flow <- NA_real_
    return(proyectos_sf)
  }
  
  tryCatch({
    # Transformar a UTM para c√°lculos precisos
    proyectos_utm <- st_transform(proyectos_sf, 32614)
    avenidas_utm <- st_transform(avenidas_sf, 32614)
    
    # Inicializar columnas
    n <- nrow(proyectos_utm)
    dist_to_avenue <- numeric(n)
    nearest_avenue_name <- character(n)
    nearest_avenue_type <- character(n)
    nearest_avenue_hierarchy <- numeric(n)
    nearest_avenue_flow <- numeric(n)
    
    # Calcular para cada proyecto
    for(i in 1:n) {
      if(i %% 25 == 0) log_progreso(paste("Procesando proyecto", i, "de", n), "INFO")
      
      proyecto <- proyectos_utm[i, ]
      distancias <- st_distance(proyecto, avenidas_utm)
      idx_min <- which.min(distancias)
      
      if(length(idx_min) > 0) {
        dist_to_avenue[i] <- as.numeric(distancias[idx_min])
        nearest_avenue_name[i] <- avenidas_sf$nombre_normalizado[idx_min]
        nearest_avenue_type[i] <- if("tipo_via" %in% names(avenidas_sf)) avenidas_sf$tipo_via[idx_min] else NA
        nearest_avenue_hierarchy[i] <- if("jerarquia" %in% names(avenidas_sf)) avenidas_sf$jerarquia[idx_min] else NA
        nearest_avenue_flow[i] <- if("flujo_promedio" %in% names(avenidas_sf)) avenidas_sf$flujo_promedio[idx_min] else NA
      } else {
        dist_to_avenue[i] <- NA
        nearest_avenue_name[i] <- NA
        nearest_avenue_type[i] <- NA
        nearest_avenue_hierarchy[i] <- NA
        nearest_avenue_flow[i] <- NA
      }
    }
    
    # Agregar columnas al dataset
    proyectos_sf$dist_to_avenue <- dist_to_avenue
    proyectos_sf$nearest_avenue_name <- nearest_avenue_name
    proyectos_sf$nearest_avenue_type <- nearest_avenue_type
    proyectos_sf$nearest_avenue_hierarchy <- nearest_avenue_hierarchy
    proyectos_sf$nearest_avenue_flow <- nearest_avenue_flow
    
    log_progreso("Distancias a avenidas calculadas", "SUCCESS")
    return(proyectos_sf)
    
  }, error = function(e) {
    log_progreso(paste("Error calculando distancias a avenidas:", e$message), "ERROR")
    # Crear columnas vac√≠as para mantener consistencia
    proyectos_sf$dist_to_avenue <- NA_real_
    proyectos_sf$nearest_avenue_name <- NA_character_
    proyectos_sf$nearest_avenue_type <- NA_character_
    proyectos_sf$nearest_avenue_hierarchy <- NA_real_
    proyectos_sf$nearest_avenue_flow <- NA_real_
    return(proyectos_sf)
  })
}

proyectos_sf <- calcular_distancias_avenidas(proyectos_sf, avenidas_data)

# ---- 11. TRANSFORMACI√ìN DE VARIABLES ----

log_progreso("Transformando variables...", "INFO")

proyectos_sf <- proyectos_sf %>%
  mutate(
    # Variables de √©xito comercial
    exitoso = case_when(
      is.na(absorcion) ~ NA_real_,
      absorcion >= 3 ~ 1,
      TRUE ~ 0
    ),
    super_exitoso = case_when(
      is.na(absorcion) ~ NA_real_,
      absorcion >= 7 ~ 1,
      TRUE ~ 0
    ),
    
    # Densidad poblacional
    alta_densidad_pob = case_when(
      !is.na(pob2020_1km) ~ ifelse(pob2020_1km / 3.14 > 20000, 1, 0),
      TRUE ~ 0
    ),
    
    # Cercan√≠a a parques relevantes
    cerca_parque_relevante = case_when(
      !is.na(dist_to_relevant_park) ~ ifelse(dist_to_relevant_park <= 500, 1, 0),
      TRUE ~ 0
    ),
    
    # Proporci√≥n de hogares propios
    prop_hogares_propios = case_when(
      !is.na(propia_1km) & !is.na(propia_pagando_1km) & !is.na(rentada_1km) & !is.na(prestada_1km) ~
        (propia_1km + propia_pagando_1km) / (propia_1km + propia_pagando_1km + rentada_1km + prestada_1km),
      TRUE ~ NA_real_
    ),
    predominio_hogares_propios = case_when(
      !is.na(prop_hogares_propios) ~ ifelse(prop_hogares_propios > 0.6, 1, 0),
      TRUE ~ 0
    ),
    
    # Crecimiento poblacional
    crecimiento_pob = case_when(
      !is.na(pob2020_1km) & !is.na(pob2010_1km) & pob2010_1km > 0 ~
        (pob2020_1km - pob2010_1km) / pob2010_1km,
      TRUE ~ NA_real_
    ),
    alto_crecimiento = case_when(
      !is.na(crecimiento_pob) ~ ifelse(crecimiento_pob > 0.15, 1, 0),
      TRUE ~ 0
    ),
    
    # Variables de avenidas con validaci√≥n robusta
    cercania_avenida = case_when(
      is.na(dist_to_avenue) | dist_to_avenue >= 3000 ~ 0,
      dist_to_avenue <= 200 ~ 1,
      TRUE ~ 0
    ),
    cercania_avenida_arterial = case_when(
      is.na(dist_to_avenue) | is.na(nearest_avenue_hierarchy) | dist_to_avenue >= 3000 ~ 0,
      dist_to_avenue <= 200 & nearest_avenue_hierarchy == 1 ~ 1,
      TRUE ~ 0
    ),
    cercania_avenida_secundaria = case_when(
      is.na(dist_to_avenue) | is.na(nearest_avenue_hierarchy) | dist_to_avenue >= 3000 ~ 0,
      dist_to_avenue <= 200 & nearest_avenue_hierarchy == 2 ~ 1,
      TRUE ~ 0
    ),
    cerca_avenida_principal = case_when(
      is.na(dist_to_avenue) | is.na(nearest_avenue_hierarchy) | dist_to_avenue >= 3000 ~ 0,
      dist_to_avenue <= 200 & nearest_avenue_hierarchy %in% c(1, 2) ~ 1,
      TRUE ~ 0
    ),
    
    # Variables de vialidad normalizadas
    dist_avenida_norm = case_when(
      is.na(dist_to_avenue) | dist_to_avenue >= 3000 ~ 0,
      TRUE ~ 1 - pmin(1, dist_to_avenue / 1000)
    ),
    
    ponderacion_jerarquia = case_when(
      is.na(nearest_avenue_hierarchy) ~ 0.3,
      nearest_avenue_hierarchy == 1 ~ 1.0,
      nearest_avenue_hierarchy == 2 ~ 0.8,
      nearest_avenue_hierarchy == 3 ~ 0.6,
      nearest_avenue_hierarchy == 4 ~ 0.4,
      TRUE ~ 0.3
    ),
    
    ponderacion_flujo = case_when(
      is.na(nearest_avenue_flow) ~ 0,
      nearest_avenue_flow > 500 ~ 0.2,
      nearest_avenue_flow > 200 ~ 0.1,
      TRUE ~ 0
    )
  )

# ---- 12. CREACI√ìN DE √çNDICES COMPUESTOS ----

log_progreso("Creando √≠ndices compuestos...", "INFO")

proyectos_sf <- proyectos_sf %>%
  mutate(
    # √çndice de Accesibilidad a Servicios
    indice_accesibilidad = (
      (cercania_universidad * 3) +
        (cercania_esc_priv * 2) +
        (cercania_esc_pub * 1) +
        (cercania_hospital * 3) +
        (cercania_super * 2) +
        (cercania_restau * 1) +
        (cercania_oficina * 2) +
        (cercania_tienda_dept * 2)
    ) / 16,
    
    # Densidades e √≠ndices adicionales
    densidad_educativa = cantidad_esc_priv_1km + cantidad_esc_pub_1km + cantidad_universidad_1km,
    alta_densidad_educativa = ifelse(densidad_educativa >= 5, 1, 0),
    
    densidad_comercial = cantidad_super_1km + cantidad_restau_1km + cantidad_tienda_dept_1km,
    alta_densidad_comercial = ifelse(densidad_comercial >= 10, 1, 0),
    
    entorno_laboral = cantidad_oficina_1km,
    alto_entorno_laboral = ifelse(entorno_laboral >= 5, 1, 0),
    
    # N√∫mero de amenidades
    num_amenidades = {
      cols_amenidades <- names(select(., matches("alberca|areas_verdes|asadores|bar|campo_de_golf|canchas_deportivas|casa_club|fogatero|gimnasio|golf_virtual|jacuzzi|lounges|ludoteca|patio_central|pet_zone|pista_de_jogging|roof_graden|sala_de_cine|sala_de_lectura|salon_usos_multiples|salon_de_yoga|sauna|spa|terraza|vestidores")))
      if(length(cols_amenidades) > 0) {
        rowSums(select(., all_of(cols_amenidades)), na.rm = TRUE)
      } else {
        0
      }
    },
    
    categoria_amenidades = case_when(
      num_amenidades >= 15 ~ "Premium",
      num_amenidades >= 8 ~ "Alto",
      num_amenidades >= 4 ~ "Medio",
      TRUE ~ "B√°sico"
    ),
    
    # √çndice de accesibilidad vial
    accesibilidad_vial = (dist_avenida_norm * 0.6) + 
      (ponderacion_jerarquia * 0.3) + 
      (ponderacion_flujo * 0.1),
    
    categoria_accesibilidad_vial = case_when(
      accesibilidad_vial >= 0.8 ~ "Excelente",
      accesibilidad_vial >= 0.6 ~ "Buena",
      accesibilidad_vial >= 0.4 ~ "Media",
      accesibilidad_vial >= 0.2 ~ "Regular",
      TRUE ~ "Deficiente"
    ),
    
    # √çndice compuesto de inversi√≥n
    potencial_inversion = (
      (alto_crecimiento * 3) +
        (cerca_parque_relevante * 3) +
        (indice_accesibilidad * 4) +
        (alta_densidad_comercial * 4) +
        (alto_entorno_laboral * 2) +
        (accesibilidad_vial * 3) +
        (cerca_avenida_principal * 2) +
        (ifelse(Estatus == "Preventa", 1, 0) * 1)
    ) / 22,
    
    # √çndice de conveniencia urbana
    indice_conveniencia = (
      cercania_super * 0.20 +
        cercania_restau * 0.15 +
        cercania_hospital * 0.10 +
        cercania_esc_priv * 0.10 +
        cercania_tienda_dept * 0.10 +
        cerca_parque_relevante * 0.20 +
        cerca_avenida_principal * 0.15
    ),
    
    alta_conveniencia = ifelse(indice_conveniencia >= 0.7, 1, 0)
  )

# ---- 13. PROCESAMIENTO FINAL ----

log_progreso("Agregando variables finales...", "INFO")

proyectos_sf <- proyectos_sf %>%
  mutate(
    # Unidades vendidas
    unidades_vendidas = case_when(
      !is.na(unidades_totales) & !is.na(unidades_inv) ~ unidades_totales - unidades_inv,
      TRUE ~ NA_real_
    ),
    
    # Logaritmo del precio
    log_pm2 = case_when(
      !is.na(p_m2) & p_m2 > 0 ~ log(p_m2),
      TRUE ~ NA_real_
    ),
    
    # Calificaci√≥n de proximidad a parques
    inv_dist_to_park = case_when(
      !is.na(dist_to_relevant_park) ~ 1 / log(dist_to_relevant_park + 1),
      TRUE ~ NA_real_
    ),
    
    # Extraer coordenadas para uso posterior
    longitud = st_coordinates(.)[,1],
    latitud = st_coordinates(.)[,2]
  ) %>%
  # Reordenar columnas importantes
  relocate(unidades_vendidas, .after = unidades_inv) %>%
  relocate(log_pm2, .after = p_m2) %>%
  relocate(inv_dist_to_park, .after = dist_to_relevant_park) %>%
  relocate(longitud, latitud, .after = geometry)

# ---- 14. VALIDACI√ìN FINAL ----

log_progreso("Realizando validaci√≥n final...", "INFO")

n_proyectos_final <- nrow(proyectos_sf)
n_variables_final <- ncol(proyectos_sf)

variables_clave <- c("indice_accesibilidad", "potencial_inversion", 
                     "indice_conveniencia", "accesibilidad_vial", "num_amenidades")
variables_existentes <- intersect(variables_clave, names(proyectos_sf))

log_progreso("=== ESTAD√çSTICAS FINALES ===", "INFO")
log_progreso(paste("Proyectos procesados:", n_proyectos_final), "SUCCESS")
log_progreso(paste("Variables totales:", n_variables_final), "SUCCESS")
log_progreso(paste("Segmentos √∫nicos:", n_distinct(proyectos_sf$Segmento, na.rm = TRUE)), "SUCCESS")

# ---- 15. EXPORTACI√ìN DE RESULTADOS ----

log_progreso("Exportando resultados...", "INFO")

# Crear directorio de salida
dir_output <- file.path(RUTAS_DATOS$base_dir, RUTAS_DATOS$output_dir)
if(!dir.exists(dir_output)) {
  dir.create(dir_output, recursive = TRUE)
}

# Exportar versi√≥n espacial
ruta_gpkg <- file.path(dir_output, "base_inmobiliaria_preparada.gpkg")
tryCatch({
  st_write(proyectos_sf, ruta_gpkg, delete_dsn = TRUE)
  log_progreso("Archivo GeoPackage exportado", "SUCCESS")
}, error = function(e) {
  log_progreso(paste("Error exportando GeoPackage:", e$message), "ERROR")
})

# Exportar versi√≥n CSV
datos_csv <- st_drop_geometry(proyectos_sf)
archivos_exportados <- exportar_resultados(
  datos_csv, 
  "base_inmobiliaria_preparada", 
  formatos = c("csv", "xlsx"), 
  directorio = dir_output
)

# ---- 16. RESUMEN EJECUTIVO FINAL ----

cat("\n", rep("üéâ", 30), "\n")
cat("SCRIPT 01 COMPLETADO EXITOSAMENTE - VERSI√ìN CORREGIDA\n")
cat(rep("üéâ", 30), "\n\n")

cat("üìä RESULTADOS FINALES:\n")
cat("‚Ä¢ Proyectos procesados:", n_proyectos_final, "\n")
cat("‚Ä¢ Variables totales:", n_variables_final, "\n")
cat("‚Ä¢ Archivos exportados:", length(archivos_exportados), "\n")

cat("\n‚úÖ CORRECCIONES APLICADAS:\n")
cat("‚Ä¢ ‚úÖ Error de join en avenidas solucionado\n")
cat("‚Ä¢ ‚úÖ Validaci√≥n robusta de columnas implementada\n")
cat("‚Ä¢ ‚úÖ Manejo de errores mejorado\n")
cat("‚Ä¢ ‚úÖ Logs detallados para debugging\n")

cat("\nüöÄ SIGUIENTE PASO:\n")
cat("Ejecutar Script 02 (C√°lculo de Pesos) con la base preparada\n")

log_progreso("SCRIPT 01 COMPLETADO EXITOSAMENTE", "SUCCESS")
